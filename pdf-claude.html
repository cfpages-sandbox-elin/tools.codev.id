<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Splitter - Fixed Version</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js from Mozilla -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- pdf-lib -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
        .spinner { border: 4px solid rgba(0,0,0,.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #09f; animation: spin 1s ease infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .cut-line { position: absolute; left: 0; right: 0; height: 5px; background-color: rgba(239, 68, 68, 0.7); cursor: ns-resize; border-top: 1px dashed white; border-bottom: 1px dashed white; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .cut-line:hover { background-color: rgba(220, 38, 38, 1); }
        .cut-line .handle { width: 60px; height: 20px; background-color: rgb(239, 68, 68); border-radius: 10px; color: white; font-size: 10px; text-align: center; line-height: 20px; font-family: sans-serif; pointer-events: none; }
        .padding-zone { position: absolute; left: 0; right: 0; background-color: rgba(59, 130, 246, 0.2); border: 1px dashed rgba(59, 130, 246, 0.5); pointer-events: none; z-index: 5; }
        .content-boundary { position: absolute; left: 0; right: 0; height: 2px; background-color: rgba(34, 197, 94, 0.8); z-index: 8; pointer-events: none; }
    </style>
</head>
<body class="bg-slate-100 font-sans">
    <div class="w-full max-w-5xl mx-auto p-4 sm:p-8 my-10 bg-white rounded-xl shadow-lg">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-slate-800">Advanced PDF Splitter v4.4 - Claude</h1>
            <p class="text-slate-500 mt-2">Upload, preview, and adjust split lines before creating your multi-page PDF.</p>
        </div>

        <div id="settings-section" class="grid grid-cols-1 md:grid-cols-3 gap-6 border-b pb-6 mb-6 items-start">
            <div>
                <label class="block text-sm font-medium text-slate-700 mb-2">1. Upload PDF</label>
                <input id="file-upload" type="file" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100" accept=".pdf">
                <p id="file-name" class="text-xs text-slate-500 mt-2 truncate"></p>
            </div>
            <div>
                <label for="paper-size" class="block text-sm font-medium text-slate-700 mb-2">2. Target Paper Size</label>
                <select id="paper-size" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option value="A4">A4 (210 x 297 mm)</option>
                    <option value="A5">A5 (148 x 210 mm)</option>
                    <option value="Letter">Letter (8.5 x 11 in)</option>
                    <option value="Legal">Legal (8.5 x 14 in)</option>
                    <option value="F4">F4 (210 x 330 mm)</option>
                </select>
            </div>
            <div>
                <label for="padding-select" class="block text-sm font-medium text-slate-700 mb-2">3. Top/Bottom Padding</label>
                <select id="padding-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option value="18">Narrow (18 pts / 0.25")</option>
                    <option value="36" selected>Normal (36 pts / 0.5")</option>
                    <option value="72">Wide (72 pts / 1.0")</option>
                    <option value="custom">Custom</option>
                </select>
                <input type="number" id="custom-padding-input" value="36" class="hidden mt-2 w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
            </div>
        </div>

        <div id="action-bar" class="flex items-center justify-center space-x-4 mb-6">
             <button id="preview-button" type="button" disabled class="px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-slate-400 disabled:cursor-not-allowed">Generate Preview</button>
             <button id="generate-button" type="button" class="hidden px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Create Final PDF</button>
             <a id="download-link" class="hidden px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700">Download Split PDF</a>
        </div>
        <div id="status" class="text-center mb-4 min-h-[2rem]"></div>

        <div id="preview-section" class="hidden">
            <h3 class="text-lg font-semibold text-slate-700 mb-2 text-center">4. Adjust Split Lines</h3>
            <p class="text-sm text-slate-500 text-center mb-2">Red lines show where pages will be split. Blue zones show padding areas. Green lines show actual content boundaries.</p>
            <div class="flex items-center justify-center gap-4 text-xs mb-4">
                <span class="flex items-center gap-1"><div class="w-4 h-4 bg-red-500"></div> Cut Line</span>
                <span class="flex items-center gap-1"><div class="w-4 h-4 bg-blue-300"></div> Padding Zone</span>
                <span class="flex items-center gap-1"><div class="w-4 h-4 bg-green-500"></div> Content Boundary</span>
            </div>
            <div id="preview-container" class="relative w-full max-h-[80vh] overflow-y-auto border-2 border-slate-300 bg-slate-200">
                <canvas id="pdf-canvas" class="w-full h-auto"></canvas>
                <div id="cut-lines-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
                <div id="padding-zones-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
                <div id="content-boundaries-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
            </div>
        </div>
    </div>

<script>
    const { PDFDocument, rgb } = PDFLib;
    let uploadedFile = null;
    let originalPdfArrayBuffer = null;
    let originalPageSize = { width: 0, height: 0, scale: 1 };
    let cutPositions = [];
    let maxSliceHeightPixels = 0;
    let paddingPixels = 0;
    let activeDrag = { lineIndex: -1, startY: 0, originalCutPositions: [] };
    
    const fileInput = document.getElementById('file-upload');
    const fileNameDisplay = document.getElementById('file-name');
    const paperSizeSelect = document.getElementById('paper-size');
    const paddingSelect = document.getElementById('padding-select');
    const customPaddingInput = document.getElementById('custom-padding-input');
    const previewButton = document.getElementById('preview-button');
    const generateButton = document.getElementById('generate-button');
    const statusDiv = document.getElementById('status');
    const previewSection = document.getElementById('preview-section');
    const canvas = document.getElementById('pdf-canvas');
    const cutLinesContainer = document.getElementById('cut-lines-container');
    const paddingZonesContainer = document.getElementById('padding-zones-container');
    const contentBoundariesContainer = document.getElementById('content-boundaries-container');
    const downloadLink = document.getElementById('download-link');

    const paperDimensions = { A4: { width: 595.28, height: 841.89 }, A5: { width: 419.53, height: 595.28 }, Letter: { width: 612, height: 792 }, Legal: { width: 612, height: 1008 }, F4: { width: 595.28, height: 935.43 } };

    fileInput.addEventListener('change', handleFileSelect);
    previewButton.addEventListener('click', renderPreview);
    generateButton.addEventListener('click', createFinalPdf);
    paddingSelect.addEventListener('change', () => {
        customPaddingInput.classList.toggle('hidden', paddingSelect.value !== 'custom');
        if (cutPositions.length > 0) {
            calculateInitialCutLines();
            drawAllVisualElements();
        }
    });
    paperSizeSelect.addEventListener('change', () => {
        if (cutPositions.length > 0) {
            calculateInitialCutLines();
            drawAllVisualElements();
        }
    });

    function getPaddingValue() {
        return paddingSelect.value === 'custom' ? (parseFloat(customPaddingInput.value) || 0) : parseFloat(paddingSelect.value);
    }

    function handleFileSelect(e) {
        uploadedFile = e.target.files[0];
        if (uploadedFile) {
            fileNameDisplay.textContent = uploadedFile.name;
            previewButton.disabled = false;
            previewSection.classList.add('hidden');
            generateButton.classList.add('hidden');
            downloadLink.classList.add('hidden');
            statusDiv.innerHTML = '';
        }
    }

    async function renderPreview() {
        if (!uploadedFile) return;
        showStatus('loading', 'Loading and rendering PDF preview...');
        previewButton.disabled = true;
        
        try {
            originalPdfArrayBuffer = await uploadedFile.arrayBuffer();
            const pdfjsDoc = await pdfjsLib.getDocument({ data: originalPdfArrayBuffer.slice(0) }).promise;
            
            if (pdfjsDoc.numPages !== 1) {
                showStatus('error', 'Error: This tool only supports single-page PDFs.'); return;
            }

            const page = await pdfjsDoc.getPage(1);
            const desiredWidth = 1000;
            const viewport = page.getViewport({ scale: 1 });
            const scale = desiredWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });

            originalPageSize = { width: viewport.width, height: viewport.height, scale: scale };
            canvas.height = scaledViewport.height;
            canvas.width = scaledViewport.width;

            const renderContext = { canvasContext: canvas.getContext('2d', { willReadFrequently: true }), viewport: scaledViewport };
            await page.render(renderContext).promise;

            calculateInitialCutLines();
            drawAllVisualElements();
            
            previewSection.classList.remove('hidden');
            generateButton.classList.remove('hidden');
            downloadLink.classList.add('hidden');
            showStatus('success', `Preview generated. Found ${cutPositions.length + 1} potential pages.`);
        } catch (err) {
            showStatus('error', `Error rendering preview: ${err.message}`);
        } finally {
            previewButton.disabled = false;
        }
    }

    function calculateInitialCutLines() {
        const selectedPaper = paperSizeSelect.value;
        const targetDims = paperDimensions[selectedPaper];
        const targetRatio = targetDims.height / targetDims.width;
        
        const paddingPoints = getPaddingValue();
        paddingPixels = paddingPoints * originalPageSize.scale;
        
        // Calculate the actual content height available on each page
        const targetHeightPoints = originalPageSize.width * targetRatio;
        const targetContentHeightPoints = targetHeightPoints - (2 * paddingPoints);

        if (targetContentHeightPoints <= 0) {
            showStatus('error', 'Padding is too large for the selected paper size.');
            cutPositions = []; maxSliceHeightPixels = 0; return;
        }

        maxSliceHeightPixels = targetContentHeightPoints * originalPageSize.scale;
        cutPositions = [];
        
        // First page has no top padding, so it can fit more content
        const firstPageContentHeight = (targetHeightPoints - paddingPoints) * originalPageSize.scale;
        let currentY = firstPageContentHeight;
        
        // Add first cut
        if (currentY < canvas.height) {
            cutPositions.push(Math.round(currentY));
        }
        
        // Add subsequent cuts
        while (currentY < canvas.height) {
            currentY += maxSliceHeightPixels;
            if (currentY < canvas.height) {
                cutPositions.push(Math.round(currentY));
            }
        }
    }

    function drawAllVisualElements() {
        drawPaddingZones();
        drawContentBoundaries();
        drawCutLines();
    }

    function drawPaddingZones() {
        paddingZonesContainer.innerHTML = '';
        
        // For each page section, draw padding zones
        const allCuts = [0, ...cutPositions, canvas.height];
        
        for (let i = 0; i < allCuts.length - 1; i++) {
            const pageTop = allCuts[i];
            const pageBottom = allCuts[i + 1];
            
            // Top padding (except for first page)
            if (i > 0) {
                const topPadding = document.createElement('div');
                topPadding.className = 'padding-zone';
                topPadding.style.top = `${pageTop}px`;
                topPadding.style.height = `${paddingPixels}px`;
                paddingZonesContainer.appendChild(topPadding);
            }
            
            // Bottom padding
            const bottomPadding = document.createElement('div');
            bottomPadding.className = 'padding-zone';
            bottomPadding.style.top = `${pageBottom - paddingPixels}px`;
            bottomPadding.style.height = `${paddingPixels}px`;
            paddingZonesContainer.appendChild(bottomPadding);
        }
    }

    function drawContentBoundaries() {
        contentBoundariesContainer.innerHTML = '';
        
        const allCuts = [0, ...cutPositions, canvas.height];
        
        for (let i = 0; i < allCuts.length - 1; i++) {
            const pageTop = allCuts[i];
            const pageBottom = allCuts[i + 1];
            
            // Top content boundary (where content actually starts)
            if (i > 0) {
                const topBoundary = document.createElement('div');
                topBoundary.className = 'content-boundary';
                topBoundary.style.top = `${pageTop + paddingPixels}px`;
                contentBoundariesContainer.appendChild(topBoundary);
            }
            
            // Bottom content boundary (where content actually ends)
            const bottomBoundary = document.createElement('div');
            bottomBoundary.className = 'content-boundary';
            bottomBoundary.style.top = `${pageBottom - paddingPixels}px`;
            contentBoundariesContainer.appendChild(bottomBoundary);
        }
    }

    function drawCutLines() {
        cutLinesContainer.innerHTML = '';
        cutPositions.forEach((yPos, index) => {
            const line = document.createElement('div');
            line.className = 'cut-line';
            line.style.top = `${yPos}px`;
            line.dataset.index = index;
            line.style.pointerEvents = 'auto';
            const handle = document.createElement('div');
            handle.className = 'handle';
            handle.textContent = `Page ${index + 2}`;
            line.appendChild(handle);
            line.addEventListener('mousedown', startDrag);
            cutLinesContainer.appendChild(line);
        });
    }

    function startDrag(e) {
        e.preventDefault();
        const lineIndex = parseInt(e.target.dataset.index, 10);
        activeDrag = { lineIndex, startY: e.clientY, originalCutPositions: [...cutPositions] };
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
    }

    function drag(e) {
        if (activeDrag.lineIndex === -1) return;
        const deltaY = e.clientY - activeDrag.startY;
        const index = activeDrag.lineIndex;
        const originalY = activeDrag.originalCutPositions[index];
        let newY = originalY + deltaY;
        
        // Calculate constraints based on content areas
        const prevCutY = index > 0 ? cutPositions[index - 1] : 0;
        const minY = prevCutY + paddingPixels + 20; // Previous cut + padding + minimum content
        const maxY = prevCutY + paddingPixels + maxSliceHeightPixels;
        
        // Ensure the cut doesn't go into the padding zone of the current page
        if (index === 0) {
            // First cut: account for no top padding on first page
            const firstPageMaxContent = (paperDimensions[paperSizeSelect.value].height / paperDimensions[paperSizeSelect.value].width * originalPageSize.width - paddingPixels / originalPageSize.scale) * originalPageSize.scale;
            newY = Math.min(newY, firstPageMaxContent);
        }
        
        newY = Math.max(minY, Math.min(maxY, newY, canvas.height - paddingPixels));
        
        const snappedY = Math.round(newY);
        if (cutPositions[index] === snappedY) return;
        
        cutPositions[index] = snappedY;
        
        // Adjust subsequent cuts to maintain valid spacing
        for (let i = index + 1; i < cutPositions.length; i++) {
            const minNextY = cutPositions[i - 1] + paddingPixels + 20;
            if (cutPositions[i] < minNextY) {
                cutPositions[i] = minNextY;
            }
        }
        
        drawAllVisualElements();
    }

    function endDrag() {
        activeDrag.lineIndex = -1;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', endDrag);
    }
    
    // FIXED PDF GENERATION FUNCTION
    async function createFinalPdf() {
        if (!originalPdfArrayBuffer) return;
        showStatus('loading', 'Generating final PDF...');
        generateButton.disabled = true;

        try {
            const outputPdfDoc = await PDFDocument.create();
            const [embeddedPage] = await outputPdfDoc.embedPdf(originalPdfArrayBuffer.slice(0));
            
            const selectedPaper = paperSizeSelect.value;
            const targetSize = paperDimensions[selectedPaper];
            const paddingPoints = getPaddingValue();
            
            // Convert pixel positions to PDF points
            const cutPointsY = [0, ...cutPositions.map(p => p / originalPageSize.scale), originalPageSize.height];
            
            // Calculate the scale factor to fit width
            const scaleFactor = targetSize.width / originalPageSize.width;

            for (let i = 0; i < cutPointsY.length - 1; i++) {
                const sliceStartY = cutPointsY[i];
                const sliceEndY = cutPointsY[i + 1];
                
                // Create new page
                const newPage = outputPdfDoc.addPage([targetSize.width, targetSize.height]);
                
                // Calculate where to position the embedded page
                let contentTopY;
                if (i === 0) {
                    // First page: content starts at top
                    contentTopY = targetSize.height;
                } else {
                    // Other pages: content starts after top padding
                    contentTopY = targetSize.height - paddingPoints;
                }
                
                // Position the embedded page so the correct slice is visible
                const embeddedPageY = contentTopY - (originalPageSize.height - sliceStartY) * scaleFactor;
                
                // Draw the page
                newPage.drawPage(embeddedPage, {
                    x: 0,
                    y: embeddedPageY,
                    width: targetSize.width,
                    height: originalPageSize.height * scaleFactor,
                });
                
                // Create white rectangles to mask unwanted content
                const white = rgb(1, 1, 1);
                
                // Mask content above the slice
                if (contentTopY < targetSize.height) {
                    newPage.drawRectangle({
                        x: 0,
                        y: contentTopY,
                        width: targetSize.width,
                        height: targetSize.height - contentTopY,
                        color: white,
                    });
                }
                
                // Calculate where the slice ends on the page
                const sliceHeight = (sliceEndY - sliceStartY) * scaleFactor;
                const contentBottomY = contentTopY - sliceHeight;
                
                // Mask content below the slice, preserving bottom padding
                if (contentBottomY > paddingPoints) {
                    newPage.drawRectangle({
                        x: 0,
                        y: paddingPoints,
                        width: targetSize.width,
                        height: contentBottomY - paddingPoints,
                        color: white,
                    });
                }
                
                // Always ensure bottom padding is clean
                newPage.drawRectangle({
                    x: 0,
                    y: 0,
                    width: targetSize.width,
                    height: paddingPoints,
                    color: white,
                });
            }

            const pdfBytes = await outputPdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            
            const originalFileName = uploadedFile.name.replace(/\.pdf$/i, '');
            downloadLink.href = url;
            downloadLink.download = `${originalFileName}-split-final.pdf`;
            downloadLink.classList.remove('hidden');
            
            showStatus('success', `PDF successfully created! ${cutPointsY.length - 1} pages generated.`);

        } catch (err) {
            showStatus('error', `Failed to create PDF: ${err.message}`);
            console.error(err);
        } finally {
            generateButton.disabled = false;
        }
    }

    function showStatus(type, message) {
        let color = type === 'error' ? 'text-red-600' : (type === 'success' ? 'text-green-600' : 'text-slate-600');
        const icon = type === 'loading' ? '<div class="spinner mx-auto"></div>' : '';
        statusDiv.innerHTML = `<div class="flex items-center justify-center space-x-2 ${color}">${icon}<p>${message}</p></div>`;
    }
</script>
</body>
</html>