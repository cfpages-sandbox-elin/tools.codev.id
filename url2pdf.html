<!DOCTYPE html>
<html>
<head>
<title>URL to PDF & Issuu Uploader v4.8 üöÄ</title>
<style>
  /* Basic CSS Styling here */
  body { font-family: sans-serif; }
  textarea { width: 100%; height: 150px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; padding: 8px; }
  button, .ctrl-button, .api-key-button { padding: 10px 20px; cursor: pointer; border-radius: 5px; background-color: #f0f0f0; border: 1px solid #ccc; margin-right: 5px; }
  button:hover, .ctrl-button:hover, .api-key-button:hover { background-color: #e0e0e0; }
  button:disabled, .ctrl-button:disabled, .api-key-button:disabled { background-color: #ddd; cursor: default; }
  #status, #cleanupStatus { margin-top: 10px; white-space: pre-wrap; height: 150px; overflow-y: scroll; border: 1px solid #ccc; padding: 8px; box-sizing: border-box; font-family: monospace; border-radius: 5px; background-color: #f9f9f9; }
  #sitemapUrl, #printfriendlyApiKey, #issuuBearerToken, #issuuClientId, #issuuClientSecret, #urlFilter, .additional-api-key { width: 100%; margin-bottom: 8px; padding: 8px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; }
  .api-key-input, .sitemap-parser, .url-area, .results-area, .progress-area, .cors-info, .cleanup-area { margin-bottom: 15px; padding: 10px; border-radius: 8px; background-color: #fff; border: 1px solid #ddd; }
  .sitemap-parser { display: flex; }
  .sitemap-parser input { flex-grow: 1; margin-right: 10px; }
  .url-area { display: flex; }
  .url-area textarea { flex-grow: 2; margin-right: 10px; }
  .url-filter-area { flex-grow: 1; }
  .results-area { margin-top: 10px; display: flex; }
  .results-area textarea { flex: 1; height: 150px; margin-right: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; padding: 8px; }
  .progress-area { margin-bottom: 10px; }
  .progress-bar { width: 100%; height: 20px; background-color: #eee; border-radius: 5px; overflow: hidden; }
  .progress-bar-fill { height: 100%; width: 0%; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s ease-in-out; }
  .cors-info { background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc; margin-bottom: 15px; border-radius: 5px; }
  .issuu-creds { display: flex; align-items: center; }
  .issuu-creds label { margin-right: 10px; white-space: nowrap; }
  .issuu-creds input { margin-right: 10px; flex: 1; }
  .api-keys-container { display: flex; flex-direction: column; }
  .additional-keys-container { display: flex; flex-wrap: wrap; align-items: center; margin-top: 5px; }
  .additional-keys-container label { margin-right: 10px; white-space: nowrap; margin-bottom: 5px; }
  .additional-keys-container input { flex: 1 1 200px; margin-right: 10px; margin-bottom: 5px; }
  h1 { color: #333; }
  label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; }
  p { color: #777; margin-bottom: 8px; }
  .url-filter-area p { margin-top: 5px; font-style: italic; color: #999; }
  .results-area button { margin-top: 10px; }
  .controls { display: flex; align-items: center; margin-bottom: 10px; }
  /* Tabs Styling */
  .tab { overflow: hidden; border-bottom: 1px solid #ccc; margin-bottom: 15px; }
  .tab button { background-color: inherit; border: none; outline: none; cursor: pointer; padding: 10px 16px; transition: 0.3s; float: left; border-top-left-radius: 5px; border-top-right-radius: 5px; }
  .tab button:hover { background-color: #ddd; }
  .tab button.active { background-color: #ccc; }
  .tabcontent { display: none; padding: 6px 12px; border: 1px solid #ccc; border-top: none; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }
  .tabcontent.active { display: block; }
  .api-key-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
  .api-key-header button { margin-left: 10px; padding: 5px 10px; font-size: 0.9em; }
</style>
</head>
<body>

  <h1>URL to PDF & Issuu Uploader v4.9 üöÄ</h1>

  <div class="api-keys-container">
    <div class="api-key-input">
      <div class="api-key-header">
        <label for="printfriendlyApiKey">PrintFriendly API Key(s) üîë:</label>
        <button type="button" id="addApiKeyButton" class="api-key-button">+</button>
      </div>
      <input type="text" id="printfriendlyApiKey" placeholder="Enter PrintFriendly API Key">
      <div class="additional-keys-container" id="additionalPrintFriendlyKeys">
        <!-- Additional API key inputs will be added here -->
      </div>
    </div>

    <div class="api-key-input">
      <label>Issuu Credentials üìö:</label>
      <div class="issuu-creds">
        <label for="issuuBearerToken">Bearer Token:</label>
        <input type="text" id="issuuBearerToken" placeholder="Enter Issuu Bearer Token (OAuth)">
        <label for="issuuClientId">Client ID:</label>
        <input type="text" id="issuuClientId" placeholder="Enter Issuu Client ID">
        <label for="issuuClientSecret">Client Secret:</label>
        <input type="text" id="issuuClientSecret" placeholder="Enter Issuu Client Secret">
      </div>
    </div>
  </div>

  <div class="tab">
    <button class="tablinks active" onclick="openTab(event, 'uploadTab')">URL 2 PDF 2 Upload</button>
    <button class="tablinks" onclick="openTab(event, 'cleanupTab')">Clean Out Issuu</button>
  </div>

  <div id="uploadTab" class="tabcontent active">
    <div class="sitemap-parser">
      <input type="url" id="sitemapUrl" placeholder="Enter Sitemap URL üåê">
      <button id="parseSitemapButton">Parse Sitemap URLs üó∫Ô∏è</button>
    </div>

    <div class="url-area">
      <textarea id="urlList" placeholder="Enter URLs here, one per line"></textarea>
      <div class="url-filter-area">
        <textarea id="urlFilter" title="Enter keywords to filter out URLs containing these keywords. One keyword per line. URLs containing any of these keywords will be excluded." placeholder="Filter URLs (keywords, one per line) üîçÔ∏è
(e.g., contact, privacy policy, tos)">contact
privacy policy
terms of service
tos
about us
about me
contoh
wp</textarea>
        <p>URLs: <span id="urlCount">0</span> / <span id="filteredUrlCount">0</span> (Filtered/Total)</p>
      </div>
    </div>

    <div class="controls">
      <button id="convertButton">Convert to PDFs & Upload üöÄ</button>
      <button id="pauseButton" class="ctrl-button" disabled>Pause ‚è∏Ô∏è</button>
      <button id="resumeButton" class="ctrl-button" disabled>Resume ‚ñ∂Ô∏è</button>
    </div>

    <div class="progress-area">
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progressBarFill"></div>
      </div>
      <p id="progressInfo">Progress: 0/0 URLs | PDF: 0/0 | Uploaded: 0/0 | Published: 0/0 | Est. Time: --</p>
    </div>
    <p id="statusSummary">Status Summary: Pending...</p>
    <textarea id="status" readonly placeholder="Status messages will appear here"></textarea>

    <div class="results-area">
      <div>
        <textarea id="successUrls" readonly placeholder="‚úÖ Successful Issuu URLs"></textarea>
        <div style="display: flex; align-items: center;">
          <button id="copySuccessButton">Copy Success URLs üìã</button>
          <button id="indexIssuuButton">Index Issuu (N/A)</button>
        </div>
      </div>
      <div>
        <textarea id="failedUrls" readonly placeholder="‚ùå Failed URLs"></textarea>
        <button id="retryFailedButton">Retry Failed URLs üîÑ</button>
      </div>
      <div>
        <textarea id="skippedUrls" readonly placeholder="‚è≠Ô∏è Skipped URLs (already on Issuu)"></textarea>
      </div>
    </div>
  </div>

  <div id="cleanupTab" class="tabcontent">
    <div class="cleanup-area">
      <button id="cleanIssuuButton">Clean Out Issuu üßπ</button>
      <textarea id="cleanupStatus" readonly placeholder="Cleanup status messages will appear here"></textarea>
    </div>
  </div>


  <script type="module">
    let draftSlugs = {};
    let isPaused = false;
    let processingActive = false;
    let waitingForApiKey = false;

    document.addEventListener('DOMContentLoaded', async () => {
      // Load API keys from local storage on page load
      loadApiKeys();
      initializeUrlHandling();
      updateUrlCountDisplay();
      applyUrlFilter();
      updateAdditionalApiKeyFields();

      // Event listeners for API key input changes to save to local storage
      document.getElementById('printfriendlyApiKey').addEventListener('input', savePrintFriendlyApiKey);
      document.querySelectorAll('.additional-api-key').forEach(input => {
          input.addEventListener('input', savePrintFriendlyApiKey);
      });
      document.getElementById('issuuBearerToken').addEventListener('input', saveIssuuBearerToken);
      document.getElementById('issuuClientId').addEventListener('input', saveIssuuClientId);
      document.getElementById('issuuClientSecret').addEventListener('input', saveIssuuClientSecret);
      document.getElementById('urlList').addEventListener('input', updateUrlCountDisplay);
      document.getElementById('urlList').addEventListener('input', updateAdditionalApiKeyFields);
      document.getElementById('urlFilter').addEventListener('input', applyUrlFilter);
      document.getElementById('copySuccessButton').addEventListener('click', copySuccessUrls);
      document.getElementById('retryFailedButton').addEventListener('click', retryFailedUrls);
      document.getElementById('addApiKeyButton').addEventListener('click', addNewApiKeyField);
      document.getElementById('indexIssuuButton').addEventListener('click', indexSuccessUrls);


      // Tab functionality
      document.querySelectorAll('.tablinks').forEach(tab => {
        tab.addEventListener('click', (event) => {
          openTab(event, event.target.textContent === "URL 2 PDF 2 Upload" ? 'uploadTab' : 'cleanupTab');
        });
      });

      document.getElementById('cleanIssuuButton').addEventListener('click', cleanOutIssuu);

      // Fetch and display SpeedyIndex balance on load
      await displaySpeedyIndexBalance();

    });

    function openTab(evt, tabName) {
      let i, tabcontent, tablinks;
      tabcontent = document.querySelectorAll(".tabcontent");
      for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].classList.remove("active");
      }
      tablinks = document.querySelectorAll(".tablinks");
      for (i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove("active");
      }
      document.getElementById(tabName).classList.add("active");
      evt.currentTarget.classList.add("active");
    }


    function loadApiKeys() {
      const printfriendlyKey = localStorage.getItem('printfriendlyApiKey');
      const issuuBearerToken = localStorage.getItem('issuuBearerToken');
      const issuuClientId = localStorage.getItem('issuuClientId');
      const issuuClientSecret = localStorage.getItem('issuuClientSecret');
      const additionalKeys = JSON.parse(localStorage.getItem('additionalPrintFriendlyKeys') || '[]');

      if (printfriendlyKey) {
        document.getElementById('printfriendlyApiKey').value = printfriendlyKey;
      }
      if (issuuBearerToken) {
        document.getElementById('issuuBearerToken').value = issuuBearerToken;
      }
      if (issuuClientId) {
        document.getElementById('issuuClientId').value = issuuClientId;
      }
      if (issuuClientSecret) {
        document.getElementById('issuuClientSecret').value = issuuClientSecret;
      }

      const additionalKeysContainer = document.getElementById('additionalPrintFriendlyKeys');
      additionalKeys.forEach((key, index) => {
          addNewApiKeyField(key, additionalKeysContainer, index + 1);
      });
    }

    function savePrintFriendlyApiKey(event) {
      if (event.target.id === 'printfriendlyApiKey') {
          localStorage.setItem('printfriendlyApiKey', event.target.value);
      } else if (event.target.classList.contains('additional-api-key')) {
          saveAdditionalApiKeys();
      }
      updateAdditionalApiKeyFields();
    }

    function saveAdditionalApiKeys() {
        const additionalKeys = [];
        document.querySelectorAll('.additional-api-key').forEach(input => {
            additionalKeys.push(input.value);
        });
        localStorage.setItem('additionalPrintFriendlyKeys', JSON.stringify(additionalKeys));
    }


    function saveIssuuBearerToken(event) {
      localStorage.setItem('issuuBearerToken', event.target.value);
    }

    function saveIssuuClientId(event) {
      localStorage.setItem('issuuClientId', event.target.value);
    }

    function saveIssuuClientSecret(event) {
      localStorage.setItem('issuuClientSecret', event.target.value);
    }

    function updateStatus(message) {
      const statusTextarea = document.getElementById('status');
      statusTextarea.value += message + '\n';
      statusTextarea.scrollTop = statusTextarea.scrollHeight; // Auto-scroll to bottom
    }

    function updateCleanupStatus(message) {
      const statusTextarea = document.getElementById('cleanupStatus');
      statusTextarea.value += message + '\n';
      statusTextarea.scrollTop = statusTextarea.scrollHeight; // Auto-scroll to bottom
    }

    function updateStatusSummary(summary) {
      document.getElementById('statusSummary').textContent = 'Status Summary: ' + summary;
    }

    function updateProgressBar(percentage) {
      document.getElementById('progressBarFill').style.width = `${percentage}%`;
    }

    function updateProgressInfo(processed, total, pdfGenerated, uploaded, published, estimatedTime) {
      document.getElementById('progressInfo').textContent = `Progress: ${processed}/${total} URLs | PDF: ${pdfGenerated}/${total} | Uploaded: ${uploaded}/${total} | Published: ${published}/${total} | Est. Time: ${estimatedTime}`;
    }

    let originalUrls = [];
    let filteredUrls = [];

    function initializeUrlHandling() {
        originalUrls = document.getElementById('urlList').value.trim().split('\n').filter(url => url);
        filteredUrls = [...originalUrls]; // Initially filtered URLs are the same as original
        updateUrlListTextarea();
    }

    function updateUrlCountDisplay() {
        originalUrls = document.getElementById('urlList').value.trim().split('\n').filter(url => url); // Update originalUrls from textarea
        applyUrlFilter(); // Re-apply filter to update filteredUrls and display
    }

    function applyUrlFilter() {
        const filterKeywords = document.getElementById('urlFilter').value.trim().split('\n').filter(keyword => keyword.trim() !== '');
        if (filterKeywords.length > 0) {
            filteredUrls = originalUrls.filter(url => {
                const lowerUrl = url.toLowerCase();
                return !filterKeywords.some(keyword => lowerUrl.includes(keyword.toLowerCase().trim()));
            });
        } else {
            filteredUrls = [...originalUrls]; // If no filter, filtered URLs are same as original
        }
        updateUrlListTextarea();
    }

    function updateUrlListTextarea() {
        document.getElementById('urlList').value = filteredUrls.join('\n');
        document.getElementById('urlCount').textContent = originalUrls.length;
        document.getElementById('filteredUrlCount').textContent = filteredUrls.length;
        updateAdditionalApiKeyFields(); // Update API key fields when URL list changes
    }


    document.getElementById('convertButton').addEventListener('click', async () => {
      if (processingActive) {
        updateStatus("Processing is already active. Please wait or pause/resume.");
        return;
      }
      processingActive = true;
      isPaused = false;
      waitingForApiKey = false; // Reset the waiting for API key flag
      document.getElementById('pauseButton').disabled = false;
      document.getElementById('resumeButton').disabled = true;
      document.getElementById('convertButton').disabled = true; // Disable Convert button during processing


      filteredUrls = document.getElementById('urlList').value.trim().split('\n').filter(url => url); // Use filtered URLs for processing
      const statusTextarea = document.getElementById('status');
      statusTextarea.value = ""; // Clear previous status
      const successUrlsTextarea = document.getElementById('successUrls');
      successUrlsTextarea.value = "";
      const failedUrlsTextarea = document.getElementById('failedUrls');
      failedUrlsTextarea.value = "";
      const skippedUrlsTextarea = document.getElementById('skippedUrls');
      skippedUrlsTextarea.value = "";

      if (filteredUrls.length === 0) {
        updateStatus("Please enter URLs or parse from a sitemap.");
        updateStatusSummary("URLs missing.");
        resetButtonsAfterProcess();
        return;
      }

      let printfriendlyApiKeys = getPrintFriendlyApiKeys(); // Get initial API keys
      const issuuBearerToken = document.getElementById('issuuBearerToken').value.trim();
      const issuuClientId = document.getElementById('issuuClientId').value.trim();
      const issuuClientSecret = document.getElementById('issuuClientSecret').value.trim();

      if (!printfriendlyApiKeys[0]) {
        updateStatus("Please enter at least one PrintFriendly API Key.");
        updateStatusSummary("PrintFriendly API Key missing.");
        resetButtonsAfterProcess();
        return;
      }

      if (filteredUrls.length > printfriendlyApiKeys.length * 200) {
        updateStatus(`Please provide ${Math.ceil(filteredUrls.length / 200)} PrintFriendly API Keys to process ${filteredUrls.length} URLs.`);
        updateStatusSummary("Insufficient PrintFriendly API Keys.");
        resetButtonsAfterProcess();
        return;
      }
      if (printfriendlyApiKeys.some(key => !key.trim())) {
          updateStatus("Please fill in all PrintFriendly API Key fields.");
          updateStatusSummary("Missing PrintFriendly API Keys.");
          resetButtonsAfterProcess();
          return;
      }


      if (!issuuBearerToken) {
        updateStatus("Please enter your Issuu Bearer Token.");
        updateStatusSummary("Issuu Bearer Token missing.");
        resetButtonsAfterProcess();
        return;
      }

      if (!issuuClientId) {
        updateStatus("Please enter your Issuu Client ID.");
        updateStatusSummary("Issuu Client ID missing.");
        resetButtonsAfterProcess();
        return;
      }

      if (!issuuClientSecret) {
        updateStatus("Please enter your Issuu Client Secret.");
        updateStatusSummary("Issuu Client Secret missing.");
        resetButtonsAfterProcess();
        return;
      }

      updateStatus("Checking for existing URLs on Issuu...");
      const existingIssuuUrls = await checkExistingUrlsInIssuu(filteredUrls, issuuBearerToken);
      const urlsToProcess = filteredUrls.filter(url => !existingIssuuUrls.has(url));
      const skippedUrls = filteredUrls.filter(url => existingIssuuUrls.has(url));

      if (skippedUrls.length > 0) {
          skippedUrlsTextarea.value = skippedUrls.join('\n');
          updateStatus(`‚è≠Ô∏è Skipped ${skippedUrls.length} URLs already found on Issuu.`);
      }

      if (urlsToProcess.length === 0) {
          updateStatus("No new URLs to process. All URLs are already on Issuu or were filtered.");
          updateStatusSummary("No new URLs to process.");
          resetButtonsAfterProcess();
          return;
      }
      filteredUrls = urlsToProcess; // Process only the new URLs


      const totalUrls = filteredUrls.length;
      let processedUrlsCount = 0;
      let pdfGeneratedCount = 0;
      let uploadedCount = 0;
      let publishedCount = 0;
      let startTime = new Date().getTime();
      const estimatedTimePerUrl = 15000; // Initial estimate in milliseconds (adjust as needed)
      let failedUrlList = [];
      let successIssuuUrls = [];
      // let apiKeyIndex = 0;

      updateStatusSummary(`Processing ${totalUrls} URLs...`);


      for (let i = 0; i < filteredUrls.length; i++) {
        if (isPaused || waitingForApiKey) { // Check waitingForApiKey flag as well
          updateStatus(isPaused ? "‚è∏Ô∏è Processing paused. Click 'Resume' to continue." : "‚è≥ Waiting for PrintFriendly API Key. Please add a new key and click 'Resume'.");
          updateStatusSummary(isPaused ? "Paused" : "Waiting for API Key");
          document.getElementById('pauseButton').disabled = true;
          document.getElementById('resumeButton').disabled = false;
          return; // Exit the loop to pause
        }

        let url = filteredUrls[i];
        let retryCount = 0;
        const maxRetries = 3;
        let currentStage = "pdf"; // pdf, upload, publish
        let pdfBlob; // Define pdfBlob here so it's accessible in the loop
        let currentDraftSlug; // To store draft slug for the current URL

        while (retryCount <= maxRetries) {
          try {
            updateStatus(`Processing URL ${processedUrlsCount + 1}/${totalUrls}: ${url} (Attempt ${retryCount + 1})...`);
            updateProgressInfo(processedUrlsCount, totalUrls, pdfGeneratedCount, uploadedCount, publishedCount, calculateEstimatedTime(startTime, processedUrlsCount, totalUrls, estimatedTimePerUrl));

            if (currentStage === "pdf") {
              updateStatus(`  > Converting to PDF using PrintFriendly...`);
              const currentApiKeyIndex = Math.floor(processedUrlsCount / 200); // Determine API key index based on processed count
              pdfBlob = await convertUrlToPdfWithRateLimit(url, printfriendlyApiKeys[currentApiKeyIndex]); // Rate limited PDF conversion

              if (pdfBlob) {
                updateStatus(`  > ‚úÖ PDF generated successfully.`);
                pdfGeneratedCount++;
                currentStage = "upload";
              } else {
                updateStatus(`  > ‚ùå Failed to convert to PDF.`); // Removed HTML formatting
                currentStage = "pdf"; // Retry PDF conversion
                throw new Error("PDF Conversion Failed"); // For retry logic
              }
            }

            if (currentStage === "upload") {
              // Check if we already have a draftSlug for this URL
              if (draftSlugs[url]) {
                updateStatus(`  > ‚ôªÔ∏è Reusing existing Draft Slug for URL: ${url}`);
                currentDraftSlug = draftSlugs[url]; // Use existing slug
                currentStage = "publish"; // Skip upload, go to publish
              } else {
                updateStatus(`  > üì§ Uploading PDF to Issuu...`);
                currentDraftSlug = await uploadPdfToIssuu(pdfBlob, url, issuuBearerToken, issuuClientId, issuuClientSecret); // Upload and get slug

                if (currentDraftSlug) {
                  updateStatus(`  > ‚úÖ PDF uploaded successfully, Draft Slug: ${currentDraftSlug}`);
                  uploadedCount++;
                  draftSlugs[url] = currentDraftSlug; // Store the draft slug for future reuse
                  currentStage = "publish";
                } else {
                  updateStatus(`  > ‚ùå Failed to upload PDF to Issuu.`); // Removed HTML formatting
                  currentStage = "upload"; // Retry Upload
                  throw new Error("PDF Upload Failed"); // For retry logic
                }
              }
            }

            if (currentStage === "publish") {
              updateStatus(`  > üöÄ Publishing Draft on Issuu and retrieving URL...`);
              const issuuPublicationUrl = await publishDraft(currentDraftSlug, issuuBearerToken); // Call publishDraft

              if (issuuPublicationUrl) {
                updateStatus(`  > ‚úÖ Published on Issuu. Publication URL: ${issuuPublicationUrl}`);
                publishedCount++;
                successUrlsTextarea.value += issuuPublicationUrl + '\n';
                successIssuuUrls.push({url: url, issuuUrl: issuuPublicationUrl});
                break; // Success, move to next URL
              } else {
                updateStatus(`  > ‚ùå Failed to publish or retrieve Issuu URL.`); // Removed HTML formatting
                currentStage = "publish"; // Retry Publish
                throw new Error("Issuu Publication Failed or URL retrieval failed"); // For retry logic
              }
            }


          } catch (error) {
            console.error(`Error processing URL: ${url} (Attempt ${retryCount + 1})`, error);
            updateStatus(`  > ‚ö†Ô∏è Error: ${error.message || error}`); // Removed HTML formatting
            if (error.message.includes("API Key Exhausted") || error.message.includes("Unauthorized")) { // Check for API key exhaustion error
              updateStatus(`<span style="color: red;">  > ‚õî PrintFriendly API Key Exhausted or Invalid. Please add a new API key below and click 'Resume'.</span>`);
              addNewApiKeyField(); // Add a new API key input field
              waitingForApiKey = true; // Set the flag to pause processing loop
              document.getElementById('pauseButton').disabled = true; // Disable pause button while waiting for API key
              document.getElementById('resumeButton').disabled = false; // Enable resume button
              updateStatusSummary("Waiting for API Key");
              return; // Exit the function to pause processing loop
            }


            retryCount++;
            if (retryCount <= maxRetries) {
              const waitTime = Math.random() * 3000 + 1000; // Random wait 1-4 seconds
              updateStatus(`  > ‚è≥ Retrying in ${waitTime/1000} seconds...`);
              await new Promise(resolve => setTimeout(resolve, waitTime));
            } else {
              updateStatus(`  > ‚õî Max retries reached for ${url}. Processing failed.`); // Removed HTML formatting
              failedUrlsTextarea.value += url + '\n';
              failedUrlList.push(url);
              break; // Max retries, move to next URL
            }
          }
        } // end while retry loop

        processedUrlsCount++;
        if (processedUrlsCount % 200 === 0 && processedUrlsCount < filteredUrls.length) { // Check if there are more URLs to process after rotation
            updateStatus(`üîë Rotated to next PrintFriendly API Key after processing 200 URLs.`); // Inform user of key rotation
        }
        updateProgressBar((processedUrlsCount / totalUrls) * 100);
        updateProgressInfo(processedUrlsCount, totalUrls, pdfGeneratedCount, uploadedCount, publishedCount, calculateEstimatedTime(startTime, processedUrlsCount, totalUrls, estimatedTimePerUrl));

      } // end for url loop


      const endTime = new Date().getTime();
      const totalTimeSeconds = (endTime - startTime) / 1000;
      updateStatusSummary(`‚úÖ Processing completed in ${totalTimeSeconds.toFixed(1)} seconds.  ${totalUrls} URLs, PDF Generated: ${pdfGeneratedCount}, Uploaded: ${uploadedCount}, Published: ${publishedCount}. Failed: ${failedUrlList.length}. Skipped: ${skippedUrls.length}`);
      updateProgressInfo(totalUrls, totalUrls, pdfGeneratedCount, uploadedCount, publishedCount, "Done");
      resetButtonsAfterProcess();

    });

    document.getElementById('resumeButton').addEventListener('click', () => {
      isPaused = false;
      waitingForApiKey = false; // Reset waiting for API key flag on resume
      document.getElementById('pauseButton').disabled = false;
      document.getElementById('resumeButton').disabled = true;
      document.getElementById('convertButton').disabled = true; // Keep convert button disabled while processing
      document.getElementById('convertButton').click(); // Re-trigger the convert process to continue
    });

    function resetButtonsAfterProcess() {
        document.getElementById('convertButton').disabled = false; // Enable Convert button after processing is done or stopped
        document.getElementById('pauseButton').disabled = true;
        document.getElementById('resumeButton').disabled = true;
        processingActive = false;
    }

    document.getElementById('pauseButton').addEventListener('click', () => {
      isPaused = true;
      document.getElementById('pauseButton').disabled = true;
      document.getElementById('resumeButton').disabled = false;
      document.getElementById('convertButton').disabled = true; // Keep convert button disabled while paused
    });

    document.getElementById('resumeButton').addEventListener('click', () => {
      isPaused = false;
      document.getElementById('pauseButton').disabled = false;
      document.getElementById('resumeButton').disabled = true;
      document.getElementById('convertButton').disabled = true; // Keep convert button disabled while processing
      document.getElementById('convertButton').click(); // Re-trigger the convert process to continue
    });


    document.getElementById('parseSitemapButton').addEventListener('click', async () => {
      const sitemapUrl = document.getElementById('sitemapUrl').value.trim();
      const statusTextarea = document.getElementById('status');
      if (!sitemapUrl) {
        updateStatus("Please enter a Sitemap URL.");
        return;
      }
      updateStatus("üó∫Ô∏è Parsing sitemap...");
      try {
        const urlsFromSitemap = await parseSitemapUrls(sitemapUrl);
        if (urlsFromSitemap && urlsFromSitemap.length > 0) {
          originalUrls = urlsFromSitemap; // Update original URLs with sitemap URLs
          applyUrlFilter(); // Re-apply filter to update filteredUrls and display
          updateUrlCountDisplay();
          updateStatus(`‚úÖ Found ${urlsFromSitemap.length} URLs from sitemap and populated the URL list.`);
        } else {
          updateStatus("‚ö†Ô∏è No URLs found in the sitemap or error parsing sitemap.");
        }
      } catch (error) {
        updateStatus(`‚ùå Error parsing sitemap: ${error.message || error}`);
        console.error("Error parsing sitemap:", error);
      }
    });

    function addNewApiKeyField(initialValue = '', container = document.getElementById('additionalPrintFriendlyKeys'), keyIndex = document.querySelectorAll('.additional-api-key').length + 1) {
        const keyInput = document.createElement('div');
        keyInput.classList.add('additional-keys-container');
        keyInput.innerHTML = `
            <label for="printfriendlyApiKey${keyIndex}">Additional API Key ${keyIndex} üîë:</label>
            <input type="text" id="printfriendlyApiKey${keyIndex}" class="additional-api-key" placeholder="Enter Additional API Key" value="${initialValue}">
        `;
        container.appendChild(keyInput);
        const newInput = keyInput.querySelector('input');
        newInput.addEventListener('input', savePrintFriendlyApiKey); // Attach event listener to new input
        return newInput; // Return the newly created input element
    }


    function getPrintFriendlyApiKeys() {
        const keys = [document.getElementById('printfriendlyApiKey').value];
        const additionalKeyInputs = document.querySelectorAll('.additional-api-key');
        additionalKeyInputs.forEach(input => {
            keys.push(input.value);
        });
        return keys.filter(key => key.trim() !== ''); // Filter out empty keys
    }

    function updateAdditionalApiKeyFields() {
        const urlCount = document.getElementById('urlList').value.trim().split('\n').filter(url => url).length;
        const requiredKeys = Math.ceil(urlCount / 200);
        const existingKeyCount = document.querySelectorAll('.additional-api-key').length + 1; // +1 for the default key
        const additionalKeysContainer = document.getElementById('additionalPrintFriendlyKeys');

        // Add required fields
        if (requiredKeys > existingKeyCount) {
            for (let i = existingKeyCount; i < requiredKeys; i++) {
                addNewApiKeyField('', additionalKeysContainer, i + 1);
            }
        }
        // Remove extra fields if URL count decreases (but keep at least one additional field if there were any added manually)
        while (document.querySelectorAll('.additional-api-key').length > Math.max(requiredKeys - 1, 0) && document.querySelectorAll('.additional-api-key').length > (localStorage.getItem('additionalPrintFriendlyKeys') ? JSON.parse(localStorage.getItem('additionalPrintFriendlyKeys')).length : 0 )) {
            additionalKeysContainer.removeChild(additionalKeysContainer.lastChild);
        }
    }


    const printfriendlyRequestQueue = [];
    let printfriendlyRequestsThisMinute = 0;
    let lastMinuteStart = Date.now();

    async function convertUrlToPdfWithRateLimit(url, apiKey) {
      return new Promise((resolve, reject) => {
        printfriendlyRequestQueue.push({ url, apiKey, resolve, reject });
        processPrintFriendlyQueue();
      });
    }

    async function processPrintFriendlyQueue() {
      if (printfriendlyRequestQueue.length === 0) return;

      const now = Date.now();
      if (now - lastMinuteStart >= 60000) {
        printfriendlyRequestsThisMinute = 0;
        lastMinuteStart = now;
      }

      if (printfriendlyRequestsThisMinute < 60) {
        printfriendlyRequestsThisMinute++;
        const requestItem = printfriendlyRequestQueue.shift();
        try {
          const pdfBlob = await convertUrlToPdf(requestItem.url, requestItem.apiKey);
          requestItem.resolve(pdfBlob);
        } catch (error) {
          requestItem.reject(error);
        } finally {
          processPrintFriendlyQueue(); // Process next item in queue
        }
      } else {
        // Rate limit hit, wait and retry
        setTimeout(processPrintFriendlyQueue, 1000); // Wait 1 second and try again
      }
    }


    async function convertUrlToPdf(url, apiKey) { // apiKey parameter is now USED!
      try {
        // ** Updated fetch call to pass API key as query parameter **
        const proxyUrl = `/printfriendly-api?page_url=${encodeURIComponent(url)}&apikey=${encodeURIComponent(apiKey)}`; // Append apikey query parameter
        const response = await fetch(proxyUrl); // Call PDF proxy Function with API key
        if (!response.ok) {
          const errorData = await response.json(); // Assuming error response is JSON
          throw new Error(`PDF Conversion Proxy error: ${response.status} ${response.statusText} - ${errorData?.error || 'Unknown error'}`);
        }

        // ** Get PDF Blob from the response (proxy function returns Blob)**
        const pdfBlob = await response.blob();
        return pdfBlob; // Return the Blob
      } catch (error) {
        console.error("Error converting to PDF using PDF Proxy Function:", error);
        return null;
      }
    }


    async function uploadPdfToIssuu(pdfBlob, url, bearerToken, clientId, clientSecret) { // Issuu OAuth parameters
      const issuuApiBearerToken = bearerToken;
      const issuuApiDraftsUrl = "https://api.issuu.com/v2/drafts";

      try {
        // 1. Create a Draft
        const createDraftResponse = await fetch(issuuApiDraftsUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${issuuApiBearerToken}`
          },
          body: JSON.stringify({
            "confirmCopyright": true, // Assuming you confirm copyright
            "info": {
              "access": "PUBLIC", // Or "PRIVATE", etc.
              "title": await getPageTitle(url) || `Document from ${url}`, // Get title from page or default
              "description": url, // Description is now set to the URL for checking duplicates
              "type": "editorial", // Or other type as needed
              "downloadable": true // Allow downloads
            }
          })
        });

        if (!createDraftResponse.ok) {
          const errorData = await createDraftResponse.json();
          throw new Error(`Issuu API - Create Draft failed: ${createDraftResponse.status} ${createDraftResponse.statusText} - ${errorData?.message || 'Unknown error'}`);
        }

        const draftData = await createDraftResponse.json();
        const draftSlug = draftData.slug; // Assuming slug is directly available in response. Check Issuu API response structure.

        if (!draftSlug) {
          throw new Error("Issuu API - Draft slug not found in response.");
        }

        // 2. Upload Document to Draft
        const uploadUrl = `https://api.issuu.com/v2/drafts/${draftSlug}/upload`;
        const formData = new FormData();
        formData.append('file', pdfBlob, `document_${Date.now()}.pdf`);
        formData.append('confirmCopyright', 'true'); // Again, confirm copyright

        const uploadResponse = await fetch(uploadUrl, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${issuuApiBearerToken}`
          },
          body: formData
        });

        if (!uploadResponse.ok) {
          const errorData = await uploadResponse.json();
          throw new Error(`Issuu API - Upload Document failed: ${uploadResponse.status} ${uploadResponse.statusText} - ${errorData?.message || 'Unknown error'}`);
        }

        let uploadStatus = "PENDING";
        let fileInfo;
        // Polling to check conversion status - Issuu API needs time to process.
        while (uploadStatus !== "DONE") {
          await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before checking again
          const getDraftResponse = await fetch(`https://api.issuu.com/v2/drafts/${draftSlug}`, {
            headers: { 'Authorization': `Bearer ${issuuApiBearerToken}` }
          });
          if (!getDraftResponse.ok) {
             throw new Error(`Issuu API - Get Draft Status failed: ${getDraftResponse.status} ${getDraftResponse.statusText}`);
          }
          const getDraftData = await getDraftResponse.json();
          fileInfo = getDraftData.fileInfo;
          uploadStatus = fileInfo?.conversionStatus;
          if (uploadStatus === "FAILED") {
              throw new Error(`Issuu API - Document conversion failed on Issuu's side.`);
          }
        }
        return draftSlug; // Return slug for publication URL retrieval

      } catch (error) {
        console.error("Error uploading to Issuu:", error);
        return null;
      }
    }

    async function publishDraft(draftSlug, bearerToken) {
      const issuuApiPublishDraftUrl = `https://api.issuu.com/v2/drafts/${draftSlug}/publish`;

      try {
        updateStatus(`  > üöÄ Publishing Draft on Issuu...`);
        const response = await fetch(issuuApiPublishDraftUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json', // Important: Content-Type should be application/json even if body is empty
            'Authorization': `Bearer ${bearerToken}`
          },
          body: JSON.stringify({}) // Empty JSON body as per doc example (or omit body entirely - testing needed)
        });

        if (!response.ok) {
          const errorData = await response.json();
          console.error("Issuu API - Publish Draft failed response:", response.status, response.statusText, errorData);
          console.error("  Details:", JSON.stringify(errorData?.details)); // Log details of error
          throw new Error(`Issuu API - Publish Draft failed: ${response.status} ${response.statusText} - ${errorData?.message || 'Unknown error'} - Details: ${JSON.stringify(errorData?.details)}`);
        }

        const data = await response.json();
        console.log("Issuu API - Publish Draft success response:", data);
        return data.publicLocation; // Publication URL should be in publicLocation

      } catch (error) {
        console.error("Error publishing draft to Issuu:", error);
        return null;
      }
    }


    async function getPageTitle(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) return null;
        const text = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        const titleTag = doc.querySelector('title');
        return titleTag ? titleTag.textContent : null;
      } catch (error) {
        console.error("Error fetching page title:", error);
        return null;
      }
    }

    async function getPageDescription(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) return null;
        const text = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        const metaDescription = doc.querySelector('meta[name="description"]');
        return metaDescription ? metaDescription.getAttribute('content') : null;
      } catch (error) {
        console.error("Error fetching page description:", error);
        return null;
      }
    }

    async function parseSitemapUrls(sitemapUrl) {
      try {
        const response = await fetch(sitemapUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch sitemap: ${response.status} ${response.statusText}`);
        }
        const xmlText = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
        const urlElements = xmlDoc.querySelectorAll('loc');
        const urls = Array.from(urlElements).map(element => element.textContent);
        return urls;
      } catch (error) {
        console.error("Error parsing sitemap:", error);
        return null;
      }
    }

    function calculateEstimatedTime(startTime, processedCount, totalCount, estPerItem) {
      if (processedCount === 0) return "--";
      const elapsed = new Date().getTime() - startTime;
      const avgTimePerItem = elapsed / processedCount;
      const remainingItems = totalCount - processedCount;
      const estimatedRemainingTimeMs = remainingItems * avgTimePerItem;

      if (estimatedRemainingTimeMs < 0 ) return "Calculating...";

      const minutes = Math.floor(estimatedRemainingTimeMs / 60000);
      const seconds = Math.floor((estimatedRemainingTimeMs % 60000) / 1000);
      return `${minutes}m ${seconds}s`;
    }

    function copySuccessUrls() {
      const successUrlsTextarea = document.getElementById('successUrls');
      successUrlsTextarea.select();
      document.execCommand('copy');
    }

    function retryFailedUrls() {
      const failedUrlsTextarea = document.getElementById('failedUrls');
      const failedUrls = failedUrlsTextarea.value.trim().split('\n').filter(url => url);
      originalUrls = [...originalUrls, ...failedUrls]; // Add failed URLs back to original list
      applyUrlFilter(); // Re-apply filter
      failedUrlsTextarea.value = ""; // Clear failed URLs textarea
      document.getElementById('convertButton').click(); // Trigger conversion for failed URLs
    }


    async function listIssuuDocuments(documentType, bearerToken) {
      const issuuApiListUrl = `https://api.issuu.com/v2/${documentType}`; // documentType will be 'publications' or 'drafts'
      let allDocuments = [];
      let page = 1;
      let hasNextPage = true;

      updateCleanupStatus(`Fetching Issuu ${documentType}...`);

      while (hasNextPage) {
        try {
          const response = await fetch(`${issuuApiListUrl}?size=100&page=${page}`, { // Fetch 100 per page
            headers: { 'Authorization': `Bearer ${bearerToken}` }
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Issuu API - List ${documentType} failed: ${response.status} ${response.statusText} - ${errorData?.message || 'Unknown error'}`);
          }

          const data = await response.json();
          console.log(`Issuu API - List ${documentType} response (page ${page}):`, data); // **DEBUGGING LOG - Inspect the response data**

          if (data.results && Array.isArray(data.results)) {
            allDocuments = allDocuments.concat(data.results);
          }

          const links = data.links;
          if (links && links.next && links.next.href) {
            page++;
            hasNextPage = true; // More pages to fetch
          } else {
            hasNextPage = false; // No more 'next' link, end pagination
          }

        } catch (error) {
          console.error(`Error listing Issuu ${documentType}:`, error);
          updateCleanupStatus(`‚ùå Error fetching Issuu ${documentType}: ${error.message || error}`);
          return null; // Indicate failure
        }
      }
      updateCleanupStatus(`‚úÖ Fetched ${allDocuments.length} Issuu ${documentType}.`);
      return allDocuments;
    }

    async function deleteIssuuDocument(documentType, slug, bearerToken) {
      const issuuApiDeleteUrl = `https://api.issuu.com/v2/${documentType}/${slug}`; // documentType: 'drafts' or 'publications'

      try {
        const response = await fetch(issuuApiDeleteUrl, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${bearerToken}` }
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`Issuu API - Delete ${documentType} failed: ${response.status} ${response.statusText} - ${errorData?.message || 'Unknown error'}`);
        }
        console.log(`Successfully deleted Issuu ${documentType} with slug: ${slug}`);
        return true; // Deletion successful

      } catch (error) {
        console.error(`Error deleting Issuu ${documentType} with slug ${slug}:`, error);
        updateCleanupStatus(`‚ùå Error deleting Issuu ${documentType} slug ${slug}: ${error.message || error}`);
        return false; // Deletion failed
      }
    }


    async function cleanOutIssuu() {
      const issuuBearerToken = document.getElementById('issuuBearerToken').value.trim();
      const cleanupStatusTextarea = document.getElementById('cleanupStatus');
      cleanupStatusTextarea.value = ""; // Clear cleanup status

      if (!issuuBearerToken) {
        updateCleanupStatus("Please enter your Issuu Bearer Token in API Keys tab.");
        return;
      }

      updateCleanupStatus("Starting Issuu Cleanup Process...");

      const publications = await listIssuuDocuments('publications', issuuBearerToken);
      const drafts = await listIssuuDocuments('drafts', issuuBearerToken);

      if (!publications || !drafts) {
        updateCleanupStatus("Cleanup process aborted due to errors fetching documents.");
        return;
      }

      const documentsByTitle = {};

      // Group publications by title
      publications.forEach(pub => {
        const title = pub.info.title;
        if (!documentsByTitle[title]) {
          documentsByTitle[title] = { publications: [], drafts: [] };
        }
        documentsByTitle[title].publications.push(pub);
      });

      // Group drafts by title
      drafts.forEach(draft => {
        const title = draft.info.title;
        if (!documentsByTitle[title]) {
          documentsByTitle[title] = { publications: [], drafts: [] };
        }
        documentsByTitle[title].drafts.push(draft);
      });

      let deletedDraftCount = 0;
      let deletedPublicationCount = 0;
      let publishedDraftCount = 0;

      for (const title in documentsByTitle) {
        const docGroup = documentsByTitle[title];
        if (docGroup.publications.length > 0) {
          if (docGroup.drafts.length > 0) {
            updateCleanupStatus(`> Found Publication(s) and Draft(s) with title: "${title}". Deleting drafts...`);
            for (let i = 0; i < docGroup.drafts.length; i++) {
              const draft = docGroup.drafts[i];
              if (i < docGroup.drafts.length - 1) { // Keep one draft just in case, deleting the rest.
                 const deleteSuccess = await deleteIssuuDocument('drafts', draft.slug, issuuBearerToken);
                 if (deleteSuccess) {
                    deletedDraftCount++;
                 }
              }
            }
          }
          // Keep one publication, delete others if multiple exist (though unlikely in this scenario).
          if (docGroup.publications.length > 1) {
             updateCleanupStatus(`> Found multiple Publications with title: "${title}". Keeping one, deleting others...`);
             for (let i = 1; i < docGroup.publications.length; i++) { // Keep first publication, delete the rest.
                const pub = docGroup.publications[i];
                const deleteSuccess = await deleteIssuuDocument('publications', pub.slug, issuuBearerToken);
                if (deleteSuccess) {
                   deletedPublicationCount++;
                }
             }
          }

        } else if (docGroup.drafts.length > 0) {
          updateCleanupStatus(`> Only Draft(s) found with title: "${title}". Publishing one draft and deleting others...`);
          let draftToPublish = null;
          for (let i = 0; i < docGroup.drafts.length; i++) {
            const draft = docGroup.drafts[i];
            if (i < docGroup.drafts.length - 1) { // Keep one draft to publish, deleting the rest.
               const deleteSuccess = await deleteIssuuDocument('drafts', draft.slug, issuuBearerToken);
               if (deleteSuccess) {
                  deletedDraftCount++;
               }
            } else {
              draftToPublish = draft; // Keep the last draft to publish
            }
          }
          if (draftToPublish) {
            const publishSuccess = await publishDraft(draftToPublish.slug, issuuBearerToken);
            if (publishSuccess) {
              publishedDraftCount++;
              updateCleanupStatus(`  > Published draft with title "${title}", URL: ${publishSuccess}`);
            } else {
              updateCleanupStatus(`  > ‚ùå Failed to publish draft with title "${title}".`);
            }
          }
        }
      }

      updateCleanupStatus(`‚úÖ Issuu Cleanup Completed.`);
      updateCleanupStatus(`  > Drafts Deleted: ${deletedDraftCount}`);
      updateCleanupStatus(`  > Publications Deleted: ${deletedPublicationCount}`);
      updateCleanupStatus(`  > Drafts Published: ${publishedDraftCount}`);
      updateCleanupStatus("‚ö†Ô∏è Please manually check your Issuu dashboard to ensure cleanup is as expected, especially for edge cases.");
    }

    async function checkExistingUrlsInIssuu(urls, bearerToken) {
      const existingUrls = new Set();
      const publications = await listIssuuDocuments('publications', bearerToken);
      const drafts = await listIssuuDocuments('drafts', bearerToken);

      if (publications) {
        publications.forEach(pub => {
          let description = pub.info?.description; // Try to get description from pub.info?.description first

          if (!description) {
            description = pub.description; // **Fallback: Try to get description directly from pub.description**
          }

          if (description) {
            urls.forEach(url => {
              if (description.includes(url)) {
                existingUrls.add(url);
              }
            });
          } else {
            console.warn("Publication missing 'info.description' and 'description', skipping URL check for this publication:", pub); // Debugging log
          }
        });
      }
      if (drafts) {
        drafts.forEach(draft => {
          let description = draft.info?.description; // Try to get description from draft.info?.description first

          if (!description) {
            description = draft.changes?.description; // **Fallback: Try to get description from draft.changes?.description (less likely)**
          }
          if (!description) {
            description = draft.description; // **Fallback: Try to get description directly from draft.description (even less likely)**
          }


          if (description) {
            urls.forEach(url => {
              if (description.includes(url)) {
                existingUrls.add(url);
              }
            });
          } else {
            console.warn("Draft missing 'info.description', 'changes.description', and 'description', skipping URL check for this draft:", draft); // Debugging log
          }
        });
      }
      return existingUrls;
    }

    async function getSpeedyIndexBalance() {
      try {
        const response = await fetch('/speedyindex-api?action=get-balance');
        if (!response.ok) {
          console.error("Error fetching SpeedyIndex balance from Function:", response.status, response.statusText);
          return "Error";
        }
        const data = await response.json();
        if (data && data.balance && typeof data.balance.indexer !== 'undefined') {
          return data.balance.indexer;
        } else {
          console.warn("SpeedyIndex balance data structure unexpected:", data);
          return "N/A";
        }
      } catch (error) {
        console.error("Error fetching SpeedyIndex balance from Function:", error);
        return "Error";
      }
    }

    async function displaySpeedyIndexBalance() {
      const balance = await getSpeedyIndexBalance();
      const buttonText = balance === "Error" || balance === "N/A" ? `Index Issuu (${balance})` : `Index Issuu (${balance})`;
      document.getElementById('indexIssuuButton').textContent = buttonText;
    }

    async function indexSuccessUrls() {
      const successUrlsTextarea = document.getElementById('successUrls');
      const urls = successUrlsTextarea.value.trim().split('\n').filter(url => url);
      if (urls.length === 0) {
        updateStatus("No successful Issuu URLs to index.");
        return;
      }

      updateStatus("Starting SpeedyIndex indexing process (via Function)...");
      const indexStatus = await indexUrlsWithSpeedyIndex(urls); // Call client-side indexUrlsWithSpeedyIndex (modified below)
      if (indexStatus) {
        updateStatus("SpeedyIndex indexing process completed (via Function).");
      } else {
        updateStatus("SpeedyIndex indexing process failed (via Function). Check console for errors.");
      }
      await displaySpeedyIndexBalance(); // Update balance after indexing attempt
    }

    async function indexUrlsWithSpeedyIndex(urls) {
      try {
        const response = await fetch('/speedyindex-api?action=index-urls', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ urls: urls })
        });

        if (!response.ok) {
          const errorData = await response.json();
          updateStatus(`SpeedyIndex API - Task creation via Function failed: ${response.status} ${response.statusText} - ${errorData?.error || 'Unknown error'}`); // Error is in data.error now
          console.error("SpeedyIndex API - Task creation via Function failed:", response.status, response.statusText, errorData);
          return false;
        }

        const data = await response.json(); // Data from Function response
        updateStatus(`SpeedyIndex API - Task created successfully (via Function).`);
        updateStatus(`  > Task ID: ${data.task_id}`); // Access properties from Function response
        updateStatus(`  > Task Type: ${data.type}`);
        updateStatus(`  > Status Code: ${data.code}`);
        return true;

      } catch (error) {
        updateStatus(`Error calling SpeedyIndex Function: ${error.message || error}`);
        console.error("Error calling SpeedyIndex Function:", error);
        return false;
      }
    }

  </script>

</body>
</html>