<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RJPP - Rencana Jangka Panjang Perusahaan</title>
    <style>
        /* General Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa; /* Lighter gray background */
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #343a40; /* Darker text color */
            line-height: 1.6;
        }

        .container {
            width: 90%;
            max-width: 850px; /* Slightly wider */
            background-color: white;
            padding: 30px; /* More padding */
            border-radius: 12px; /* More rounded corners */
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* Softer shadow */
            margin-bottom: 20px;
        }

        h1, h2, h3 {
            text-align: center;
            color: #212529; /* Even darker heading color */
            margin-bottom: 1em;
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 1.5em;
        }

        h2 {
            font-size: 1.8em;
            border-bottom: 1px solid #dee2e6; /* Subtle separator */
            padding-bottom: 0.5em;
        }

        h3 {
             font-size: 1.4em;
             color: #495057; /* Slightly lighter heading color */
        }

        label {
            font-weight: 600; /* Bolder labels */
            display: block;
            margin-bottom: 8px;
            color: #495057;
        }

        input[type="text"],
        input[type="email"],
        textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            box-sizing: border-box;
            border-radius: 8px;
            border: 1px solid #ced4da; /* Standard border color */
            font-size: 1em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        textarea:focus {
            border-color: #80bdff; /* Blue focus border */
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); /* Blue focus shadow */
        }

        textarea {
            min-height: 150px;
            resize: vertical; /* Allow vertical resize */
        }

        button {
            padding: 12px 25px;
            cursor: pointer;
            border-radius: 8px;
            background-color: #007bff; /* Primary blue */
            color: white;
            border: none;
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin: 5px; /* Add some margin around buttons */
        }

        button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

        button:active {
             transform: scale(0.98); /* Slight shrink on click */
        }

        button:disabled {
            background-color: #6c757d; /* Gray for disabled */
            cursor: not-allowed;
        }

        button.secondary {
             background-color: #6c757d; /* Gray secondary button */
        }
         button.secondary:hover {
             background-color: #5a6268; /* Darker gray on hover */
        }

        /* Section Visibility */
        #user-info-form-section,
        #checkpoint-section,
        #topic-checkpoint-section,
        #topic-greeting-section,
        #question-section,
        #analysis-completion-section,
        #report-section {
            display: none; /* Hide all sections initially */
            width: 100%; /* Ensure sections take full width of container */
        }

        /* Checkpoint Styling */
        .checkpoint-grid, .topic-checkpoint-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
            gap: 20px;
            margin-top: 20px;
        }

        .checkpoint-card, .topic-checkpoint-card {
            background-color: #f8f9fa; /* Light background for cards */
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space out content and button */
        }

        .checkpoint-card:hover, .topic-checkpoint-card:hover {
            transform: translateY(-5px); /* Lift effect on hover */
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
        }

        .checkpoint-card h3, .topic-checkpoint-card h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
            color: #343a40;
        }

        .checkpoint-status, .topic-checkpoint-status {
            font-size: 0.9em;
            color: #6c757d; /* Gray for status */
            margin-bottom: 15px;
        }

         .checkpoint-status.done, .topic-checkpoint-status.done {
             color: #28a745; /* Green for done */
             font-weight: bold;
         }

        .checkpoint-card button, .topic-checkpoint-card button {
            margin-top: auto; /* Push button to bottom */
            width: 100%;
            padding: 10px 15px;
            font-size: 0.95em;
        }

        /* Question Card Styling */
        #question-card {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: translateY(0);
            border: 1px solid #e9ecef; /* Subtle border */
        }

        .card-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .card-analysis, .card-topic {
            font-size: 1em; /* Slightly larger */
            color: #6c757d; /* Gray */
            margin-bottom: 5px;
        }
         .card-analysis { font-weight: 600; } /* Bolder analysis */

        .card-question {
            font-weight: 500; /* Medium weight */
            margin-bottom: 20px;
            text-align: left; /* Align question text left */
            font-size: 1.15em; /* Larger question text */
            line-height: 1.5;
        }

        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            align-items: center; /* Vertically align items */
        }

        .progress-container {
            margin-bottom: 25px;
            text-align: center;
        }

        .progress-bar-info {
            font-size: 0.95em;
            color: #495057;
            margin-bottom: 8px;
        }

        .progress-bar-wrapper {
             width: 100%;
             background-color: #e9ecef; /* Light gray background */
             border-radius: 50px; /* Pill shape */
             height: 12px; /* Slightly thicker */
             overflow: hidden;
             position: relative; /* Needed for segment overlay */
        }

        #progress-fill {
            height: 100%;
            width: 0%;
            background-color: #007bff; /* Primary blue */
            border-radius: 50px;
            transition: width 0.4s ease-in-out;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
        }

        #progress-segments {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             display: flex;
             z-index: 2; /* Segments on top of fill */
         }

         .progress-segment {
             flex-grow: 1; /* Each segment takes equal space */
             border-right: 1px solid rgba(255, 255, 255, 0.5); /* White separator */
         }
         .progress-segment:last-child {
             border-right: none;
         }

        /* Greeting Card Styling */
        .greeting-card {
            text-align: center;
            padding: 40px 20px;
            background-color: #e9f7ff; /* Light blue background */
            border-radius: 12px;
            border: 1px solid #bce0ff; /* Light blue border */
            margin-bottom: 30px;
        }
        .greeting-card h2 {
            color: #0056b3; /* Dark blue heading */
            border-bottom: none; /* Remove border */
        }
        .greeting-card p {
            color: #004085; /* Medium blue text */
            font-size: 1.1em;
            margin-bottom: 25px;
        }
        .greeting-buttons {
             display: flex;
             justify-content: center;
             gap: 15px;
             flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        /* Report Section Styling */
        #report-section {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }
        #report-user-info {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px dashed #ced4da;
        }
         #report-user-info p { margin: 5px 0; }
         #report-user-info strong { color: #343a40; }

        #report-answers h3 {
            font-size: 1.3em;
            color: #007bff; /* Blue for analysis titles */
            margin-top: 25px;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
         #report-answers h4 {
             font-size: 1.1em;
             color: #495057; /* Dark gray for topic titles */
             margin-top: 15px;
             margin-bottom: 10px;
             text-align: left;
         }
         #report-answers div { /* Container for each Q&A */
             margin-bottom: 15px;
             padding-left: 10px;
             border-left: 3px solid #e9ecef; /* Left border for visual grouping */
         }
         #report-answers p { margin: 5px 0; }
         #report-answers p strong { /* Question text */
             display: block; /* Question on its own line */
             color: #343a40;
             margin-bottom: 3px;
         }
         #report-answers p span { /* Answer text */
             color: #555;
             white-space: pre-wrap; /* Preserve line breaks in answer */
             display: block; /* Answer below question */
             padding-left: 10px;
         }

        .report-actions {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px dashed #ced4da;
        }

        /* Loading/Error Styling */
        #loading-indicator {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #6c757d;
        }
         #error-message {
             text-align: center;
             padding: 30px;
             background-color: #f8d7da; /* Light red */
             color: #721c24; /* Dark red */
             border: 1px solid #f5c6cb; /* Red border */
             border-radius: 8px;
             margin: 20px auto; /* Center horizontally */
             width: 80%;
             max-width: 600px;
             display: none; /* Hidden by default */
         }

        /* Confetti and Balloon Styles (Keep existing or refine) */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 1000;
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00; /* Example color */
            opacity: 0.7;
            border-radius: 50%;
            animation: confetti-fall 3s linear infinite;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotateZ(0deg); opacity: 0.7; }
            100% { transform: translateY(110vh) rotateZ(720deg); opacity: 0; }
        }
        .balloon-container {
            position: fixed;
            bottom: -10%; /* Start below screen */
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999; /* Below confetti */
            display: flex;
            justify-content: space-around;
        }
        .balloon {
            width: 60px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.7); /* Example color */
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            position: relative; /* Needed for pseudo-element */
            opacity: 0;
            animation: balloon-float 5s ease-in infinite, balloon-sway 3s ease-in-out infinite alternate;
        }
        .balloon::after { /* Balloon string */
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 30px;
            background-color: #555;
        }
        @keyframes balloon-float {
            0% { transform: translateY(0); opacity: 0.7; }
            100% { transform: translateY(-110vh); opacity: 0; }
        }
        @keyframes balloon-sway {
             0% { transform: translateX(-10px) rotateZ(-5deg); }
             100% { transform: translateX(10px) rotateZ(5deg); }
        }


    </style>
</head>
<body>
    <div class="container">
        <h1>RJPP - Analisis Perusahaan</h1>

        <div id="loading-indicator">Loading questions...</div>
        <div id="error-message"></div>

        <div id="user-info-form-section">
            <h2>Informasi Dasar</h2>
            <form id="user-info-form">
                <label for="companyName">Nama Perusahaan:</label>
                <input type="text" id="companyName" name="companyName" required>

                <label for="userName">Nama Anda:</label>
                <input type="text" id="userName" name="userName" required>

                <label for="userEmail">Email Anda:</label>
                <input type="email" id="userEmail" name="userEmail" required>

                <center><button type="submit">Mulai Analisis</button></center>
            </form>
        </div>

        <div id="checkpoint-section">
            <h2>Pilih Analisis Utama</h2>
            <p style="text-align: center; color: #6c757d;">Pilih salah satu analisis untuk memulai atau melanjutkan.</p>
            <div id="checkpoint-grid" class="checkpoint-grid">
                </div>
        </div>

        <div id="topic-checkpoint-section">
            <h2 id="topic-checkpoint-analysis-name">Topik dalam Analisis X</h2>
             <p style="text-align: center; color: #6c757d;">Pilih topik yang ingin Anda kerjakan dalam analisis ini.</p>
            <div id="topic-checkpoint-grid" class="topic-checkpoint-grid">
                </div>
            <center style="margin-top: 30px;">
                <button id="go-to-main-checkpoint-btn" class="secondary">‚¨ÖÔ∏è Kembali ke Daftar Analisis</button>
            </center>
        </div>

        <div id="topic-greeting-section">
            <div id="topic-greeting-card" class="greeting-card">
                <h2 id="topic-greeting-title">Memulai Topik: Y</h2>
                <p id="topic-greeting-description">Anda akan memulai pertanyaan untuk topik ini.</p>
                <div class="greeting-buttons">
                    <button id="go-to-topic-checkpoint-btn" class="secondary">‚¨ÖÔ∏è Kembali ke Daftar Topik</button>
                    <button id="start-topic-btn">Mulai Pertanyaan</button>
                    <button id="next-topic-btn" style="display: none;">Lanjut ke Topik Berikutnya ‚û°Ô∏è</button>
                </div>
            </div>
             <center style="margin-top: 30px;">
                 <button id="go-to-main-checkpoint-btn-from-greeting" class="secondary">‚¨ÖÔ∏è Kembali ke Daftar Analisis Utama</button>
             </center>
        </div>

        <div id="question-section">
            <div class="progress-container">
                <div id="question-number" class="progress-bar-info">Pertanyaan X dari Y</div>
                <div class="progress-bar-wrapper">
                     <div id="progress-segments"></div>
                     <div id="progress-fill"></div>
                </div>
            </div>

            <div id="question-card" class="card">
                <div class="card-header">
                    <div id="card-analysis-title" class="card-analysis">Analisis: ...</div>
                    <div id="card-topic-title" class="card-topic">Topik: ...</div>
                </div>
                <div id="card-question-text" class="card-question">Teks pertanyaan akan muncul di sini...</div>
                <label for="answer-textarea">Jawaban Anda:</label>
                <textarea id="answer-textarea" placeholder="Ketik jawaban Anda di sini..."></textarea>
            </div>
            <div class="navigation-buttons">
                <button id="prev-btn" class="secondary">‚¨ÖÔ∏è Kembali</button>
                <button id="next-btn-question">Lanjut ‚û°Ô∏è</button>
            </div>
             <center style="margin-top: 20px;">
                <button id="back-to-topic-checkpoint-btn" class="secondary">Kembali ke Daftar Topik</button>
             </center>
        </div>

         <div id="analysis-completion-section">
              <div id="analysis-completion-card" class="greeting-card" style="background-color: #e2f0d9; border-color: #c3e6cb;">
                  <h2 style="color: #155724;">üéâ Analisis Selesai! üéâ</h2>
                  <p style="color: #155724;" id="analysis-completion-text">Selamat! Anda telah menyelesaikan semua pertanyaan untuk analisis '[Analysis Name]'.</p>
                  <div class="greeting-buttons">
                      <button id="go-to-main-checkpoint-btn-from-completion" class="secondary">Kembali ke Daftar Analisis</button>
                      <button id="view-full-report-btn">Lihat Laporan Lengkap üìÑ</button>
                  </div>
              </div>
              <div class="confetti-container" id="completion-confetti"></div>
              <div class="balloon-container" id="completion-balloons"></div>
         </div>

        <div id="report-section">
            <h2>Laporan Hasil Analisis RJPP</h2>

            <div id="report-user-info">
                <h3>Informasi Pengguna</h3>
                </div>

            <div id="report-answers">
                <h3>Jawaban Analisis</h3>
                </div>

            <div class="report-actions">
                 <button id="back-to-main-checkpoint-btn" class="secondary">Kembali ke Daftar Analisis</button>
                 <button id="review-answers-btn">‚úèÔ∏è Tinjau/Edit Jawaban</button>
                 <button id="download-report-btn">üíæ Unduh Laporan (JSON)</button>
                 <button id="copy-report-btn">üìã Salin Laporan (Markdown)</button>
            </div>
        </div>

    </div><script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessageDiv = document.getElementById('error-message');

        const userInfoFormSection = document.getElementById('user-info-form-section');
        const userInfoForm = document.getElementById('user-info-form');
        const companyNameInput = document.getElementById('companyName');
        const userNameInput = document.getElementById('userName');
        const userEmailInput = document.getElementById('userEmail');

        const checkpointSection = document.getElementById('checkpoint-section');
        const checkpointGrid = document.getElementById('checkpoint-grid');

        const topicCheckpointSection = document.getElementById('topic-checkpoint-section');
        const topicCheckpointAnalysisNameDisplay = document.getElementById('topic-checkpoint-analysis-name');
        const topicCheckpointGrid = document.getElementById('topic-checkpoint-grid');
        const goToMainCheckpointBtn_TopicCheckpoint = document.getElementById('go-to-main-checkpoint-btn'); // In topic checkpoint section

        const topicGreetingSection = document.getElementById('topic-greeting-section');
        const topicGreetingCard = document.getElementById('topic-greeting-card');
        const topicGreetingTitle = document.getElementById('topic-greeting-title');
        const topicGreetingDescription = document.getElementById('topic-greeting-description');
        const goToTopicCheckpointBtn_Greeting = document.getElementById('go-to-topic-checkpoint-btn');
        const startTopicBtn = document.getElementById('start-topic-btn');
        const nextTopicBtn = document.getElementById('next-topic-btn');
        const goToMainCheckpointBtn_Greeting = document.getElementById('go-to-main-checkpoint-btn-from-greeting'); // In greeting section

        const questionSection = document.getElementById('question-section');
        const questionCard = document.getElementById('question-card');
        const cardAnalysisTitle = document.getElementById('card-analysis-title');
        const cardTopicTitle = document.getElementById('card-topic-title');
        const cardQuestionText = document.getElementById('card-question-text');
        const answerTextarea = document.getElementById('answer-textarea');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtnQuestion = document.getElementById('next-btn-question');
        const questionNumberDisplay = document.getElementById('question-number');
        const progressBarFill = document.getElementById('progress-fill');
        const progressBarSegments = document.getElementById('progress-segments');
        const backToTopicCheckpointBtn = document.getElementById('back-to-topic-checkpoint-btn'); // In question section

        const analysisCompletionSection = document.getElementById('analysis-completion-section');
        const analysisCompletionText = document.getElementById('analysis-completion-text');
        const goToMainCheckpointBtn_Completion = document.getElementById('go-to-main-checkpoint-btn-from-completion');
        const viewFullReportBtn = document.getElementById('view-full-report-btn');
        const completionConfettiContainer = document.getElementById('completion-confetti');
        const completionBalloonsContainer = document.getElementById('completion-balloons');


        const reportSection = document.getElementById('report-section');
        const reportUserInfoDiv = document.getElementById('report-user-info');
        const reportAnswersDiv = document.getElementById('report-answers');
        const backToMainCheckpointBtn_Report = document.getElementById('back-to-main-checkpoint-btn'); // In report section
        const reviewAnswersBtn = document.getElementById('review-answers-btn'); // NEW button in report section
        const downloadReportBtn = document.getElementById('download-report-btn');
        const copyReportBtn = document.getElementById('copy-report-btn');


        // --- State Variables ---
        let questionsData = {}; // Will be populated from Markdown
        let currentAnalysisKeys = [];
        let currentTopicKeys = {}; // Stores topic keys for each analysis
        let allQuestionsFlat = []; // Flat array of all questions { analysis, topic, question, answerKey, index }

        let currentUserInfo = { companyName: '', userName: '', userEmail: '' };
        let answers = {}; // Stores answers keyed by answerKey
        let analysisProgress = {}; // { analysisKey: { completed: bool, total: int, answered: int } }
        let topicProgress = {}; // { analysisKey: { topicKey: { completed: bool, total: int, answered: int } } }

        let currentAnalysisKey = null;
        let currentTopicKey = null;
        let currentQuestionIndexInTopic = 0; // Index within the current topic's questions
        let currentGlobalQuestionIndex = 0; // Index within the flat allQuestionsFlat array


        // --- Constants ---
        const QUESTIONS_MD_URL = 'rjpp-questions.md'; // Path to your Markdown file
        const LOCAL_STORAGE_KEY_INFO = 'rjppUserInfo';
        const LOCAL_STORAGE_KEY_ANSWERS = 'rjppAnswers';

        // --- Initialization ---
        async function initialize() {
            showLoading();
            try {
                await loadQuestionsFromMarkdown();
                loadState(); // Load user info and answers after questions are loaded
                calculateInitialProgress(); // Calculate progress based on loaded answers
                if (currentUserInfo.companyName) {
                    showCheckpointSection(); // If user info exists, show checkpoints
                } else {
                    showUserInfoForm(); // Otherwise, show form
                }
            } catch (error) {
                console.error("Initialization failed:", error);
                showError(`Failed to load questions: ${error.message}. Please ensure '${QUESTIONS_MD_URL}' exists and is accessible.`);
            } finally {
                hideLoading();
            }
        }

        // --- Data Loading and Parsing ---
        async function loadQuestionsFromMarkdown() {
            console.log(`Fetching questions from ${QUESTIONS_MD_URL}...`);
            const response = await fetch(QUESTIONS_MD_URL);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const markdown = await response.text();
            console.log("Markdown fetched successfully.");
            parseMarkdownToQuestions(markdown);
            console.log("Questions parsed:", questionsData);
            prepareFlatQuestionsList(); // Create the flat list after parsing
            console.log("Flat questions list created:", allQuestionsFlat.length, "questions total.");
        }

        function parseMarkdownToQuestions(markdown) {
             questionsData = {};
             currentAnalysisKeys = [];
             currentTopicKeys = {};
             let currentAnalysis = null;
             let currentTopic = null;
             const lines = markdown.split('\n');
             const keyRegex = /\{answerKey:\s*([^}]+)\}/; // Regex to extract answerKey

             lines.forEach(line => {
                 line = line.trim();
                 if (line.startsWith('## ')) {
                     // New Analysis
                     currentAnalysis = line.substring(3).trim();
                     questionsData[currentAnalysis] = {};
                     currentAnalysisKeys.push(currentAnalysis);
                     currentTopicKeys[currentAnalysis] = [];
                     currentTopic = null; // Reset current topic
                     // console.log(`Found Analysis: ${currentAnalysis}`);
                 } else if (line.startsWith('### ') && currentAnalysis) {
                     // New Topic
                     currentTopic = line.substring(4).trim();
                     questionsData[currentAnalysis][currentTopic] = [];
                     currentTopicKeys[currentAnalysis].push(currentTopic);
                     // console.log(`  Found Topic: ${currentTopic} under ${currentAnalysis}`);
                 } else if (line.startsWith('- ') && currentAnalysis && currentTopic) {
                     // New Question
                     const match = line.match(keyRegex);
                     let questionText = line.substring(2).trim();
                     let answerKey = null;

                     if (match && match[1]) {
                         answerKey = match[1].trim();
                         // Remove the {answerKey: ...} part from the question text
                         questionText = questionText.replace(keyRegex, '').trim();
                     } else {
                          console.warn(`Missing answerKey for question: ${questionText} in ${currentAnalysis} > ${currentTopic}`);
                          // Generate a fallback key (less ideal, but prevents errors)
                          answerKey = `fallback_${currentAnalysis.replace(/\s+/g, '_')}_${currentTopic.replace(/\s+/g, '_')}_${questionsData[currentAnalysis][currentTopic].length}`;
                     }

                     questionsData[currentAnalysis][currentTopic].push({
                         question: questionText,
                         answerKey: answerKey
                     });
                     // console.log(`    Added Question: ${questionText.substring(0,30)}... {${answerKey}}`);
                 }
             });
         }

         function prepareFlatQuestionsList() {
              allQuestionsFlat = [];
              let globalIndex = 0;
              currentAnalysisKeys.forEach(analysisKey => {
                  if (currentTopicKeys[analysisKey]) {
                      currentTopicKeys[analysisKey].forEach(topicKey => {
                          if (questionsData[analysisKey] && questionsData[analysisKey][topicKey]) {
                              questionsData[analysisKey][topicKey].forEach((q, indexInTopic) => {
                                  allQuestionsFlat.push({
                                      analysis: analysisKey,
                                      topic: topicKey,
                                      question: q.question,
                                      answerKey: q.answerKey,
                                      indexInTopic: indexInTopic, // Store index within topic
                                      globalIndex: globalIndex++ // Store global index
                                  });
                              });
                          }
                      });
                  }
              });
         }


        // --- State Management (Save/Load) ---
        function saveState() {
            localStorage.setItem(LOCAL_STORAGE_KEY_INFO, JSON.stringify(currentUserInfo));
            localStorage.setItem(LOCAL_STORAGE_KEY_ANSWERS, JSON.stringify(answers));
            console.log("State saved to localStorage.");
        }

        function loadState() {
            const savedInfo = localStorage.getItem(LOCAL_STORAGE_KEY_INFO);
            const savedAnswers = localStorage.getItem(LOCAL_STORAGE_KEY_ANSWERS);

            if (savedInfo) {
                currentUserInfo = JSON.parse(savedInfo);
                companyNameInput.value = currentUserInfo.companyName;
                userNameInput.value = currentUserInfo.userName;
                userEmailInput.value = currentUserInfo.userEmail;
                console.log("User info loaded:", currentUserInfo);
            }
            if (savedAnswers) {
                answers = JSON.parse(savedAnswers);
                console.log("Answers loaded:", Object.keys(answers).length, "answers found.");
            }
        }

        // --- Progress Calculation ---
        function calculateInitialProgress() {
             analysisProgress = {};
             topicProgress = {};

             currentAnalysisKeys.forEach(analysisKey => {
                 let analysisTotal = 0;
                 let analysisAnswered = 0;
                 topicProgress[analysisKey] = {};

                 if (currentTopicKeys[analysisKey]) {
                     currentTopicKeys[analysisKey].forEach(topicKey => {
                         const questionsInTopic = questionsData[analysisKey]?.[topicKey] || [];
                         const topicTotal = questionsInTopic.length;
                         let topicAnswered = 0;

                         questionsInTopic.forEach(q => {
                             if (answers[q.answerKey] !== undefined && answers[q.answerKey] !== null && answers[q.answerKey] !== '') {
                                 topicAnswered++;
                             }
                         });

                         topicProgress[analysisKey][topicKey] = {
                             total: topicTotal,
                             answered: topicAnswered,
                             completed: topicTotal > 0 && topicAnswered === topicTotal
                         };

                         analysisTotal += topicTotal;
                         analysisAnswered += topicAnswered;
                     });
                 }

                 analysisProgress[analysisKey] = {
                     total: analysisTotal,
                     answered: analysisAnswered,
                     completed: analysisTotal > 0 && analysisAnswered === analysisTotal
                 };
             });
             console.log("Initial progress calculated:", { analysisProgress, topicProgress });
         }

        // Recalculate progress for a specific topic and its analysis
        function updateProgress(analysisKey, topicKey, questionAnswerKey, isAnswered) {
            if (!analysisKey || !topicKey || !questionAnswerKey) return;

            // --- Update Topic Progress ---
            if (!topicProgress[analysisKey]) topicProgress[analysisKey] = {};
            if (!topicProgress[analysisKey][topicKey]) {
                // Initialize if somehow missing (shouldn't happen often)
                const questionsInTopic = questionsData[analysisKey]?.[topicKey] || [];
                topicProgress[analysisKey][topicKey] = { total: questionsInTopic.length, answered: 0, completed: false };
            }

            const topicProg = topicProgress[analysisKey][topicKey];
            // Recount answered questions for the topic to ensure accuracy
            let topicAnsweredCount = 0;
             const questionsInTopic = questionsData[analysisKey]?.[topicKey] || [];
             questionsInTopic.forEach(q => {
                 if (answers[q.answerKey] !== undefined && answers[q.answerKey] !== null && answers[q.answerKey] !== '') {
                     topicAnsweredCount++;
                 }
             });
             topicProg.answered = topicAnsweredCount;
             topicProg.completed = topicProg.total > 0 && topicProg.answered === topicProg.total;


            // --- Update Analysis Progress ---
             if (!analysisProgress[analysisKey]) {
                  // Initialize if somehow missing
                  analysisProgress[analysisKey] = { total: 0, answered: 0, completed: false };
                  // Recalculate total for analysis
                  if (currentTopicKeys[analysisKey]) {
                       currentTopicKeys[analysisKey].forEach(tk => {
                           analysisProgress[analysisKey].total += questionsData[analysisKey]?.[tk]?.length || 0;
                       });
                  }
             }

             const analysisProg = analysisProgress[analysisKey];
             // Recount answered questions for the entire analysis
             let analysisAnsweredCount = 0;
             if (currentTopicKeys[analysisKey]) {
                  currentTopicKeys[analysisKey].forEach(tk => {
                       analysisAnsweredCount += topicProgress[analysisKey]?.[tk]?.answered || 0;
                  });
             }
             analysisProg.answered = analysisAnsweredCount;
             analysisProg.completed = analysisProg.total > 0 && analysisProg.answered === analysisProg.total;

             console.log(`Progress updated for ${analysisKey} > ${topicKey}:`, { topicProg, analysisProg });

             // Re-render relevant checkpoint sections if they are visible
             if (checkpointSection.style.display !== 'none') {
                 renderAnalysisCheckpoints();
             }
             if (topicCheckpointSection.style.display !== 'none' && currentAnalysisKey === analysisKey) {
                 renderTopicCheckpoints(analysisKey);
             }
        }


        // --- UI Rendering ---
        function showLoading() {
            hideAllSections();
            loadingIndicator.style.display = 'block';
            errorMessageDiv.style.display = 'none';
        }

        function hideLoading() {
            loadingIndicator.style.display = 'none';
        }

         function showError(message) {
             hideAllSections();
             errorMessageDiv.textContent = message;
             errorMessageDiv.style.display = 'block';
         }

        function hideAllSections() {
            userInfoFormSection.style.display = 'none';
            checkpointSection.style.display = 'none';
            topicCheckpointSection.style.display = 'none';
            topicGreetingSection.style.display = 'none';
            questionSection.style.display = 'none';
            analysisCompletionSection.style.display = 'none';
            reportSection.style.display = 'none';
            loadingIndicator.style.display = 'none'; // Also hide loading
            errorMessageDiv.style.display = 'none'; // Also hide error
        }

        function showUserInfoForm() {
            hideAllSections();
            userInfoFormSection.style.display = 'block';
        }

        function showCheckpointSection() {
            hideAllSections();
            renderAnalysisCheckpoints();
            checkpointSection.style.display = 'block';
            currentAnalysisKey = null; // Reset context when going back to main checkpoints
            currentTopicKey = null;
        }

        function renderAnalysisCheckpoints() {
             checkpointGrid.innerHTML = ''; // Clear existing cards
             currentAnalysisKeys.forEach(analysisKey => {
                 const card = document.createElement('div');
                 card.className = 'checkpoint-card';
                 const progress = analysisProgress[analysisKey] || { answered: 0, total: 0, completed: false };
                 const isDone = progress.completed;
                 const statusText = isDone ? 'Selesai' : `${progress.answered} / ${progress.total} Pertanyaan`;

                 card.innerHTML = `
                     <h3>${analysisKey}</h3>
                     <p class="checkpoint-status ${isDone ? 'done' : ''}">${statusText}</p>
                     <button data-analysis="${analysisKey}">${isDone ? 'Lihat Topik' : 'Mulai/Lanjutkan'}</button>
                 `;
                 card.querySelector('button').addEventListener('click', () => {
                     showTopicCheckpointSection(analysisKey);
                 });
                 checkpointGrid.appendChild(card);
             });
         }


        function showTopicCheckpointSection(analysisKey) {
            hideAllSections();
            currentAnalysisKey = analysisKey; // Set current analysis context
            topicCheckpointAnalysisNameDisplay.textContent = `Topik dalam: ${analysisKey}`;
            renderTopicCheckpoints(analysisKey);
            topicCheckpointSection.style.display = 'block';
            currentTopicKey = null; // Reset topic context
        }

         function renderTopicCheckpoints(analysisKey) {
             topicCheckpointGrid.innerHTML = ''; // Clear existing
             const topics = currentTopicKeys[analysisKey] || [];

             if (topics.length === 0) {
                  topicCheckpointGrid.innerHTML = '<p>Tidak ada topik ditemukan untuk analisis ini.</p>';
                  return;
             }

             topics.forEach(topicKey => {
                 const card = document.createElement('div');
                 card.className = 'topic-checkpoint-card';
                 const progress = topicProgress[analysisKey]?.[topicKey] || { answered: 0, total: 0, completed: false };
                 const isDone = progress.completed;
                 const statusText = isDone ? 'Selesai' : `${progress.answered} / ${progress.total} Pertanyaan`;

                 card.innerHTML = `
                     <h3>${topicKey}</h3>
                     <p class="topic-checkpoint-status ${isDone ? 'done' : ''}">${statusText}</p>
                     <button data-topic="${topicKey}">${isDone ? 'Tinjau' : 'Mulai/Lanjutkan'}</button>
                 `;
                 card.querySelector('button').addEventListener('click', () => {
                     showTopicGreeting(analysisKey, topicKey);
                 });
                 topicCheckpointGrid.appendChild(card);
             });
         }

         function showTopicGreeting(analysisKey, topicKey) {
             hideAllSections();
             currentAnalysisKey = analysisKey;
             currentTopicKey = topicKey;
             const topicsInAnalysis = currentTopicKeys[analysisKey] || [];
             const currentTopicIndex = topicsInAnalysis.indexOf(topicKey);
             const nextTopicIndex = currentTopicIndex + 1;
             const isLastTopic = nextTopicIndex >= topicsInAnalysis.length;
             const topicProg = topicProgress[analysisKey]?.[topicKey] || { completed: false };

             topicGreetingTitle.textContent = `${topicProg.completed ? 'Meninjau' : 'Memulai'} Topik: ${topicKey}`;
             topicGreetingDescription.textContent = topicProg.completed
                ? `Anda telah menyelesaikan semua pertanyaan untuk topik ini. Anda dapat memulai untuk meninjau jawaban Anda.`
                : `Anda akan memulai atau melanjutkan pertanyaan untuk topik '${topicKey}'.`;

             // Show/hide "Next Topic" button
             if (!isLastTopic) {
                 nextTopicBtn.style.display = 'inline-block'; // Use inline-block for proper spacing
                 nextTopicBtn.textContent = `Lanjut ke Topik: ${topicsInAnalysis[nextTopicIndex]} ‚û°Ô∏è`;
                 nextTopicBtn.onclick = () => showTopicGreeting(analysisKey, topicsInAnalysis[nextTopicIndex]);
             } else {
                 nextTopicBtn.style.display = 'none';
             }

             // Update Start button text
             startTopicBtn.textContent = topicProg.completed ? 'Mulai Tinjau Jawaban' : 'Mulai Pertanyaan';

             topicGreetingSection.style.display = 'block';
         }


        function showQuestionSection(analysisKey, topicKey, questionIndex = 0) {
            hideAllSections();
            currentAnalysisKey = analysisKey;
            currentTopicKey = topicKey;
            currentQuestionIndexInTopic = questionIndex;

            // Find the corresponding global index
            const questionInfo = findQuestionByTopicIndex(analysisKey, topicKey, questionIndex);
            if (!questionInfo) {
                console.error(`Question not found for ${analysisKey} > ${topicKey} at index ${questionIndex}`);
                showTopicCheckpointSection(analysisKey); // Go back if question not found
                return;
            }
            currentGlobalQuestionIndex = questionInfo.globalIndex; // Set global index

            displayQuestion(currentGlobalQuestionIndex);
            questionSection.style.display = 'block';
        }

        // Helper to find a question in the flat list by its topic index
        function findQuestionByTopicIndex(analysisKey, topicKey, indexInTopic) {
            return allQuestionsFlat.find(q =>
                q.analysis === analysisKey &&
                q.topic === topicKey &&
                q.indexInTopic === indexInTopic
            );
        }

         // Helper to find a question in the flat list by its global index
         function findQuestionByGlobalIndex(globalIndex) {
             return allQuestionsFlat[globalIndex];
         }

        function displayQuestion(globalIndex) {
            if (globalIndex < 0 || globalIndex >= allQuestionsFlat.length) {
                console.error("Invalid globalIndex:", globalIndex);
                // Decide where to go - maybe back to topic checkpoints?
                 if (currentAnalysisKey) {
                     showTopicCheckpointSection(currentAnalysisKey);
                 } else {
                     showCheckpointSection(); // Fallback to main checkpoints
                 }
                return;
            }

            const questionInfo = allQuestionsFlat[globalIndex];
            currentGlobalQuestionIndex = globalIndex; // Ensure state is updated
            currentAnalysisKey = questionInfo.analysis; // Update context just in case
            currentTopicKey = questionInfo.topic;
            currentQuestionIndexInTopic = questionInfo.indexInTopic;

            const questionsInCurrentTopic = questionsData[currentAnalysisKey]?.[currentTopicKey] || [];
            const totalQuestionsInTopic = questionsInCurrentTopic.length;

            // Substitute company name
            const formattedQuestion = questionInfo.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');

            // Update UI elements
            cardAnalysisTitle.textContent = `Analisis: ${currentAnalysisKey}`;
            cardTopicTitle.textContent = `Topik: ${currentTopicKey}`;
            cardQuestionText.innerHTML = marked.parseInline(formattedQuestion); // Use marked to render potential markdown in question
            answerTextarea.value = answers[questionInfo.answerKey] || ''; // Load saved answer

            // Update progress bar info
            questionNumberDisplay.textContent = `Pertanyaan ${currentQuestionIndexInTopic + 1} dari ${totalQuestionsInTopic} (Topik Ini)`;

             // Update overall progress bar (based on global index)
             const overallProgressPercent = ((globalIndex + 1) / allQuestionsFlat.length) * 100;
             progressBarFill.style.width = `${overallProgressPercent}%`;

             // Update progress segments (visual dividers for topics/analyses - optional refinement)
             // This is a simplified version showing segments for the current topic only
             progressBarSegments.innerHTML = ''; // Clear previous segments
             for (let i = 0; i < totalQuestionsInTopic; i++) {
                 const segment = document.createElement('div');
                 segment.className = 'progress-segment';
                 progressBarSegments.appendChild(segment);
             }


            // Enable/disable navigation buttons
            prevBtn.disabled = globalIndex === 0;
            // Next button logic depends on whether it's the last question overall
            // nextBtnQuestion.textContent = (globalIndex === allQuestionsFlat.length - 1) ? 'Selesai & Lihat Laporan' : 'Lanjut ‚û°Ô∏è';
            // Let's keep 'Lanjut' and handle the completion logic in the event listener

            // Focus the textarea for immediate input
            answerTextarea.focus();

            // Fade in the card (optional animation)
            questionCard.style.opacity = '0';
            questionCard.style.transform = 'translateY(10px)';
            setTimeout(() => {
                questionCard.style.opacity = '1';
                questionCard.style.transform = 'translateY(0)';
            }, 50); // Short delay for transition
        }

        function showAnalysisCompletion(analysisKey) {
             hideAllSections();
             analysisCompletionText.textContent = `Selamat! Anda telah menyelesaikan semua pertanyaan untuk analisis '${analysisKey}'.`;
             analysisCompletionSection.style.display = 'block';
             triggerCompletionAnimation(); // Start confetti/balloons
         }

         function showReportSection() {
             hideAllSections();
             renderReport();
             reportSection.style.display = 'block';
             stopCompletionAnimation(); // Stop confetti if navigating from completion screen
         }

         function renderReport() {
             // 1. Render User Info
             reportUserInfoDiv.innerHTML = `
                 <h3>Informasi Pengguna</h3>
                 <p><strong>Nama Perusahaan:</strong> ${currentUserInfo.companyName || 'N/A'}</p>
                 <p><strong>Nama Pengguna:</strong> ${currentUserInfo.userName || 'N/A'}</p>
                 <p><strong>Email:</strong> ${currentUserInfo.userEmail || 'N/A'}</p>
                 <p><strong>Tanggal Laporan:</strong> ${new Date().toLocaleDateString('id-ID', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p>
             `;

             // 2. Render Answers, grouped by Analysis and Topic
             reportAnswersDiv.innerHTML = '<h3>Jawaban Analisis</h3>'; // Reset content
             let reportContent = '';

             currentAnalysisKeys.forEach(analysisKey => {
                 const analysisHasAnswers = currentTopicKeys[analysisKey]?.some(topicKey =>
                     questionsData[analysisKey]?.[topicKey]?.some(q => answers[q.answerKey])
                 );

                 if (analysisHasAnswers) {
                     reportContent += `<h3>${analysisKey}</h3>`;
                     currentTopicKeys[analysisKey].forEach(topicKey => {
                         const topicQuestions = questionsData[analysisKey]?.[topicKey] || [];
                         const topicHasAnswers = topicQuestions.some(q => answers[q.answerKey]);

                         if (topicHasAnswers) {
                             reportContent += `<h4>${topicKey}</h4>`;
                             topicQuestions.forEach(q => {
                                 const answer = answers[q.answerKey];
                                 if (answer !== undefined && answer !== null && answer !== '') {
                                     // Substitute company name in the question for the report
                                     const formattedQuestion = q.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                                     // Basic escaping for HTML in answers (prevent XSS)
                                     const escapedAnswer = answer.replace(/</g, "&lt;").replace(/>/g, "&gt;");

                                     reportContent += `
                                         <div>
                                             <p><strong>${formattedQuestion}</strong></p>
                                             <p><span>${escapedAnswer || '<i>(Tidak dijawab)</i>'}</span></p>
                                         </div>
                                     `;
                                 }
                             });
                         }
                     });
                 }
             });

             if (!reportContent.includes('<h3>')) { // Check if any analysis section was added
                  reportAnswersDiv.innerHTML += '<p><i>Belum ada jawaban yang diberikan.</i></p>';
             } else {
                  reportAnswersDiv.innerHTML += reportContent;
             }
         }

        // --- Event Handlers ---
        userInfoForm.addEventListener('submit', (e) => {
            e.preventDefault();
            currentUserInfo.companyName = companyNameInput.value.trim();
            currentUserInfo.userName = userNameInput.value.trim();
            currentUserInfo.userEmail = userEmailInput.value.trim();
            if (currentUserInfo.companyName && currentUserInfo.userName && currentUserInfo.userEmail) {
                saveState();
                showCheckpointSection();
            } else {
                 alert('Harap isi semua informasi.'); // Simple validation
            }
        });

        // --- Navigation Button Event Listeners ---

        // Back from Topic Checkpoints to Main Checkpoints
        goToMainCheckpointBtn_TopicCheckpoint.addEventListener('click', showCheckpointSection);

         // Back from Topic Greeting to Topic Checkpoints
         goToTopicCheckpointBtn_Greeting.addEventListener('click', () => {
             if (currentAnalysisKey) {
                 showTopicCheckpointSection(currentAnalysisKey);
             } else {
                 showCheckpointSection(); // Fallback
             }
         });

        // Back from Topic Greeting to Main Checkpoints
        goToMainCheckpointBtn_Greeting.addEventListener('click', showCheckpointSection);

        // Start questions from Topic Greeting
         startTopicBtn.addEventListener('click', () => {
             if (currentAnalysisKey && currentTopicKey) {
                 // Start from the first *unanswered* question in the topic, or the first question if all answered
                 const questionsInTopic = questionsData[currentAnalysisKey]?.[currentTopicKey] || [];
                 let startIndex = 0;
                 for(let i = 0; i < questionsInTopic.length; i++) {
                     if (!answers[questionsInTopic[i].answerKey]) {
                         startIndex = i;
                         break; // Found first unanswered
                     }
                     // If loop finishes, all are answered, startIndex remains 0 (or could be set to 0 explicitly)
                 }
                 showQuestionSection(currentAnalysisKey, currentTopicKey, startIndex);
             }
         });

         // Back from Question Section to Topic Checkpoints
         backToTopicCheckpointBtn.addEventListener('click', () => {
              // Save current answer before navigating away
              const currentQuestionInfo = findQuestionByGlobalIndex(currentGlobalQuestionIndex);
              if (currentQuestionInfo) {
                  const currentAnswer = answerTextarea.value.trim();
                  const previousAnswer = answers[currentQuestionInfo.answerKey];
                  if (currentAnswer !== previousAnswer) {
                      answers[currentQuestionInfo.answerKey] = currentAnswer;
                      updateProgress(currentAnalysisKey, currentTopicKey, currentQuestionInfo.answerKey, !!currentAnswer);
                      saveState();
                  }
              }
              // Navigate back
              if (currentAnalysisKey) {
                  showTopicCheckpointSection(currentAnalysisKey);
              } else {
                   showCheckpointSection(); // Fallback
              }
         });

         // Back from Analysis Completion to Main Checkpoints
         goToMainCheckpointBtn_Completion.addEventListener('click', () => {
             stopCompletionAnimation();
             showCheckpointSection();
         });

         // View Full Report from Analysis Completion
         viewFullReportBtn.addEventListener('click', () => {
             stopCompletionAnimation();
             showReportSection();
         });

         // Back from Report to Main Checkpoints
         backToMainCheckpointBtn_Report.addEventListener('click', showCheckpointSection);

         // --- Question Navigation ---
         prevBtn.addEventListener('click', () => {
             if (currentGlobalQuestionIndex > 0) {
                 // Save current answer before moving
                 const currentQuestionInfo = findQuestionByGlobalIndex(currentGlobalQuestionIndex);
                 const currentAnswer = answerTextarea.value.trim();
                  const previousAnswer = answers[currentQuestionInfo.answerKey];
                  if (currentAnswer !== previousAnswer) {
                       answers[currentQuestionInfo.answerKey] = currentAnswer;
                       updateProgress(currentAnalysisKey, currentTopicKey, currentQuestionInfo.answerKey, !!currentAnswer);
                       saveState();
                  }
                 // Move to previous
                 displayQuestion(currentGlobalQuestionIndex - 1);
             }
         });

         nextBtnQuestion.addEventListener('click', () => {
             // 1. Save the current answer
             const currentQuestionInfo = findQuestionByGlobalIndex(currentGlobalQuestionIndex);
             if (!currentQuestionInfo) return; // Should not happen

             const currentAnswer = answerTextarea.value.trim();
             const wasAnsweredBefore = !!answers[currentQuestionInfo.answerKey];
             const isAnsweredNow = !!currentAnswer;

             answers[currentQuestionInfo.answerKey] = currentAnswer; // Save even if empty
             // Update progress only if the answered status changed or if it's newly answered
             if (isAnsweredNow !== wasAnsweredBefore || isAnsweredNow) {
                  updateProgress(currentAnalysisKey, currentTopicKey, currentQuestionInfo.answerKey, isAnsweredNow);
             }
             saveState(); // Save state after every answer change

             // 2. Determine next step
             const nextGlobalIndex = currentGlobalQuestionIndex + 1;
             const questionsInCurrentTopic = questionsData[currentAnalysisKey]?.[currentTopicKey] || [];
             const isLastQuestionInTopic = currentQuestionIndexInTopic >= questionsInCurrentTopic.length - 1;
             const isLastQuestionOverall = currentGlobalQuestionIndex >= allQuestionsFlat.length - 1;

             if (isLastQuestionInTopic) {
                 // Check if the entire analysis is now complete
                 if (analysisProgress[currentAnalysisKey]?.completed) {
                     showAnalysisCompletion(currentAnalysisKey);
                 } else {
                      // Go back to the topic checkpoint list for the current analysis
                      showTopicCheckpointSection(currentAnalysisKey);
                 }
             } else if (nextGlobalIndex < allQuestionsFlat.length) {
                 // Check if the next question belongs to the same topic
                 const nextQuestionInfo = allQuestionsFlat[nextGlobalIndex];
                 if (nextQuestionInfo.analysis === currentAnalysisKey && nextQuestionInfo.topic === currentTopicKey) {
                      displayQuestion(nextGlobalIndex); // Continue in the same topic
                 } else {
                      // This case should ideally be handled by the isLastQuestionInTopic logic above
                      // If somehow we reach here, go back to topic checkpoints as a safe fallback
                      console.warn("Reached unexpected state after last question in topic. Navigating to topic checkpoints.");
                      showTopicCheckpointSection(currentAnalysisKey);
                 }
             } else {
                 // This means it was the very last question overall.
                 // Should ideally be handled by analysis completion logic, but as a fallback:
                 showReportSection();
             }
         });

        // --- Report Actions ---
         downloadReportBtn.addEventListener('click', () => {
             const reportData = {
                 userInfo: currentUserInfo,
                 answers: answers,
                 reportDate: new Date().toISOString()
             };
             const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(reportData, null, 2));
             const downloadAnchorNode = document.createElement('a');
             downloadAnchorNode.setAttribute("href", dataStr);
             const safeCompanyName = (currentUserInfo.companyName || 'report').replace(/[^a-z0-9]/gi, '_').toLowerCase();
             downloadAnchorNode.setAttribute("download", `rjpp_report_${safeCompanyName}_${new Date().toISOString().split('T')[0]}.json`);
             document.body.appendChild(downloadAnchorNode); // required for firefox
             downloadAnchorNode.click();
             downloadAnchorNode.remove();
         });

        copyReportBtn.addEventListener('click', () => {
            let markdownReport = `# Laporan Analisis RJPP\n\n`;
            markdownReport += `## Informasi Pengguna\n`;
            markdownReport += `- Nama Perusahaan: ${currentUserInfo.companyName || 'N/A'}\n`;
            markdownReport += `- Nama Pengguna: ${currentUserInfo.userName || 'N/A'}\n`;
            markdownReport += `- Email: ${currentUserInfo.userEmail || 'N/A'}\n`;
            markdownReport += `- Tanggal Laporan: ${new Date().toLocaleDateString('id-ID', { dateStyle: 'full' })}\n\n`;

            markdownReport += `## Jawaban Analisis\n\n`;

            currentAnalysisKeys.forEach(analysisKey => {
                 const analysisHasAnswers = currentTopicKeys[analysisKey]?.some(topicKey =>
                     questionsData[analysisKey]?.[topicKey]?.some(q => answers[q.answerKey])
                 );

                 if (analysisHasAnswers) {
                     markdownReport += `### ${analysisKey}\n\n`;
                     currentTopicKeys[analysisKey].forEach(topicKey => {
                         const topicQuestions = questionsData[analysisKey]?.[topicKey] || [];
                         const topicHasAnswers = topicQuestions.some(q => answers[q.answerKey]);

                         if (topicHasAnswers) {
                             markdownReport += `#### ${topicKey}\n\n`;
                             topicQuestions.forEach(q => {
                                 const answer = answers[q.answerKey];
                                 if (answer !== undefined && answer !== null && answer !== '') {
                                     const formattedQuestion = q.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                                     markdownReport += `**${formattedQuestion}**\n\n`;
                                     markdownReport += `${answer}\n\n`; // Add two newlines for paragraph break in Markdown
                                 }
                             });
                         }
                     });
                 }
             });
             if (!markdownReport.includes('###')) {
                 markdownReport += `*Belum ada jawaban yang diberikan.*\n`;
             }

            navigator.clipboard.writeText(markdownReport)
                .then(() => alert('Laporan dalam format Markdown telah disalin ke clipboard!'))
                .catch(err => {
                    console.error('Gagal menyalin laporan:', err);
                    alert('Gagal menyalin laporan. Coba lagi atau salin manual.');
                });
        });

         // NEW: Review/Edit Answers Button Handler
         reviewAnswersBtn.addEventListener('click', () => {
             // Navigate back to the question section, starting from the first question overall
             if (allQuestionsFlat.length > 0) {
                 showQuestionSection(allQuestionsFlat[0].analysis, allQuestionsFlat[0].topic, 0);
             } else {
                 // If there are no questions (edge case), go to main checkpoints
                 showCheckpointSection();
             }
         });

        // --- Completion Animation ---
        let animationInterval;

        function triggerCompletionAnimation() {
            stopCompletionAnimation(); // Clear previous animations
            createConfetti();
            createBalloons();
            // Optional: Repeat animation for a duration
            // animationInterval = setInterval(() => {
            //     createConfetti();
            //     createBalloons();
            // }, 5000); // Repeat every 5 seconds
        }

        function stopCompletionAnimation() {
            clearInterval(animationInterval);
            completionConfettiContainer.innerHTML = ''; // Clear existing elements
            completionBalloonsContainer.innerHTML = '';
        }

        function createConfetti() {
            completionConfettiContainer.innerHTML = ''; // Clear previous
            const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                confetti.style.animationDuration = `${2 + Math.random() * 2}s`; // Vary duration
                 confetti.style.transform = `scale(${0.5 + Math.random() * 0.5})`; // Vary size
                completionConfettiContainer.appendChild(confetti);
            }
        }

        function createBalloons() {
             completionBalloonsContainer.innerHTML = ''; // Clear previous
             const colors = ['rgba(255, 87, 34, 0.7)', 'rgba(33, 150, 243, 0.7)', 'rgba(76, 175, 80, 0.7)', 'rgba(255, 235, 59, 0.7)', 'rgba(156, 39, 176, 0.7)'];
             const numBalloons = 5;
             for (let i = 0; i < numBalloons; i++) {
                 const balloon = document.createElement('div');
                 balloon.className = 'balloon';
                 balloon.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                 // Distribute balloons horizontally - adjust calculation if needed
                 balloon.style.left = `${(100 / (numBalloons + 1)) * (i + 1) - (60 / window.innerWidth * 50)}%`; // Approximate centering
                 balloon.style.animationDelay = `${Math.random() * 1.5}s`; // Stagger start times
                 balloon.style.animationDuration = `${4 + Math.random() * 3}s`; // Vary float duration
                 completionBalloonsContainer.appendChild(balloon);
             }
         }


        // --- Keyboard Shortcut ---
        document.addEventListener('keydown', function(event) {
            // Ctrl+Enter or Cmd+Enter to advance question
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                // Check if the question section is visible and the button exists/is enabled
                if (questionSection.style.display !== 'none' && nextBtnQuestion && !nextBtnQuestion.disabled) {
                    event.preventDefault(); // Prevent default behavior (like form submission)
                    nextBtnQuestion.click(); // Trigger the button click
                }
            }
        });


        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', initialize);

    </script>
</body>
</html>