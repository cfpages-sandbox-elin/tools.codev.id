<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RJPP - Rencana Jangka Panjang Perusahaan</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"> <style>
        /* General Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9; /* Slightly bluer background */
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #333; /* Slightly softer black */
            line-height: 1.6;
        }

        .container {
            width: 90%;
            max-width: 900px; /* Wider */
            background-color: white;
            padding: 35px; /* More padding */
            border-radius: 16px; /* Even more rounded */
            box-shadow: 0 6px 20px rgba(0,0,0,0.09); /* Deeper shadow */
            margin-bottom: 25px;
        }

        h1, h2, h3 {
            text-align: center;
            color: #2c3e50; /* Dark blue-gray */
            margin-bottom: 1em;
        }

        h1 {
            font-size: 2.4em;
            margin-bottom: 1.5em;
            font-weight: 600;
        }

        h2 {
            font-size: 1.9em;
            border-bottom: 2px solid #e0e6ed; /* Slightly stronger separator */
            padding-bottom: 0.6em;
            font-weight: 500;
        }

        h3 {
             font-size: 1.5em;
             color: #34495e; /* Medium blue-gray */
             font-weight: 500;
        }

        label {
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
            color: #555;
        }

        input[type="text"],
        input[type="email"],
        select, /* Added select styling */
        textarea {
            width: 100%;
            padding: 14px; /* Increased padding */
            margin-bottom: 18px; /* Increased margin */
            box-sizing: border-box;
            border-radius: 10px; /* More rounded */
            border: 1px solid #ccc; /* Lighter border */
            font-size: 1em;
            background-color: #fdfdfd;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        select {
            appearance: none; /* Remove default dropdown arrow */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007bff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); /* Custom arrow */
            background-repeat: no-repeat;
            background-position: right 14px top 50%;
            background-size: .65em auto;
            padding-right: 35px; /* Space for arrow */
        }

        input[type="text"]:focus,
        input[type="email"]:focus,
        select:focus,
        textarea:focus {
            border-color: #007bff; /* Primary blue focus */
            outline: 0;
            box-shadow: 0 0 0 0.25rem rgba(0, 123, 255, 0.2); /* Lighter blue shadow */
        }

        textarea {
            min-height: 160px; /* Taller textarea */
            resize: vertical;
        }

        button {
            padding: 14px 28px; /* Larger padding */
            cursor: pointer;
            border-radius: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            font-size: 1.05em; /* Slightly larger font */
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            margin: 8px; /* More margin */
            box-shadow: 0 2px 5px rgba(0, 123, 255, 0.2); /* Subtle shadow */
        }

        button:hover {
            background-color: #0056b3;
            box-shadow: 0 4px 8px rgba(0, 86, 179, 0.3); /* Enhanced hover shadow */
        }

        button:active {
             transform: scale(0.97); /* Slightly more pronounced click effect */
             box-shadow: 0 1px 3px rgba(0, 86, 179, 0.2);
        }

        button:disabled {
            background-color: #adb5bd; /* Lighter gray disabled */
            cursor: not-allowed;
            box-shadow: none;
        }

        button.secondary {
             background-color: #6c757d;
             box-shadow: 0 2px 5px rgba(108, 117, 125, 0.2);
        }
         button.secondary:hover {
             background-color: #5a6268;
             box-shadow: 0 4px 8px rgba(90, 98, 104, 0.3);
         }
         button.secondary:active {
             transform: scale(0.97);
             box-shadow: 0 1px 3px rgba(90, 98, 104, 0.2);
         }
         button.yes {
             background-color: #28a745; /* Green for Yes */
             box-shadow: 0 2px 5px rgba(40, 167, 69, 0.2);
         }
         button.yes:hover {
             background-color: #218838;
             box-shadow: 0 4px 8px rgba(33, 136, 56, 0.3);
         }
         button.no {
             background-color: #dc3545; /* Red for No */
             box-shadow: 0 2px 5px rgba(220, 53, 69, 0.2);
         }
         button.no:hover {
             background-color: #c82333;
             box-shadow: 0 4px 8px rgba(200, 35, 51, 0.3);
         }


        /* Section Visibility */
        #user-info-form-section,
        #checkpoint-section,
        #topic-checkpoint-section,
        #topic-greeting-section,
        #question-section,
        #analysis-completion-section,
        #report-section {
            display: none; /* Hide all sections initially */
            width: 100%; /* Ensure sections take full width of container */
        }

        /* Checkpoint Styling */
        .checkpoint-grid, .topic-checkpoint-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Larger min size */
            gap: 25px; /* Increased gap */
            margin-top: 25px;
        }

        .checkpoint-card, .topic-checkpoint-card {
            background-color: #f8f9fa;
            padding: 25px; /* Increased padding */
            border-radius: 12px; /* More rounded */
            border: 1px solid #dee2e6;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative; /* For status icon */
            overflow: hidden; /* Hide overflowing elements */
        }
         .checkpoint-card::before, .topic-checkpoint-card::before { /* Subtle gradient background */
             content: '';
             position: absolute;
             top: 0; left: 0;
             width: 100%; height: 5px;
             background: linear-gradient(90deg, #007bff, #0056b3);
             opacity: 0.7;
         }

        .checkpoint-card:hover, .topic-checkpoint-card:hover {
            transform: translateY(-6px); /* More lift */
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
        }

        .checkpoint-card h3, .topic-checkpoint-card h3 {
            margin-top: 15px; /* Space below gradient */
            margin-bottom: 12px;
            font-size: 1.3em; /* Larger heading */
            color: #343a40;
        }

        .checkpoint-status, .topic-checkpoint-status {
            font-size: 0.95em; /* Slightly larger */
            color: #6c757d;
            margin-bottom: 18px;
            font-weight: 500;
        }

         .checkpoint-status.done, .topic-checkpoint-status.done {
             color: #28a745; /* Green for done */
             font-weight: 600; /* Bolder */
         }
         .checkpoint-status.done::before, .topic-checkpoint-status.done::before {
             content: "\f058"; /* Font Awesome check circle */
             font-family: "Font Awesome 6 Free";
             font-weight: 900;
             margin-right: 8px;
             color: #28a745;
         }
         .checkpoint-status:not(.done)::before {
              content: "\f110"; /* Font Awesome spinner/progress */
              font-family: "Font Awesome 6 Free";
              font-weight: 900;
              margin-right: 8px;
              color: #ffc107; /* Amber color for in progress */
         }


        .checkpoint-card button, .topic-checkpoint-card button {
            margin-top: auto;
            width: 100%;
            padding: 12px 18px; /* Adjusted padding */
            font-size: 1em;
        }
        .checkpoint-card button.done-button, .topic-checkpoint-card button.done-button {
             background-color: #17a2b8; /* Info blue for 'View/Review' */
             box-shadow: 0 2px 5px rgba(23, 162, 184, 0.2);
        }
         .checkpoint-card button.done-button:hover, .topic-checkpoint-card button.done-button:hover {
              background-color: #138496;
              box-shadow: 0 4px 8px rgba(19, 132, 150, 0.3);
         }

        /* Question Card Styling */
        #question-card {
            background-color: #ffffff;
            padding: 35px;
            border-radius: 16px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.09);
            margin-bottom: 25px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
            transform: translateY(0);
            border: 1px solid #e0e6ed;
        }

        .card-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 18px;
            border-bottom: 1px solid #eee;
        }

        .card-analysis, .card-topic {
            font-size: 1.05em;
            color: #6c757d;
            margin-bottom: 6px;
        }
         .card-analysis { font-weight: 600; }

        .card-question {
            font-weight: 500;
            margin-bottom: 25px;
            text-align: left;
            font-size: 1.2em; /* Larger */
            line-height: 1.6;
            color: #333;
        }

        /* Yes/No Button Styling */
        .yes-no-buttons {
            display: flex;
            justify-content: center;
            gap: 20px; /* More gap */
            margin-bottom: 25px;
        }
        .yes-no-buttons button {
            padding: 12px 35px; /* Wider buttons */
            font-size: 1.1em;
        }
        .yes-no-buttons button.selected {
             transform: scale(1.05);
             box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5), 0 4px 10px rgba(0,0,0,0.2); /* Highlight selected */
        }

        /* Follow-up Question Styling */
        .follow-up-question {
            margin-top: 20px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px dashed #ced4da;
            display: none; /* Hidden by default */
        }
        .follow-up-question label {
            font-weight: 500;
            color: #495057;
        }
        .follow-up-question textarea {
            margin-top: 10px;
            min-height: 100px; /* Smaller textarea for follow-up */
        }


        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
            align-items: center;
        }

        .progress-container {
            margin-bottom: 30px;
            text-align: center;
        }

        .progress-bar-info {
            font-size: 1em;
            color: #495057;
            margin-bottom: 10px;
        }

        .progress-bar-wrapper {
             width: 100%;
             background-color: #e9ecef;
             border-radius: 50px;
             height: 14px; /* Thicker */
             overflow: hidden;
             position: relative;
             box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #007bff, #0056b3); /* Gradient fill */
            border-radius: 50px;
            transition: width 0.4s ease-in-out;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
        }

        #progress-segments {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             display: flex;
             z-index: 2;
         }

         .progress-segment {
             flex-grow: 1;
             border-right: 1px solid rgba(255, 255, 255, 0.6); /* Brighter separator */
         }
         .progress-segment:last-child {
             border-right: none;
         }

        /* Greeting Card Styling */
        .greeting-card {
            text-align: center;
            padding: 50px 25px; /* More padding */
            background-color: #e9f7ff;
            border-radius: 16px;
            border: 1px solid #bce0ff;
            margin-bottom: 35px;
        }
        .greeting-card h2 {
            color: #0056b3;
            border-bottom: none;
            font-size: 1.8em;
        }
        .greeting-card p {
            color: #004085;
            font-size: 1.15em;
            margin-bottom: 30px;
        }
        .greeting-buttons {
             display: flex;
             justify-content: center;
             gap: 20px;
             flex-wrap: wrap;
        }

        /* Report Section Styling */
        #report-section {
            background-color: #fff;
            padding: 35px;
            border-radius: 16px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.09);
            border: 1px solid #e0e6ed;
        }
        #report-user-info {
            margin-bottom: 30px;
            padding-bottom: 25px;
            border-bottom: 1px dashed #ced4da;
        }
         #report-user-info h3 { text-align: left; font-size: 1.4em; color: #007bff; margin-bottom: 15px;}
         #report-user-info p { margin: 8px 0; font-size: 1.05em;}
         #report-user-info strong { color: #343a40; min-width: 150px; display: inline-block;} /* Align labels */

        #report-answers h3 { /* Analysis Title */
            font-size: 1.5em;
            color: #2c3e50; /* Dark blue-gray */
            margin-top: 30px;
            margin-bottom: 18px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e6ed;
            text-align: left;
        }
         #report-answers h4 { /* Topic Title */
             font-size: 1.25em;
             color: #34495e; /* Medium blue-gray */
             margin-top: 20px;
             margin-bottom: 12px;
             text-align: left;
             padding-left: 10px;
         }
         #report-answers div.qa-block { /* Container for each Q&A */
             margin-bottom: 18px;
             padding-left: 15px;
             border-left: 4px solid #e9ecef;
             background-color: #fdfdfd; /* Slight background tint */
             padding: 15px;
             border-radius: 8px;
         }
         #report-answers p { margin: 6px 0; }
         #report-answers p strong { /* Question text */
             display: block;
             color: #333;
             margin-bottom: 5px;
             font-weight: 600;
         }
         #report-answers p span.answer-text { /* Answer text */
             color: #555;
             white-space: pre-wrap;
             display: block;
             padding-left: 10px;
             font-size: 0.95em;
         }
         #report-answers p span.yes-no-answer { /* Yes/No Answer */
             font-weight: bold;
             color: #28a745; /* Default green for Yes */
             display: inline-block;
             margin-left: 5px;
             padding: 2px 8px;
             border-radius: 4px;
             background-color: #e9f7ef;
         }
         #report-answers p span.yes-no-answer.no {
             color: #dc3545; /* Red for No */
             background-color: #fbe9eb;
         }
         #report-answers div.follow-up-answer { /* Follow-up answer block */
             margin-top: 8px;
             padding-left: 20px;
             border-left: 2px dotted #ccc;
         }
         #report-answers div.follow-up-answer strong { /* Follow-up question text */
              font-weight: 500;
              font-size: 0.9em;
              color: #666;
         }


        .report-actions {
            text-align: center;
            margin-top: 35px;
            padding-top: 25px;
            border-top: 1px dashed #ced4da;
        }
        .report-actions button i { margin-right: 8px; } /* Icon spacing */

        /* Loading/Error Styling */
        #loading-indicator {
            text-align: center;
            padding: 50px;
            font-size: 1.3em;
            color: #6c757d;
        }
        #loading-indicator i {
            margin-right: 10px;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

         #error-message {
             text-align: center;
             padding: 35px;
             background-color: #f8d7da;
             color: #721c24;
             border: 1px solid #f5c6cb;
             border-radius: 12px;
             margin: 25px auto;
             width: 85%;
             max-width: 650px;
             display: none;
             font-size: 1.1em;
         }
         #error-message i { margin-right: 10px; }

        /* Confetti and Balloon Styles (Keep existing or refine) */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 1000;
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.9; /* Brighter */
            border-radius: 50%;
            animation: confetti-fall 4s linear infinite; /* Slower fall */
        }
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotateZ(0deg); opacity: 0.9; }
            100% { transform: translateY(110vh) rotateZ(1080deg); opacity: 0; } /* More rotation */
        }
        .balloon-container {
            position: fixed;
            bottom: -15%; /* Start lower */
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            display: flex;
            justify-content: space-around;
        }
        .balloon {
            width: 70px; /* Larger */
            height: 90px;
            background-color: rgba(255, 0, 0, 0.8); /* Brighter */
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            position: relative;
            opacity: 0;
            animation: balloon-float 6s ease-in infinite, balloon-sway 3.5s ease-in-out infinite alternate; /* Slower */
        }
        .balloon::after {
            content: '';
            position: absolute;
            bottom: -15px; /* Longer string */
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 40px;
            background-color: #777;
        }
        @keyframes balloon-float {
            0% { transform: translateY(0); opacity: 0.8; }
            100% { transform: translateY(-120vh); opacity: 0; } /* Float higher */
        }
        @keyframes balloon-sway {
             0% { transform: translateX(-15px) rotateZ(-6deg); } /* More sway */
             100% { transform: translateX(15px) rotateZ(6deg); }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1><i class="fas fa-chart-line"></i> RJPP - Analisis Perusahaan</h1>

        <div id="loading-indicator"><i class="fas fa-spinner"></i> Loading questions...</div>
        <div id="error-message"><i class="fas fa-exclamation-triangle"></i> <span>Error message here</span></div>

        <div id="user-info-form-section">
            <h2><i class="fas fa-user-edit"></i> Informasi Dasar</h2>
            <form id="user-info-form">
                <label for="companyName">Nama Perusahaan:</label>
                <input type="text" id="companyName" name="companyName" required placeholder="Contoh: PT Maju Jaya">

                <label for="industry">Industri:</label>
                <select id="industry" name="industry">
                    <option value="">-- Pilih Industri --</option>
                    <option value="Teknologi">Teknologi</option>
                    <option value="Keuangan">Keuangan</option>
                    <option value="Manufaktur">Manufaktur</option>
                    <option value="Ritel">Ritel</option>
                    <option value="Kesehatan">Kesehatan</option>
                    <option value="Pendidikan">Pendidikan</option>
                    <option value="Energi">Energi</option>
                    <option value="Transportasi">Transportasi</option>
                    <option value="Konstruksi">Konstruksi</option>
                    <option value="Pariwisata">Pariwisata & Perhotelan</option>
                    <option value="Lainnya">Lainnya</option>
                </select>

                <label for="companySize">Ukuran Perusahaan:</label>
                 <select id="companySize" name="companySize">
                    <option value="">-- Pilih Ukuran --</option>
                    <option value="Mikro (1-5 karyawan)">Mikro (1-5 karyawan)</option>
                    <option value="Kecil (6-19 karyawan)">Kecil (6-19 karyawan)</option>
                    <option value="Menengah (20-99 karyawan)">Menengah (20-99 karyawan)</option>
                    <option value="Besar (100+ karyawan)">Besar (100+ karyawan)</option>
                </select>

                <label for="userName">Nama Anda:</label>
                <input type="text" id="userName" name="userName" required placeholder="Nama lengkap Anda">

                <label for="userEmail">Email Anda:</label>
                <input type="email" id="userEmail" name="userEmail" required placeholder="email@example.com">

                <center><button type="submit"><i class="fas fa-play"></i> Mulai Analisis</button></center>
            </form>
        </div>

        <div id="checkpoint-section">
            <h2><i class="fas fa-tasks"></i> Pilih Analisis Utama</h2>
            <p style="text-align: center; color: #6c757d;">Pilih salah satu analisis untuk memulai atau melanjutkan.</p>
            <div id="checkpoint-grid" class="checkpoint-grid">
                </div>
        </div>

        <div id="topic-checkpoint-section">
            <h2 id="topic-checkpoint-analysis-name"><i class="fas fa-stream"></i> Topik dalam Analisis X</h2>
             <p style="text-align: center; color: #6c757d;">Pilih topik yang ingin Anda kerjakan dalam analisis ini.</p>
            <div id="topic-checkpoint-grid" class="topic-checkpoint-grid">
                </div>
            <center style="margin-top: 30px;">
                <button id="go-to-main-checkpoint-btn" class="secondary"><i class="fas fa-arrow-left"></i> Kembali ke Daftar Analisis</button>
            </center>
        </div>

        <div id="topic-greeting-section">
            <div id="topic-greeting-card" class="greeting-card">
                <h2 id="topic-greeting-title"><i class="fas fa-book-open"></i> Memulai Topik: Y</h2>
                <p id="topic-greeting-description">Anda akan memulai pertanyaan untuk topik ini.</p>
                <div class="greeting-buttons">
                    <button id="go-to-topic-checkpoint-btn" class="secondary"><i class="fas fa-arrow-left"></i> Kembali ke Daftar Topik</button>
                    <button id="start-topic-btn"><i class="fas fa-pencil-alt"></i> Mulai Pertanyaan</button>
                    <button id="next-topic-btn" style="display: none;">Lanjut ke Topik Berikutnya <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>
             <center style="margin-top: 30px;">
                 <button id="go-to-main-checkpoint-btn-from-greeting" class="secondary"><i class="fas fa-list-ul"></i> Kembali ke Daftar Analisis Utama</button>
             </center>
        </div>

        <div id="question-section">
            <div class="progress-container">
                <div id="question-number" class="progress-bar-info">Pertanyaan X dari Y</div>
                <div class="progress-bar-wrapper">
                     <div id="progress-segments"></div>
                     <div id="progress-fill"></div>
                </div>
            </div>

            <div id="question-card" class="card">
                <div class="card-header">
                    <div id="card-analysis-title" class="card-analysis">Analisis: ...</div>
                    <div id="card-topic-title" class="card-topic">Topik: ...</div>
                </div>
                <div id="card-question-text" class="card-question">Teks pertanyaan akan muncul di sini...</div>

                <div id="answer-input-container">
                    </div>

                 <div id="follow-up-container" class="follow-up-question">
                     <label id="follow-up-label" for="follow-up-textarea">Pertanyaan Lanjutan:</label>
                     <div id="follow-up-question-text" style="font-weight: bold; margin-bottom: 10px;"></div>
                     <textarea id="follow-up-textarea" placeholder="Ketik jawaban untuk pertanyaan lanjutan..."></textarea>
                 </div>

            </div>
            <div class="navigation-buttons">
                <button id="prev-btn" class="secondary"><i class="fas fa-arrow-left"></i> Kembali</button>
                <button id="next-btn-question">Lanjut <i class="fas fa-arrow-right"></i></button>
            </div>
             <center style="margin-top: 20px;">
                <button id="back-to-topic-checkpoint-btn" class="secondary"><i class="fas fa-th-list"></i> Kembali ke Daftar Topik</button>
             </center>
        </div>

         <div id="analysis-completion-section">
              <div id="analysis-completion-card" class="greeting-card" style="background-color: #e2f0d9; border-color: #c3e6cb;">
                  <h2 style="color: #155724;">ðŸŽ‰ Analisis Selesai! ðŸŽ‰</h2>
                  <p style="color: #155724;" id="analysis-completion-text">Selamat! Anda telah menyelesaikan semua pertanyaan untuk analisis '[Analysis Name]'.</p>
                  <div class="greeting-buttons">
                      <button id="go-to-main-checkpoint-btn-from-completion" class="secondary"><i class="fas fa-list-ul"></i> Kembali ke Daftar Analisis</button>
                      <button id="view-full-report-btn"><i class="fas fa-file-alt"></i> Lihat Laporan Lengkap</button>
                  </div>
              </div>
              <div class="confetti-container" id="completion-confetti"></div>
              <div class="balloon-container" id="completion-balloons"></div>
         </div>

        <div id="report-section">
            <h2><i class="fas fa-file-invoice"></i> Laporan Hasil Analisis RJPP</h2>

            <div id="report-user-info">
                </div>

            <div id="report-answers">
                </div>

            <div class="report-actions">
                 <button id="back-to-main-checkpoint-btn" class="secondary"><i class="fas fa-list-ul"></i> Kembali ke Daftar Analisis</button>
                 <button id="review-answers-btn"><i class="fas fa-edit"></i> Tinjau/Edit Jawaban</button>
                 <button id="download-report-btn"><i class="fas fa-download"></i> Unduh Laporan (JSON)</button>
                 <button id="copy-report-btn"><i class="fas fa-copy"></i> Salin Laporan (Markdown)</button>
            </div>
        </div>

    </div><script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessageDiv = document.getElementById('error-message');
        const errorTextSpan = errorMessageDiv.querySelector('span'); // Get span inside error div

        const userInfoFormSection = document.getElementById('user-info-form-section');
        const userInfoForm = document.getElementById('user-info-form');
        const companyNameInput = document.getElementById('companyName');
        const industrySelect = document.getElementById('industry'); // New
        const companySizeSelect = document.getElementById('companySize'); // New
        const userNameInput = document.getElementById('userName');
        const userEmailInput = document.getElementById('userEmail');

        const checkpointSection = document.getElementById('checkpoint-section');
        const checkpointGrid = document.getElementById('checkpoint-grid');

        const topicCheckpointSection = document.getElementById('topic-checkpoint-section');
        const topicCheckpointAnalysisNameDisplay = document.getElementById('topic-checkpoint-analysis-name');
        const topicCheckpointGrid = document.getElementById('topic-checkpoint-grid');
        const goToMainCheckpointBtn_TopicCheckpoint = document.getElementById('go-to-main-checkpoint-btn');

        const topicGreetingSection = document.getElementById('topic-greeting-section');
        const topicGreetingCard = document.getElementById('topic-greeting-card');
        const topicGreetingTitle = document.getElementById('topic-greeting-title');
        const topicGreetingDescription = document.getElementById('topic-greeting-description');
        const goToTopicCheckpointBtn_Greeting = document.getElementById('go-to-topic-checkpoint-btn');
        const startTopicBtn = document.getElementById('start-topic-btn');
        const nextTopicBtn = document.getElementById('next-topic-btn');
        const goToMainCheckpointBtn_Greeting = document.getElementById('go-to-main-checkpoint-btn-from-greeting');

        const questionSection = document.getElementById('question-section');
        const questionCard = document.getElementById('question-card');
        const cardAnalysisTitle = document.getElementById('card-analysis-title');
        const cardTopicTitle = document.getElementById('card-topic-title');
        const cardQuestionText = document.getElementById('card-question-text');
        const answerInputContainer = document.getElementById('answer-input-container'); // Container for inputs
        const followUpContainer = document.getElementById('follow-up-container');
        const followUpLabel = document.getElementById('follow-up-label');
        const followUpQuestionText = document.getElementById('follow-up-question-text');
        const followUpTextarea = document.getElementById('follow-up-textarea');
        // Note: answerTextarea is now dynamically created

        const prevBtn = document.getElementById('prev-btn');
        const nextBtnQuestion = document.getElementById('next-btn-question');
        const questionNumberDisplay = document.getElementById('question-number');
        const progressBarFill = document.getElementById('progress-fill');
        const progressBarSegments = document.getElementById('progress-segments');
        const backToTopicCheckpointBtn = document.getElementById('back-to-topic-checkpoint-btn');

        const analysisCompletionSection = document.getElementById('analysis-completion-section');
        const analysisCompletionText = document.getElementById('analysis-completion-text');
        const goToMainCheckpointBtn_Completion = document.getElementById('go-to-main-checkpoint-btn-from-completion');
        const viewFullReportBtn = document.getElementById('view-full-report-btn');
        const completionConfettiContainer = document.getElementById('completion-confetti');
        const completionBalloonsContainer = document.getElementById('completion-balloons');

        const reportSection = document.getElementById('report-section');
        const reportUserInfoDiv = document.getElementById('report-user-info');
        const reportAnswersDiv = document.getElementById('report-answers');
        const backToMainCheckpointBtn_Report = document.getElementById('back-to-main-checkpoint-btn');
        const reviewAnswersBtn = document.getElementById('review-answers-btn');
        const downloadReportBtn = document.getElementById('download-report-btn');
        const copyReportBtn = document.getElementById('copy-report-btn');


        // --- State Variables ---
        let questionsData = {}; // { analysis: { topic: [ { question, answerKey, type, followUp: { yes: { question, answerKey }, no: { question, answerKey } } } ] } }
        let currentAnalysisKeys = [];
        let currentTopicKeys = {};
        let allQuestionsFlat = []; // Flat array: { analysis, topic, question, answerKey, type, followUp, indexInTopic, globalIndex, isFollowUpFor? }

        let currentUserInfo = { companyName: '', industry: '', companySize: '', userName: '', userEmail: '' }; // Added industry, companySize
        let answers = {}; // Stores answers: { answerKey: value (string, 'yes', 'no') }
        let analysisProgress = {};
        let topicProgress = {};

        let currentAnalysisKey = null;
        let currentTopicKey = null;
        let currentQuestionIndexInTopic = 0;
        let currentGlobalQuestionIndex = 0;
        let currentYesNoSelection = null; // Tracks 'yes' or 'no' selection for current yes/no question


        // --- Constants ---
        const QUESTIONS_MD_URL = 'rjpp-questions.md';
        const LOCAL_STORAGE_KEY_INFO = 'rjppUserInfo_v2'; // Version bump for new fields
        const LOCAL_STORAGE_KEY_ANSWERS = 'rjppAnswers_v2'; // Version bump for new structure potentially

        // --- Initialization ---
        async function initialize() {
            showLoading();
            try {
                await loadQuestionsFromMarkdown();
                loadState();
                calculateInitialProgress();
                if (currentUserInfo.companyName && currentUserInfo.userName && currentUserInfo.userEmail) { // Check essential fields
                    showCheckpointSection();
                } else {
                    showUserInfoForm();
                }
            } catch (error) {
                console.error("Initialization failed:", error);
                showError(`Failed to load questions: ${error.message}. Please ensure '${QUESTIONS_MD_URL}' exists and is accessible.`);
            } finally {
                hideLoading();
            }
        }

        // --- Data Loading and Parsing ---
        async function loadQuestionsFromMarkdown() {
            console.log(`Fetching questions from ${QUESTIONS_MD_URL}...`);
            const response = await fetch(QUESTIONS_MD_URL);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const markdown = await response.text();
            console.log("Markdown fetched successfully.");
            parseMarkdownToQuestions(markdown);
            console.log("Questions parsed:", questionsData);
            prepareFlatQuestionsList();
            console.log("Flat questions list created:", allQuestionsFlat.length, "questions total.");
        }

        function parseMarkdownToQuestions(markdown) {
             questionsData = {};
             currentAnalysisKeys = [];
             currentTopicKeys = {};
             let currentAnalysis = null;
             let currentTopic = null;
             let currentMainQuestion = null; // To link follow-ups

             const lines = markdown.split('\n');
             const keyRegex = /\{answerKey:\s*([^}]+)\}/;
             const yesNoMarker = '? [y/n]';
             const followUpMarker = '-> ';

             lines.forEach(line => {
                 line = line.trim();
                 if (line.startsWith('## ')) {
                     // New Analysis
                     currentAnalysis = line.substring(3).trim();
                     questionsData[currentAnalysis] = {};
                     currentAnalysisKeys.push(currentAnalysis);
                     currentTopicKeys[currentAnalysis] = [];
                     currentTopic = null;
                     currentMainQuestion = null;
                 } else if (line.startsWith('### ') && currentAnalysis) {
                     // New Topic
                     currentTopic = line.substring(4).trim();
                     questionsData[currentAnalysis][currentTopic] = [];
                     currentTopicKeys[currentAnalysis].push(currentTopic);
                     currentMainQuestion = null;
                 } else if (line.startsWith('- ') && currentAnalysis && currentTopic) {
                     // New Main Question
                     const match = line.match(keyRegex);
                     let questionText = line.substring(2).trim();
                     let answerKey = null;
                     let questionType = 'text'; // Default type

                     if (questionText.endsWith(yesNoMarker)) {
                         questionType = 'yesno';
                         questionText = questionText.substring(0, questionText.length - yesNoMarker.length).trim();
                     }

                     if (match && match[1]) {
                         answerKey = match[1].trim();
                         questionText = questionText.replace(keyRegex, '').trim();
                     } else {
                          console.warn(`Missing answerKey for question: ${questionText} in ${currentAnalysis} > ${currentTopic}`);
                          answerKey = `fallback_${currentAnalysis.replace(/\s+/g, '_')}_${currentTopic.replace(/\s+/g, '_')}_${questionsData[currentAnalysis][currentTopic].length}`;
                     }

                     currentMainQuestion = {
                         question: questionText,
                         answerKey: answerKey,
                         type: questionType,
                         followUp: {} // Initialize followUp object
                     };
                     questionsData[currentAnalysis][currentTopic].push(currentMainQuestion);

                 } else if (line.startsWith(followUpMarker) && currentMainQuestion) {
                     // Follow-up Question
                     const followUpLine = line.substring(followUpMarker.length).trim();
                     const triggerMatch = followUpLine.match(/^(yes|no):\s*/); // Check for 'yes:' or 'no:'

                     if (triggerMatch) {
                         const trigger = triggerMatch[1]; // 'yes' or 'no'
                         let followUpText = followUpLine.substring(triggerMatch[0].length).trim();
                         const followUpKeyMatch = followUpText.match(keyRegex);
                         let followUpKey = null;

                         if (followUpKeyMatch && followUpKeyMatch[1]) {
                             followUpKey = followUpKeyMatch[1].trim();
                             followUpText = followUpText.replace(keyRegex, '').trim();
                         } else {
                             console.warn(`Missing answerKey for follow-up question: ${followUpText} under ${currentMainQuestion.answerKey}`);
                             followUpKey = `${currentMainQuestion.answerKey}_followup_${trigger}`;
                         }

                         // Add follow-up to the current main question
                         currentMainQuestion.followUp[trigger] = {
                             question: followUpText,
                             answerKey: followUpKey
                         };
                         // console.log(`    Added Follow-up (${trigger}): ${followUpText.substring(0,30)}... {${followUpKey}}`);
                     }
                 }
             });
         }


         function prepareFlatQuestionsList() {
             allQuestionsFlat = [];
             let globalIndex = 0;

             currentAnalysisKeys.forEach(analysisKey => {
                 if (currentTopicKeys[analysisKey]) {
                     currentTopicKeys[analysisKey].forEach(topicKey => {
                         if (questionsData[analysisKey] && questionsData[analysisKey][topicKey]) {
                             questionsData[analysisKey][topicKey].forEach((q, indexInTopic) => {
                                 // Add the main question
                                 allQuestionsFlat.push({
                                     analysis: analysisKey,
                                     topic: topicKey,
                                     question: q.question,
                                     answerKey: q.answerKey,
                                     type: q.type,
                                     followUp: q.followUp, // Include follow-up structure
                                     indexInTopic: indexInTopic,
                                     globalIndex: globalIndex++,
                                     isFollowUp: false // Mark as main question
                                 });

                                 // Add follow-up questions to the flat list *if* they exist
                                 // We might not actually navigate *directly* to these via index,
                                 // but having them here helps with overall progress calculation.
                                 if (q.type === 'yesno') {
                                     if (q.followUp.yes) {
                                         allQuestionsFlat.push({
                                             analysis: analysisKey,
                                             topic: topicKey,
                                             question: q.followUp.yes.question,
                                             answerKey: q.followUp.yes.answerKey,
                                             type: 'text', // Follow-ups are text input
                                             followUp: {},
                                             indexInTopic: indexInTopic, // Belongs to same topic index
                                             globalIndex: globalIndex++, // Consumes a global index slot
                                             isFollowUp: true,
                                             parentKey: q.answerKey,
                                             trigger: 'yes'
                                         });
                                     }
                                     if (q.followUp.no) {
                                         allQuestionsFlat.push({
                                             analysis: analysisKey,
                                             topic: topicKey,
                                             question: q.followUp.no.question,
                                             answerKey: q.followUp.no.answerKey,
                                             type: 'text',
                                             followUp: {},
                                             indexInTopic: indexInTopic,
                                             globalIndex: globalIndex++,
                                             isFollowUp: true,
                                             parentKey: q.answerKey,
                                             trigger: 'no'
                                         });
                                     }
                                 }
                             });
                         }
                     });
                 }
             });
             // Recalculate global indices after adding all questions
             allQuestionsFlat.forEach((q, index) => q.globalIndex = index);
         }


        // --- State Management (Save/Load) ---
        function saveState() {
            localStorage.setItem(LOCAL_STORAGE_KEY_INFO, JSON.stringify(currentUserInfo));
            localStorage.setItem(LOCAL_STORAGE_KEY_ANSWERS, JSON.stringify(answers));
            console.log("State saved to localStorage.");
            console.log("Current Answers:", JSON.parse(JSON.stringify(answers))); // Log saved answers (deep copy)
        }

        function loadState() {
            const savedInfo = localStorage.getItem(LOCAL_STORAGE_KEY_INFO);
            const savedAnswers = localStorage.getItem(LOCAL_STORAGE_KEY_ANSWERS);

            if (savedInfo) {
                currentUserInfo = JSON.parse(savedInfo);
                companyNameInput.value = currentUserInfo.companyName || '';
                industrySelect.value = currentUserInfo.industry || ''; // Load industry
                companySizeSelect.value = currentUserInfo.companySize || ''; // Load company size
                userNameInput.value = currentUserInfo.userName || '';
                userEmailInput.value = currentUserInfo.userEmail || '';
                console.log("User info loaded:", currentUserInfo);
            }
            if (savedAnswers) {
                answers = JSON.parse(savedAnswers);
                console.log("Answers loaded:", Object.keys(answers).length, "answers found.");
            }
        }

        // --- Progress Calculation ---
         function calculateInitialProgress() {
             analysisProgress = {};
             topicProgress = {};
             const allAnswerKeys = new Set(allQuestionsFlat.map(q => q.answerKey)); // Get all possible answer keys

             currentAnalysisKeys.forEach(analysisKey => {
                 let analysisTotal = 0;
                 let analysisAnswered = 0;
                 topicProgress[analysisKey] = {};

                 if (currentTopicKeys[analysisKey]) {
                     currentTopicKeys[analysisKey].forEach(topicKey => {
                         const questionsInTopic = allQuestionsFlat.filter(q => q.analysis === analysisKey && q.topic === topicKey);
                         const topicTotal = questionsInTopic.length; // Count all potential questions (main + followups)
                         let topicAnswered = 0;

                         questionsInTopic.forEach(q => {
                             if (answers[q.answerKey] !== undefined && answers[q.answerKey] !== null && answers[q.answerKey] !== '') {
                                 topicAnswered++;
                             }
                         });

                         topicProgress[analysisKey][topicKey] = {
                             total: topicTotal,
                             answered: topicAnswered,
                             // Completion requires answering the main question AND any triggered follow-up
                             completed: areAllTopicQuestionsAnswered(analysisKey, topicKey)
                         };

                         analysisTotal += topicTotal;
                         analysisAnswered += topicAnswered;
                     });
                 }

                 analysisProgress[analysisKey] = {
                     total: analysisTotal,
                     answered: analysisAnswered,
                     completed: analysisTotal > 0 && areAllAnalysisQuestionsAnswered(analysisKey)
                 };
             });
             console.log("Initial progress calculated:", { analysisProgress, topicProgress });
         }

         // Helper to check if a topic is truly complete (handles conditional follow-ups)
         function areAllTopicQuestionsAnswered(analysisKey, topicKey) {
             const mainQuestionsInTopic = questionsData[analysisKey]?.[topicKey] || [];
             if (mainQuestionsInTopic.length === 0) return true; // Empty topic is complete

             return mainQuestionsInTopic.every(q => {
                 const mainAnswer = answers[q.answerKey];
                 if (mainAnswer === undefined || mainAnswer === null || mainAnswer === '') return false; // Main question must be answered

                 if (q.type === 'yesno') {
                     const followUpTrigger = mainAnswer; // 'yes' or 'no'
                     const followUpInfo = q.followUp[followUpTrigger];
                     if (followUpInfo) {
                         // If there's a follow-up for this answer, it must also be answered
                         const followUpAnswer = answers[followUpInfo.answerKey];
                         return followUpAnswer !== undefined && followUpAnswer !== null && followUpAnswer !== '';
                     }
                 }
                 return true; // Text question or yes/no without follow-up for the given answer
             });
         }

         // Helper to check if an analysis is truly complete
         function areAllAnalysisQuestionsAnswered(analysisKey) {
             const topics = currentTopicKeys[analysisKey] || [];
             if (topics.length === 0) return true;
             return topics.every(topicKey => areAllTopicQuestionsAnswered(analysisKey, topicKey));
         }


         // Update progress, considering the complexity of yes/no follow-ups
         function updateProgress(answeredKey) {
             const questionInfo = allQuestionsFlat.find(q => q.answerKey === answeredKey);
             if (!questionInfo) return;

             const analysisKey = questionInfo.analysis;
             const topicKey = questionInfo.topic;

             // Recalculate counts for the specific topic
             const questionsInTopic = allQuestionsFlat.filter(q => q.analysis === analysisKey && q.topic === topicKey);
             let topicAnsweredCount = 0;
             questionsInTopic.forEach(q => {
                 if (answers[q.answerKey] !== undefined && answers[q.answerKey] !== null && answers[q.answerKey] !== '') {
                     topicAnsweredCount++;
                 }
             });

             if (!topicProgress[analysisKey]) topicProgress[analysisKey] = {};
             topicProgress[analysisKey][topicKey] = {
                 total: questionsInTopic.length,
                 answered: topicAnsweredCount,
                 completed: areAllTopicQuestionsAnswered(analysisKey, topicKey)
             };

             // Recalculate counts for the analysis
             let analysisAnsweredCount = 0;
             let analysisTotalCount = 0;
             if (currentTopicKeys[analysisKey]) {
                 currentTopicKeys[analysisKey].forEach(tk => {
                     const topicProg = topicProgress[analysisKey]?.[tk];
                     if (topicProg) {
                         analysisAnsweredCount += topicProg.answered;
                         analysisTotalCount += topicProg.total;
                     }
                 });
             }

             if (!analysisProgress[analysisKey]) analysisProgress[analysisKey] = {};
             analysisProgress[analysisKey] = {
                 total: analysisTotalCount,
                 answered: analysisAnsweredCount,
                 completed: analysisTotalCount > 0 && areAllAnalysisQuestionsAnswered(analysisKey)
             };

             console.log(`Progress updated after answering ${answeredKey}:`, {
                 topicProgress: topicProgress[analysisKey][topicKey],
                 analysisProgress: analysisProgress[analysisKey]
             });

             // Re-render relevant checkpoint sections if they are visible
             if (checkpointSection.style.display !== 'none') {
                 renderAnalysisCheckpoints();
             }
             if (topicCheckpointSection.style.display !== 'none' && currentAnalysisKey === analysisKey) {
                 renderTopicCheckpoints(analysisKey);
             }
         }


        // --- UI Rendering ---
        function showLoading() {
            hideAllSections();
            loadingIndicator.style.display = 'block';
            errorMessageDiv.style.display = 'none';
        }

        function hideLoading() {
            loadingIndicator.style.display = 'none';
        }

         function showError(message) {
             hideAllSections();
             errorTextSpan.textContent = message; // Set text in the span
             errorMessageDiv.style.display = 'block';
         }

        function hideAllSections() {
            // ... (keep existing code to hide all sections)
             userInfoFormSection.style.display = 'none';
             checkpointSection.style.display = 'none';
             topicCheckpointSection.style.display = 'none';
             topicGreetingSection.style.display = 'none';
             questionSection.style.display = 'none';
             analysisCompletionSection.style.display = 'none';
             reportSection.style.display = 'none';
             loadingIndicator.style.display = 'none';
             errorMessageDiv.style.display = 'none';
             stopCompletionAnimation(); // Stop animations when changing sections
        }

        function showUserInfoForm() {
            hideAllSections();
            userInfoFormSection.style.display = 'block';
        }

        function showCheckpointSection() {
            hideAllSections();
            renderAnalysisCheckpoints();
            checkpointSection.style.display = 'block';
            currentAnalysisKey = null;
            currentTopicKey = null;
        }

        function renderAnalysisCheckpoints() {
             checkpointGrid.innerHTML = ''; // Clear existing cards
             currentAnalysisKeys.forEach(analysisKey => {
                 const card = document.createElement('div');
                 card.className = 'checkpoint-card';
                 const progress = analysisProgress[analysisKey] || { answered: 0, total: 0, completed: false };
                 const isDone = progress.completed;
                 // Use total from flat list for accurate count
                 const totalQuestionsInAnalysis = allQuestionsFlat.filter(q => q.analysis === analysisKey).length;
                 const answeredQuestionsInAnalysis = countAnsweredForAnalysis(analysisKey);

                 const statusText = isDone ? 'Selesai' : `${answeredQuestionsInAnalysis} / ${totalQuestionsInAnalysis} Pertanyaan`;

                 card.innerHTML = `
                     <h3><i class="fas fa-clipboard-list"></i> ${analysisKey}</h3>
                     <p class="checkpoint-status ${isDone ? 'done' : ''}">${statusText}</p>
                     <button data-analysis="${analysisKey}" class="${isDone ? 'done-button' : ''}">${isDone ? '<i class="fas fa-eye"></i> Lihat Topik' : '<i class="fas fa-play-circle"></i> Mulai/Lanjutkan'}</button>
                 `;
                 // Add click listener to the card itself for easier interaction
                 card.addEventListener('click', () => {
                     showTopicCheckpointSection(analysisKey);
                 });
                 // Keep button listener as fallback / explicit action
                 card.querySelector('button').addEventListener('click', (e) => {
                      e.stopPropagation(); // Prevent card click from firing too
                      showTopicCheckpointSection(analysisKey);
                 });
                 checkpointGrid.appendChild(card);
             });
         }
         // Helper to count actually answered questions for analysis progress display
         function countAnsweredForAnalysis(analysisKey) {
             return allQuestionsFlat.reduce((count, q) => {
                 if (q.analysis === analysisKey && answers[q.answerKey] !== undefined && answers[q.answerKey] !== null && answers[q.answerKey] !== '') {
                     return count + 1;
                 }
                 return count;
             }, 0);
         }


        function showTopicCheckpointSection(analysisKey) {
            hideAllSections();
            currentAnalysisKey = analysisKey;
            topicCheckpointAnalysisNameDisplay.innerHTML = `<i class="fas fa-stream"></i> Topik dalam: ${analysisKey}`; // Add icon
            renderTopicCheckpoints(analysisKey);
            topicCheckpointSection.style.display = 'block';
            currentTopicKey = null;
        }

         function renderTopicCheckpoints(analysisKey) {
             topicCheckpointGrid.innerHTML = ''; // Clear existing
             const topics = currentTopicKeys[analysisKey] || [];

             if (topics.length === 0) {
                  topicCheckpointGrid.innerHTML = '<p>Tidak ada topik ditemukan untuk analisis ini.</p>';
                  return;
             }

             topics.forEach(topicKey => {
                 const card = document.createElement('div');
                 card.className = 'topic-checkpoint-card';
                 const progress = topicProgress[analysisKey]?.[topicKey] || { answered: 0, total: 0, completed: false };
                 const isDone = progress.completed; // Use the accurate completion check

                 // Use total from flat list for accurate count
                 const totalQuestionsInTopic = allQuestionsFlat.filter(q => q.analysis === analysisKey && q.topic === topicKey).length;
                 const answeredQuestionsInTopic = countAnsweredForTopic(analysisKey, topicKey);

                 const statusText = isDone ? 'Selesai' : `${answeredQuestionsInTopic} / ${totalQuestionsInTopic} Pertanyaan`;

                 card.innerHTML = `
                     <h3><i class="fas fa-tag"></i> ${topicKey}</h3>
                     <p class="topic-checkpoint-status ${isDone ? 'done' : ''}">${statusText}</p>
                     <button data-topic="${topicKey}" class="${isDone ? 'done-button' : ''}">${isDone ? '<i class="fas fa-search"></i> Tinjau' : '<i class="fas fa-pencil-alt"></i> Mulai/Lanjutkan'}</button>
                 `;
                  // Add click listener to the card itself
                  card.addEventListener('click', () => {
                      showTopicGreeting(analysisKey, topicKey);
                  });
                  // Keep button listener
                  card.querySelector('button').addEventListener('click', (e) => {
                       e.stopPropagation();
                       showTopicGreeting(analysisKey, topicKey);
                  });
                 topicCheckpointGrid.appendChild(card);
             });
         }
         // Helper to count actually answered questions for topic progress display
         function countAnsweredForTopic(analysisKey, topicKey) {
             return allQuestionsFlat.reduce((count, q) => {
                 if (q.analysis === analysisKey && q.topic === topicKey && answers[q.answerKey] !== undefined && answers[q.answerKey] !== null && answers[q.answerKey] !== '') {
                     return count + 1;
                 }
                 return count;
             }, 0);
         }


         function showTopicGreeting(analysisKey, topicKey) {
             hideAllSections();
             currentAnalysisKey = analysisKey;
             currentTopicKey = topicKey;
             const topicsInAnalysis = currentTopicKeys[analysisKey] || [];
             const currentTopicIndex = topicsInAnalysis.indexOf(topicKey);
             const nextTopicIndex = currentTopicIndex + 1;
             const isLastTopic = nextTopicIndex >= topicsInAnalysis.length;
             const topicIsComplete = areAllTopicQuestionsAnswered(analysisKey, topicKey); // Use accurate check

             topicGreetingTitle.innerHTML = `<i class="fas ${topicIsComplete ? 'fa-check-circle' : 'fa-book-open'}"></i> ${topicIsComplete ? 'Meninjau' : 'Memulai'} Topik: ${topicKey}`;
             topicGreetingDescription.textContent = topicIsComplete
                ? `Anda telah menyelesaikan semua pertanyaan untuk topik ini. Anda dapat memulai untuk meninjau jawaban Anda.`
                : `Anda akan memulai atau melanjutkan pertanyaan untuk topik '${topicKey}'.`;

             // Show/hide "Next Topic" button
             if (!isLastTopic) {
                 nextTopicBtn.style.display = 'inline-block';
                 nextTopicBtn.innerHTML = `Lanjut ke Topik: ${topicsInAnalysis[nextTopicIndex]} <i class="fas fa-arrow-right"></i>`;
                 nextTopicBtn.onclick = () => showTopicGreeting(analysisKey, topicsInAnalysis[nextTopicIndex]);
             } else {
                 nextTopicBtn.style.display = 'none';
             }

             // Update Start button text and icon
             startTopicBtn.innerHTML = topicIsComplete ? '<i class="fas fa-search"></i> Mulai Tinjau Jawaban' : '<i class="fas fa-pencil-alt"></i> Mulai Pertanyaan';

             topicGreetingSection.style.display = 'block';
         }


        function showQuestionSection(analysisKey, topicKey, questionIndex = 0) {
            hideAllSections();
            currentAnalysisKey = analysisKey;
            currentTopicKey = topicKey;
            currentQuestionIndexInTopic = questionIndex; // Index within the *main* questions of the topic

             // Find the *main* question in the original structure based on topic index
             const mainQuestionData = questionsData[analysisKey]?.[topicKey]?.[questionIndex];
             if (!mainQuestionData) {
                 console.error(`Main question data not found for ${analysisKey} > ${topicKey} at index ${questionIndex}`);
                 showTopicCheckpointSection(analysisKey);
                 return;
             }

             // Find the corresponding *entry* in the flat list using the main answer key
             const questionInfo = allQuestionsFlat.find(q => q.answerKey === mainQuestionData.answerKey && !q.isFollowUp);
             if (!questionInfo) {
                 console.error(`Flat question entry not found for main key: ${mainQuestionData.answerKey}`);
                 showTopicCheckpointSection(analysisKey);
                 return;
             }
             currentGlobalQuestionIndex = questionInfo.globalIndex; // Set global index based on the main question

            displayQuestion(currentGlobalQuestionIndex); // Display based on global index
            questionSection.style.display = 'block';
        }

         // Helper to find a question in the flat list by its global index
         function findQuestionByGlobalIndex(globalIndex) {
             // Adjust index if needed (though ideally flat list is accurate)
             if (globalIndex < 0 || globalIndex >= allQuestionsFlat.length) {
                 console.warn(`Adjusting invalid globalIndex ${globalIndex}`);
                 globalIndex = Math.max(0, Math.min(globalIndex, allQuestionsFlat.length - 1));
             }
             return allQuestionsFlat[globalIndex];
         }

         // Find the *next* main question's global index, skipping over follow-ups
         function findNextMainQuestionGlobalIndex(startingGlobalIndex) {
             for (let i = startingGlobalIndex + 1; i < allQuestionsFlat.length; i++) {
                 if (!allQuestionsFlat[i].isFollowUp) {
                     return i; // Found the next main question
                 }
             }
             return -1; // No more main questions found
         }
         // Find the *previous* main question's global index
         function findPreviousMainQuestionGlobalIndex(startingGlobalIndex) {
              for (let i = startingGlobalIndex - 1; i >= 0; i--) {
                  if (!allQuestionsFlat[i].isFollowUp) {
                      return i; // Found the previous main question
                  }
              }
              return -1; // No previous main questions found
         }


        function displayQuestion(globalIndex) {
            const questionInfo = findQuestionByGlobalIndex(globalIndex);
            if (!questionInfo || questionInfo.isFollowUp) {
                 // This function should only be called with the global index of a MAIN question.
                 console.error("displayQuestion called with invalid or follow-up index:", globalIndex, questionInfo);
                 // Attempt to recover by finding the nearest main question or going back
                 const fallbackIndex = findPreviousMainQuestionGlobalIndex(globalIndex);
                 if (fallbackIndex !== -1) {
                     displayQuestion(fallbackIndex);
                 } else if (currentAnalysisKey) {
                     showTopicCheckpointSection(currentAnalysisKey);
                 } else {
                     showCheckpointSection();
                 }
                 return;
             }

            currentGlobalQuestionIndex = globalIndex; // Update state
            currentAnalysisKey = questionInfo.analysis;
            currentTopicKey = questionInfo.topic;
            currentQuestionIndexInTopic = questionInfo.indexInTopic; // Index of main question within topic
            currentYesNoSelection = null; // Reset yes/no selection for the new question

            const mainQuestionsInCurrentTopic = questionsData[currentAnalysisKey]?.[currentTopicKey] || [];
            const totalMainQuestionsInTopic = mainQuestionsInCurrentTopic.length;

            // Substitute company name
            const formattedQuestion = questionInfo.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');

            // Update card headers
            cardAnalysisTitle.textContent = `Analisis: ${currentAnalysisKey}`;
            cardTopicTitle.textContent = `Topik: ${currentTopicKey}`;
            cardQuestionText.innerHTML = marked.parseInline(formattedQuestion);

             // --- Dynamically create input elements ---
             answerInputContainer.innerHTML = ''; // Clear previous inputs
             followUpContainer.style.display = 'none'; // Hide follow-up by default
             followUpTextarea.value = ''; // Clear follow-up textarea

             if (questionInfo.type === 'yesno') {
                 // Create Yes/No buttons
                 const buttonDiv = document.createElement('div');
                 buttonDiv.className = 'yes-no-buttons';

                 const yesButton = document.createElement('button');
                 yesButton.type = 'button';
                 yesButton.className = 'yes';
                 yesButton.textContent = 'Ya';
                 yesButton.dataset.value = 'yes';

                 const noButton = document.createElement('button');
                 noButton.type = 'button';
                 noButton.className = 'no';
                 noButton.textContent = 'Tidak';
                 noButton.dataset.value = 'no';

                 // Load previous selection if exists
                 const savedAnswer = answers[questionInfo.answerKey];
                 if (savedAnswer === 'yes') {
                     yesButton.classList.add('selected');
                     currentYesNoSelection = 'yes';
                     showFollowUp('yes', questionInfo); // Show follow-up if needed
                 } else if (savedAnswer === 'no') {
                     noButton.classList.add('selected');
                     currentYesNoSelection = 'no';
                     showFollowUp('no', questionInfo); // Show follow-up if needed
                 }

                 yesButton.addEventListener('click', () => handleYesNoClick('yes', questionInfo, yesButton, noButton));
                 noButton.addEventListener('click', () => handleYesNoClick('no', questionInfo, yesButton, noButton));

                 buttonDiv.appendChild(yesButton);
                 buttonDiv.appendChild(noButton);
                 answerInputContainer.appendChild(buttonDiv);

             } else {
                 // Create Textarea for text questions
                 const label = document.createElement('label');
                 label.htmlFor = 'answer-textarea-dynamic';
                 label.textContent = 'Jawaban Anda:';

                 const textarea = document.createElement('textarea');
                 textarea.id = 'answer-textarea-dynamic'; // Unique ID
                 textarea.placeholder = 'Ketik jawaban Anda di sini...';
                 textarea.value = answers[questionInfo.answerKey] || ''; // Load saved answer

                 answerInputContainer.appendChild(label);
                 answerInputContainer.appendChild(textarea);
                 textarea.focus(); // Focus textarea for text questions
             }


            // Update progress bar info (based on main questions in topic)
            questionNumberDisplay.textContent = `Pertanyaan ${currentQuestionIndexInTopic + 1} dari ${totalMainQuestionsInTopic} (Topik Utama)`;

             // Update overall progress bar (based on *answered* keys vs total keys)
             const totalAnswerKeys = allQuestionsFlat.length;
             const answeredKeysCount = Object.keys(answers).filter(key => answers[key] !== undefined && answers[key] !== null && answers[key] !== '').length;
             const overallProgressPercent = totalAnswerKeys > 0 ? (answeredKeysCount / totalAnswerKeys) * 100 : 0;
             progressBarFill.style.width = `${overallProgressPercent}%`;

             // Update progress segments (visual dividers for main questions in topic)
             progressBarSegments.innerHTML = '';
             for (let i = 0; i < totalMainQuestionsInTopic; i++) {
                 const segment = document.createElement('div');
                 segment.className = 'progress-segment';
                 progressBarSegments.appendChild(segment);
             }

            // Enable/disable navigation buttons
            prevBtn.disabled = findPreviousMainQuestionGlobalIndex(currentGlobalQuestionIndex) === -1; // Disable if no previous *main* question

            // Fade in animation
            questionCard.style.opacity = '0';
            questionCard.style.transform = 'translateY(10px)';
            setTimeout(() => {
                questionCard.style.opacity = '1';
                questionCard.style.transform = 'translateY(0)';
            }, 50);
        }

         // Handle Yes/No button clicks
         function handleYesNoClick(value, questionInfo, yesBtn, noBtn) {
             currentYesNoSelection = value;
             answers[questionInfo.answerKey] = value; // Save 'yes' or 'no'

             // Update button styles
             yesBtn.classList.toggle('selected', value === 'yes');
             noBtn.classList.toggle('selected', value === 'no');

             showFollowUp(value, questionInfo); // Show/hide follow-up
             updateProgress(questionInfo.answerKey); // Update progress for the main Y/N question
             saveState(); // Save immediately after selection
         }

         // Show/Hide Follow-up question section
         function showFollowUp(trigger, questionInfo) {
             const followUpData = questionInfo.followUp[trigger];
             if (followUpData) {
                 const formattedFollowUp = followUpData.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                 followUpLabel.textContent = `Pertanyaan Lanjutan (jika ${trigger === 'yes' ? 'Ya' : 'Tidak'}):`;
                 followUpQuestionText.innerHTML = marked.parseInline(formattedFollowUp);
                 followUpTextarea.value = answers[followUpData.answerKey] || ''; // Load saved follow-up answer
                 followUpContainer.style.display = 'block';
                 followUpTextarea.focus(); // Focus follow-up textarea
             } else {
                 followUpContainer.style.display = 'none'; // Hide if no follow-up for this choice
                 // If hiding, potentially clear the answer for the *other* follow-up if it existed? Optional.
                 // const otherTrigger = trigger === 'yes' ? 'no' : 'yes';
                 // const otherFollowUp = questionInfo.followUp[otherTrigger];
                 // if (otherFollowUp && answers[otherFollowUp.answerKey]) {
                 //     delete answers[otherFollowUp.answerKey];
                 //     updateProgress(otherFollowUp.answerKey); // Update progress if deleting
                 // }
             }
         }


         function showAnalysisCompletion(analysisKey) {
              hideAllSections();
              analysisCompletionText.textContent = `Selamat! Anda telah menyelesaikan semua pertanyaan untuk analisis '${analysisKey}'.`;
              analysisCompletionSection.style.display = 'block';
              triggerCompletionAnimation();
          }

          function showReportSection() {
              hideAllSections();
              renderReport();
              reportSection.style.display = 'block';
              stopCompletionAnimation();
          }

          function renderReport() {
              // 1. Render User Info
              reportUserInfoDiv.innerHTML = `
                  <h3><i class="fas fa-user-circle"></i> Informasi Pengguna</h3>
                  <p><strong>Nama Perusahaan:</strong> <span>${currentUserInfo.companyName || 'N/A'}</span></p>
                  <p><strong>Industri:</strong> <span>${currentUserInfo.industry || 'N/A'}</span></p>
                  <p><strong>Ukuran Perusahaan:</strong> <span>${currentUserInfo.companySize || 'N/A'}</span></p>
                  <p><strong>Nama Pengguna:</strong> <span>${currentUserInfo.userName || 'N/A'}</span></p>
                  <p><strong>Email:</strong> <span>${currentUserInfo.userEmail || 'N/A'}</span></p>
                  <p><strong>Tanggal Laporan:</strong> <span>${new Date().toLocaleDateString('id-ID', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</span></p>
              `;

              // 2. Render Answers
              reportAnswersDiv.innerHTML = '<h3><i class="fas fa-tasks"></i> Jawaban Analisis</h3>';
              let reportContent = '';
              let hasAnyAnswer = false;

              currentAnalysisKeys.forEach(analysisKey => {
                  const analysisHasAnswers = currentTopicKeys[analysisKey]?.some(topicKey =>
                      questionsData[analysisKey]?.[topicKey]?.some(q => {
                          if (answers[q.answerKey]) return true;
                          if (q.type === 'yesno') {
                              if (q.followUp.yes && answers[q.followUp.yes.answerKey]) return true;
                              if (q.followUp.no && answers[q.followUp.no.answerKey]) return true;
                          }
                          return false;
                      })
                  );

                  if (analysisHasAnswers) {
                      hasAnyAnswer = true;
                      reportContent += `<h3>${analysisKey}</h3>`;
                      currentTopicKeys[analysisKey].forEach(topicKey => {
                          const mainQuestionsInTopic = questionsData[analysisKey]?.[topicKey] || [];
                          const topicHasAnswers = mainQuestionsInTopic.some(q => {
                               if (answers[q.answerKey]) return true;
                               if (q.type === 'yesno') {
                                   if (q.followUp.yes && answers[q.followUp.yes.answerKey]) return true;
                                   if (q.followUp.no && answers[q.followUp.no.answerKey]) return true;
                               }
                               return false;
                          });

                          if (topicHasAnswers) {
                              reportContent += `<h4>${topicKey}</h4>`;
                              mainQuestionsInTopic.forEach(q => {
                                  const mainAnswer = answers[q.answerKey];
                                  let followUpAnswer = null;
                                  let followUpQuestionText = null;
                                  let followUpKey = null;

                                  if (q.type === 'yesno' && (mainAnswer === 'yes' || mainAnswer === 'no')) {
                                      const followUpData = q.followUp[mainAnswer];
                                      if (followUpData) {
                                          followUpKey = followUpData.answerKey;
                                          followUpAnswer = answers[followUpKey];
                                          followUpQuestionText = followUpData.question;
                                      }
                                  }

                                  // Only show if main question or its triggered follow-up is answered
                                  if ((mainAnswer !== undefined && mainAnswer !== null && mainAnswer !== '') || (followUpAnswer !== undefined && followUpAnswer !== null && followUpAnswer !== '')) {
                                       const formattedQuestion = q.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                                       const escapedMainAnswer = (mainAnswer || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");
                                       const escapedFollowUpAnswer = (followUpAnswer || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");

                                       reportContent += `<div class="qa-block">`;
                                       reportContent += `<p><strong>${formattedQuestion}</strong></p>`;

                                       if (q.type === 'yesno') {
                                           if (mainAnswer === 'yes' || mainAnswer === 'no') {
                                               reportContent += `<p><span class="yes-no-answer ${mainAnswer}">${mainAnswer === 'yes' ? 'Ya' : 'Tidak'}</span></p>`;
                                               if (followUpQuestionText && (followUpAnswer !== undefined && followUpAnswer !== null && followUpAnswer !== '')) {
                                                    const formattedFollowUpQ = followUpQuestionText.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                                                    reportContent += `<div class="follow-up-answer">`;
                                                    reportContent += `<p><strong>${formattedFollowUpQ}</strong></p>`;
                                                    reportContent += `<p><span class="answer-text">${escapedFollowUpAnswer || '<i>(Tidak dijawab)</i>'}</span></p>`;
                                                    reportContent += `</div>`;
                                               }
                                           } else {
                                                reportContent += `<p><span class="answer-text"><i>(Tidak dijawab)</i></span></p>`;
                                           }
                                       } else {
                                           // Text question
                                           reportContent += `<p><span class="answer-text">${escapedMainAnswer || '<i>(Tidak dijawab)</i>'}</span></p>`;
                                       }
                                       reportContent += `</div>`; // Close qa-block
                                  }
                              });
                          }
                      });
                  }
              });

              if (!hasAnyAnswer) {
                   reportAnswersDiv.innerHTML += '<p><i>Belum ada jawaban yang diberikan.</i></p>';
              } else {
                   reportAnswersDiv.innerHTML += reportContent;
              }
          }


        // --- Event Handlers ---
        userInfoForm.addEventListener('submit', (e) => {
            e.preventDefault();
            currentUserInfo.companyName = companyNameInput.value.trim();
            currentUserInfo.industry = industrySelect.value; // Save industry
            currentUserInfo.companySize = companySizeSelect.value; // Save company size
            currentUserInfo.userName = userNameInput.value.trim();
            currentUserInfo.userEmail = userEmailInput.value.trim();
            // Basic validation
            if (currentUserInfo.companyName && currentUserInfo.userName && currentUserInfo.userEmail) {
                saveState();
                showCheckpointSection();
            } else {
                 alert('Harap isi Nama Perusahaan, Nama Anda, dan Email Anda.');
            }
        });

        // --- Navigation Button Event Listeners ---
        goToMainCheckpointBtn_TopicCheckpoint.addEventListener('click', showCheckpointSection);
        goToTopicCheckpointBtn_Greeting.addEventListener('click', () => {
            if (currentAnalysisKey) showTopicCheckpointSection(currentAnalysisKey);
            else showCheckpointSection();
        });
        goToMainCheckpointBtn_Greeting.addEventListener('click', showCheckpointSection);
        startTopicBtn.addEventListener('click', () => {
             if (currentAnalysisKey && currentTopicKey) {
                 // Start from the first *main* question in the topic
                 showQuestionSection(currentAnalysisKey, currentTopicKey, 0);
             }
         });
         backToTopicCheckpointBtn.addEventListener('click', () => {
              saveCurrentAnswer(); // Save before navigating
              if (currentAnalysisKey) showTopicCheckpointSection(currentAnalysisKey);
              else showCheckpointSection();
         });
         goToMainCheckpointBtn_Completion.addEventListener('click', () => {
             stopCompletionAnimation();
             showCheckpointSection();
         });
         viewFullReportBtn.addEventListener('click', () => {
             stopCompletionAnimation();
             showReportSection();
         });
         backToMainCheckpointBtn_Report.addEventListener('click', showCheckpointSection);

         // --- Question Navigation ---
         prevBtn.addEventListener('click', () => {
              saveCurrentAnswer(); // Save before moving
              const prevMainIndex = findPreviousMainQuestionGlobalIndex(currentGlobalQuestionIndex);
              if (prevMainIndex !== -1) {
                  displayQuestion(prevMainIndex);
              }
          });

          nextBtnQuestion.addEventListener('click', () => {
              const saved = saveCurrentAnswer(); // Save current answer(s) first
              if (!saved) return; // Don't proceed if saving failed (e.g., required follow-up missing)

              const nextMainIndex = findNextMainQuestionGlobalIndex(currentGlobalQuestionIndex);

              if (nextMainIndex !== -1) {
                  // Check if next main question is in a different topic or analysis
                  const currentQuestionInfo = findQuestionByGlobalIndex(currentGlobalQuestionIndex);
                  const nextQuestionInfo = findQuestionByGlobalIndex(nextMainIndex);

                  if (nextQuestionInfo.topic !== currentTopicKey) {
                       // Moved to a new topic, check if analysis is complete
                       if (analysisProgress[currentAnalysisKey]?.completed) {
                           showAnalysisCompletion(currentAnalysisKey);
                       } else {
                           // Go to topic checkpoint if not complete
                           showTopicCheckpointSection(currentAnalysisKey);
                       }
                  } else {
                       // Still in the same topic, display next main question
                       displayQuestion(nextMainIndex);
                  }
              } else {
                  // No more main questions found in the entire list
                  // Check if the *current* analysis is now complete
                  if (analysisProgress[currentAnalysisKey]?.completed) {
                      showAnalysisCompletion(currentAnalysisKey);
                  } else {
                       // If not complete, something is odd, maybe go back to topic list?
                       console.warn("Reached end of main questions, but analysis not marked complete. Returning to topic checkpoints.");
                       showTopicCheckpointSection(currentAnalysisKey);
                  }
                  // As a final fallback, could show the full report
                  // showReportSection();
              }
          });

          // Function to save the currently displayed question's answer(s)
          function saveCurrentAnswer() {
              const questionInfo = findQuestionByGlobalIndex(currentGlobalQuestionIndex);
              if (!questionInfo) return false;

              let mainAnswerChanged = false;
              let followUpAnswerChanged = false;

              if (questionInfo.type === 'yesno') {
                  // Yes/No answer is already saved by handleYesNoClick via currentYesNoSelection
                  const mainAnswerKey = questionInfo.answerKey;
                  const savedMainAnswer = answers[mainAnswerKey];

                  // Check if follow-up is visible and needs saving
                  if (followUpContainer.style.display === 'block') {
                      const followUpTrigger = savedMainAnswer; // 'yes' or 'no'
                      const followUpData = questionInfo.followUp[followUpTrigger];
                      if (followUpData) {
                          const followUpKey = followUpData.answerKey;
                          const followUpAnswer = followUpTextarea.value.trim();
                          const previousFollowUpAnswer = answers[followUpKey];

                          if (followUpAnswer === '') {
                              // Optional: Require follow-up if shown?
                              // alert('Jawaban untuk pertanyaan lanjutan tidak boleh kosong.');
                              // return false; // Prevent moving next if follow-up is required but empty
                          }

                          if (followUpAnswer !== previousFollowUpAnswer) {
                              answers[followUpKey] = followUpAnswer;
                              updateProgress(followUpKey);
                              followUpAnswerChanged = true;
                          }
                      }
                  }
              } else {
                  // Text question
                  const textarea = document.getElementById('answer-textarea-dynamic');
                  if (textarea) {
                      const answerKey = questionInfo.answerKey;
                      const currentAnswer = textarea.value.trim();
                      const previousAnswer = answers[answerKey];
                      if (currentAnswer !== previousAnswer) {
                          answers[answerKey] = currentAnswer;
                          updateProgress(answerKey);
                          mainAnswerChanged = true;
                      }
                  }
              }

              if (mainAnswerChanged || followUpAnswerChanged) {
                  saveState(); // Save to localStorage if any change occurred
              }
              return true; // Indicate saving process completed (even if no changes)
          }


        // --- Report Actions ---
         downloadReportBtn.addEventListener('click', () => {
             const reportData = {
                 userInfo: currentUserInfo,
                 answers: answers,
                 reportDate: new Date().toISOString()
             };
             const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(reportData, null, 2));
             const downloadAnchorNode = document.createElement('a');
             downloadAnchorNode.setAttribute("href", dataStr);
             const safeCompanyName = (currentUserInfo.companyName || 'report').replace(/[^a-z0-9]/gi, '_').toLowerCase();
             downloadAnchorNode.setAttribute("download", `rjpp_report_${safeCompanyName}_${new Date().toISOString().split('T')[0]}.json`);
             document.body.appendChild(downloadAnchorNode);
             downloadAnchorNode.click();
             downloadAnchorNode.remove();
         });

        copyReportBtn.addEventListener('click', () => {
            let markdownReport = `# Laporan Analisis RJPP\n\n`;
            markdownReport += `## Informasi Pengguna\n`;
            markdownReport += `- Nama Perusahaan: ${currentUserInfo.companyName || 'N/A'}\n`;
            markdownReport += `- Industri: ${currentUserInfo.industry || 'N/A'}\n`; // Added
            markdownReport += `- Ukuran Perusahaan: ${currentUserInfo.companySize || 'N/A'}\n`; // Added
            markdownReport += `- Nama Pengguna: ${currentUserInfo.userName || 'N/A'}\n`;
            markdownReport += `- Email: ${currentUserInfo.userEmail || 'N/A'}\n`;
            markdownReport += `- Tanggal Laporan: ${new Date().toLocaleDateString('id-ID', { dateStyle: 'full' })}\n\n`;

            markdownReport += `## Jawaban Analisis\n\n`;
            let hasAnyAnswerMd = false;

             currentAnalysisKeys.forEach(analysisKey => {
                  const analysisHasAnswers = currentTopicKeys[analysisKey]?.some(topicKey =>
                      questionsData[analysisKey]?.[topicKey]?.some(q => {
                          if (answers[q.answerKey]) return true;
                          if (q.type === 'yesno') {
                              if (q.followUp.yes && answers[q.followUp.yes.answerKey]) return true;
                              if (q.followUp.no && answers[q.followUp.no.answerKey]) return true;
                          }
                          return false;
                      })
                  );

                  if (analysisHasAnswers) {
                      hasAnyAnswerMd = true;
                      markdownReport += `### ${analysisKey}\n\n`;
                      currentTopicKeys[analysisKey].forEach(topicKey => {
                          const mainQuestionsInTopic = questionsData[analysisKey]?.[topicKey] || [];
                           const topicHasAnswers = mainQuestionsInTopic.some(q => {
                                if (answers[q.answerKey]) return true;
                                if (q.type === 'yesno') {
                                    if (q.followUp.yes && answers[q.followUp.yes.answerKey]) return true;
                                    if (q.followUp.no && answers[q.followUp.no.answerKey]) return true;
                                }
                                return false;
                           });

                          if (topicHasAnswers) {
                              markdownReport += `#### ${topicKey}\n\n`;
                              mainQuestionsInTopic.forEach(q => {
                                   const mainAnswer = answers[q.answerKey];
                                   let followUpAnswer = null;
                                   let followUpQuestionText = null;

                                   if (q.type === 'yesno' && (mainAnswer === 'yes' || mainAnswer === 'no')) {
                                       const followUpData = q.followUp[mainAnswer];
                                       if (followUpData) {
                                           followUpAnswer = answers[followUpData.answerKey];
                                           followUpQuestionText = followUpData.question;
                                       }
                                   }

                                   if ((mainAnswer !== undefined && mainAnswer !== null && mainAnswer !== '') || (followUpAnswer !== undefined && followUpAnswer !== null && followUpAnswer !== '')) {
                                       const formattedQuestion = q.question.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                                       markdownReport += `**${formattedQuestion}**\n\n`;

                                       if (q.type === 'yesno') {
                                           if (mainAnswer === 'yes' || mainAnswer === 'no') {
                                               markdownReport += `Jawaban: **${mainAnswer === 'yes' ? 'Ya' : 'Tidak'}**\n\n`;
                                               if (followUpQuestionText && (followUpAnswer !== undefined && followUpAnswer !== null && followUpAnswer !== '')) {
                                                   const formattedFollowUpQ = followUpQuestionText.replace(/\$\{companyName\}/g, currentUserInfo.companyName || '[Nama Perusahaan]');
                                                   markdownReport += `> **${formattedFollowUpQ}**\n>\n> ${followUpAnswer}\n\n`; // Follow-up as blockquote
                                               }
                                           } else {
                                                markdownReport += `*(Tidak dijawab)*\n\n`;
                                           }
                                       } else {
                                           markdownReport += `${mainAnswer || '*(Tidak dijawab)*'}\n\n`;
                                       }
                                   }
                              });
                          }
                      });
                  }
              });

             if (!hasAnyAnswerMd) {
                 markdownReport += `*Belum ada jawaban yang diberikan.*\n`;
             }

            navigator.clipboard.writeText(markdownReport)
                .then(() => alert('Laporan dalam format Markdown telah disalin ke clipboard!'))
                .catch(err => {
                    console.error('Gagal menyalin laporan:', err);
                    alert('Gagal menyalin laporan. Coba lagi atau salin manual.');
                });
        });

         // Review/Edit Answers Button Handler
         reviewAnswersBtn.addEventListener('click', () => {
             // Find the first *main* question's global index
             const firstMainIndex = allQuestionsFlat.findIndex(q => !q.isFollowUp);
             if (firstMainIndex !== -1) {
                 displayQuestion(firstMainIndex); // Start review from the first main question
                 questionSection.style.display = 'block'; // Ensure section is shown
             } else {
                 showCheckpointSection(); // Fallback if no questions
             }
         });

        // --- Completion Animation ---
        let animationInterval; // Keep interval logic if desired

        function triggerCompletionAnimation() {
            stopCompletionAnimation();
            createConfetti();
            createBalloons();
            // Optional: Repeat animation
            // animationInterval = setInterval(() => { createConfetti(); createBalloons(); }, 5000);
        }

        function stopCompletionAnimation() {
            clearInterval(animationInterval);
            completionConfettiContainer.innerHTML = '';
            completionBalloonsContainer.innerHTML = '';
        }

        function createConfetti() {
            completionConfettiContainer.innerHTML = ''; // Clear previous
            const colors = ['#f44336', '#2196f3', '#4caf50', '#ffeb3b', '#9c27b0', '#00bcd4']; // Material-like colors
            for (let i = 0; i < 120; i++) { // More confetti
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = `${Math.random() * 2.5}s`;
                confetti.style.animationDuration = `${3 + Math.random() * 3}s`;
                 confetti.style.transform = `scale(${0.6 + Math.random() * 0.6})`;
                 confetti.style.width = `${8 + Math.random() * 5}px`; // Vary size more
                 confetti.style.height = confetti.style.width;
                 confetti.style.borderRadius = `${Math.random() > 0.5 ? '50%' : '0'}`; // Mix circles and squares
                completionConfettiContainer.appendChild(confetti);
            }
        }

        function createBalloons() {
             completionBalloonsContainer.innerHTML = '';
             const colors = ['rgba(255, 87, 34, 0.8)', 'rgba(33, 150, 243, 0.8)', 'rgba(76, 175, 80, 0.8)', 'rgba(255, 235, 59, 0.8)', 'rgba(156, 39, 176, 0.8)'];
             const numBalloons = 7; // More balloons
             for (let i = 0; i < numBalloons; i++) {
                 const balloon = document.createElement('div');
                 balloon.className = 'balloon';
                 balloon.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                 balloon.style.left = `${(100 / (numBalloons + 1)) * (i + 1) - (70 / window.innerWidth * 50)}%`;
                 balloon.style.animationDelay = `${Math.random() * 2}s`;
                 balloon.style.animationDuration = `${5 + Math.random() * 4}s`;
                 completionBalloonsContainer.appendChild(balloon);
             }
         }


        // --- Keyboard Shortcut ---
        document.addEventListener('keydown', function(event) {
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                // Check if question section is visible and focus is inside a textarea
                const activeElement = document.activeElement;
                if (questionSection.style.display !== 'none' && activeElement &&
                   (activeElement.id === 'answer-textarea-dynamic' || activeElement.id === 'follow-up-textarea'))
                {
                    event.preventDefault();
                    nextBtnQuestion.click();
                }
            }
        });


        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', initialize);

    </script>
</body>
</html>