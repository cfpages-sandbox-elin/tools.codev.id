<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Article Generator & Spinner ü™Ñ v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for compactness and spintax coloring */
        body {
            font-family: 'Inter', sans-serif; /* Default font */
            @apply bg-gray-100 text-gray-800; /* Slightly lighter bg */
        }
        .compact-section {
            @apply bg-white p-4 mb-4 rounded-lg shadow-md; /* Slightly more padding/shadow */
        }
        .compact-label {
            @apply block text-sm font-medium text-gray-700 mb-1;
        }
        /* Ensure inputs always have borders */
        .compact-input, .compact-select, .compact-textarea {
            @apply block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm; /* Standard padding */
        }
        /* Style for custom inputs when shown */
        .custom-input-visible {
             @apply compact-input mt-1; /* Inherit base style and add margin */
        }
        .compact-button {
            @apply inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed; /* Added disabled cursor */
        }
        .api-key-input {
            @apply compact-input;
            font-family: monospace;
        }
        /* Spintax Highlighting */
        .spintax-level-1 { color: #007bff; } /* Blue */
        .spintax-level-2 { color: #28a745; } /* Green */
        .spintax-level-3 { color: #dc3545; } /* Red */
        .spintax-pipe { color: #ffc107; font-weight: bold; } /* Yellow */

        /* Hide scrollbar for textarea but allow scrolling */
         .compact-textarea::-webkit-scrollbar { display: none; }
        .compact-textarea { -ms-overflow-style: none; scrollbar-width: none; }

        /* Tidy alignment: Use grid with consistent label/input pairing */
        .input-group {
            @apply mb-3; /* Spacing between input groups */
        }

         /* Loading spinner style */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #6366f1; /* Indigo */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Console log styling */
        #consoleLogContainer {
             @apply compact-section mt-4 bg-gray-800 text-white p-3;
        }
        #consoleLog {
             @apply text-xs h-32 overflow-y-auto whitespace-pre-wrap break-all font-mono;
        }
        .log-error { @apply text-red-400; }
        .log-warn { @apply text-yellow-400; }
        .log-info { @apply text-blue-300; }
        .log-success { @apply text-green-400; }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="p-4 max-w-4xl mx-auto"> <h1 class="text-2xl font-bold mb-4 text-center text-indigo-700">AI Article Generator & Spinner ü™Ñüìù‚ú®</h1>

    <section id="step1" class="compact-section">
        <h2 class="text-lg font-semibold mb-3 text-gray-600 border-b pb-2">Step 1: Define Your Article üéØ</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4"> <div class="input-group">
                <label for="keyword" class="compact-label">Keyword / Product üîë:</label>
                <input type="text" id="keyword" class="compact-input" placeholder="e.g., best ergonomic chairs">
            </div>
            <div class="input-group">
                <label for="language" class="compact-label">Language üó£Ô∏è:</label>
                <select id="language" class="compact-select">
                    <option value="English">English</option>
                    <option value="Indonesian">Indonesian</option>
                    <option value="Spanish">Spanish</option>
                    <option value="French">French</option>
                    <option value="German">German</option>
                    <option value="custom">Custom...</option>
                </select>
                <input type="text" id="custom_language" class="custom-input-visible hidden" placeholder="Enter custom language">
            </div>
            <div class="input-group">
                <label for="tone" class="compact-label">Tone üòé:</label>
                <select id="tone" class="compact-select">
                    <option value="Professional">Professional</option>
                    <option value="Casual">Casual</option>
                    <option value="Formal">Formal</option>
                    <option value="Humorous">Humorous</option>
                    <option value="Informative">Informative</option>
                     <option value="custom">Custom...</option>
                </select>
                 <input type="text" id="custom_tone" class="custom-input-visible hidden" placeholder="Enter custom tone">
            </div>
            <div class="input-group">
                <label for="format" class="compact-label">Output Format üìÑ:</label>
                <select id="format" class="compact-select">
                    <option value="html">HTML</option>
                    <option value="markdown">Markdown</option>
                </select>
            </div>
             <div class="input-group md:col-span-2"> <label for="custom_specs" class="compact-label">Other Specifications (Optional) ‚úçÔ∏è:</label>
                <textarea id="custom_specs" rows="2" class="compact-textarea" placeholder="e.g., Target audience is small business owners, mention sustainability..."></textarea>
            </div>
        </div>
        <div class="mt-4 pt-4 border-t border-gray-200">
             <h3 class="text-md font-semibold mb-3 text-gray-600">AI Configuration ü§ñ</h3>
             <div class="grid grid-cols-1 md:grid-cols-3 gap-x-4">
                 <div class="input-group">
                    <label for="ai_provider" class="compact-label">AI Provider:</label>
                    <select id="ai_provider" class="compact-select">
                        <option value="google">Google</option>
                        <option value="openai">OpenAI</option>
                        <option value="anthropic">Anthropic</option>
                        <option value="deepseek">DeepSeek</option>
                        <option value="xai">xAI (Grok)</option>
                    </select>
                 </div>
                 <div class="input-group">
                    <label for="ai_model" class="compact-label">Model:</label>
                    <select id="ai_model" class="compact-select">
                        </select>
                 </div>
                 <div class="input-group">
                    <label for="api_key" class="compact-label">API Key üîí:</label>
                    <input type="password" id="api_key" class="api-key-input" placeholder="Enter API Key & hit Enter/Tab">
                 </div>
             </div>
             <p class="text-xs text-gray-500 mt-1">API Key is saved to browser's local storage automatically when you leave the input field. <strong class="text-yellow-600">Warning:</strong> Storing keys in browser is insecure for shared apps.</p>
        </div>
        <div class="mt-4 text-right">
            <button id="generateStructureBtn" class="compact-button">
                Generate Structure üèóÔ∏è
                <span id="structureLoadingIndicator" class="hidden"><span class="loader"></span></span>
            </button>
        </div>
    </section>

    <section id="step2" class="compact-section hidden">
        <div class="flex justify-between items-center mb-2 border-b pb-2">
            <h2 class="text-lg font-semibold text-gray-600">Step 2: Refine Structure üìê</h2>
            <button id="toggleStructureVisibility" class="text-sm text-indigo-600 hover:underline">Hide</button>
        </div>
        <div id="structureContainer">
             <label for="article_structure" class="compact-label">Generated Structure (Editable):</label>
             <textarea id="article_structure" rows="8" class="compact-textarea" placeholder="AI will generate the article structure here..."></textarea>
             <div class="mt-3 text-right">
                 <button id="generateArticleBtn" class="compact-button">
                     Generate Full Article ‚úçÔ∏è
                     <span id="articleLoadingIndicator" class="hidden"><span class="loader"></span></span>
                 </button>
             </div>
        </div>
    </section>

    <section id="step3" class="compact-section hidden">
         <h2 class="text-lg font-semibold mb-3 text-gray-600 border-b pb-2">Step 3: Review & Edit Article üìù</h2>
         <label for="generated_article" class="compact-label">Generated Article (Editable):</label>
         <div id="article_output_container" class="border border-gray-300 rounded-md p-1 bg-gray-50 min-h-[200px] max-h-[450px] overflow-y-auto"> <textarea id="generated_article" rows="12" class="compact-textarea w-full h-full border-none focus:ring-0 bg-transparent" placeholder="AI will generate the full article here..."></textarea>
             <div id="html_preview" class="prose max-w-none hidden p-2"></div>
         </div>
         <div class="mt-2 flex justify-between items-center">
             <label class="flex items-center space-x-2 text-sm cursor-pointer">
                 <input type="checkbox" id="preview_html_checkbox" class="rounded text-indigo-600 focus:ring-indigo-500">
                 <span>Preview HTML</span>
             </label>
             <button id="enableSpinningBtn" class="compact-button">
                 Enable Spinning üîÑ
                  <span id="spinLoadingIndicator" class="hidden"><span class="loader"></span></span>
            </button>
         </div>
    </section>

    <section id="step4" class="compact-section hidden">
         <h2 class="text-lg font-semibold mb-3 text-gray-600 border-b pb-2">Step 4: Spin Content üåÄ</h2>
         <p class="text-sm text-gray-600 mb-2">Select text in the article area below, then click the "Spin Selected Text" button.</p>
         <div class="mb-2 text-right">
             <button id="spinSelectedBtn" class="compact-button" disabled>
                 Spin Selected Text ‚ú®
                 <span id="spinActionLoadingIndicator" class="hidden"><span class="loader"></span></span>
             </button>
         </div>
         <label for="spun_article_display" class="compact-label">Spinnable Article (Editable):</label>
         <div id="spin_output_container" class="border border-gray-300 rounded-md p-2 bg-gray-50 min-h-[200px] max-h-[450px] overflow-y-auto">
              <div id="spun_article_display" contenteditable="true" class="compact-textarea w-full h-full border-none focus:outline-none focus:ring-0 min-h-[200px]" placeholder="Article content will appear here for spinning..."></div>
         </div>
         <p class="text-xs text-gray-500 mt-2">Spintax: <code class="bg-gray-200 px-1 rounded">{opt1|opt2}</code> Nested: <code class="bg-gray-200 px-1 rounded">{opt1|{nest1|nest2}|opt3}</code>. Colors distinguish levels.</p>
    </section>

    <div id="consoleLogContainer">
        <h3 class="text-md font-semibold mb-2 text-gray-400">Console Log ü™µ</h3>
        <pre id="consoleLog"></pre>
    </div>


    <script>
        // --- Configuration ---
        const aiProviders = {
            // Updated models (as of early 2025 - check provider docs for latest)
            google: {
                models: ['gemini-1.5-pro-latest', 'gemini-1.5-flash-latest', 'gemini-1.0-pro'],
                endpoint: (model, apiKey) => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
                getBody: (prompt) => ({ contents: [{ parts: [{ text: prompt }] }] }),
                headers: { 'Content-Type': 'application/json' },
                getText: (data) => data?.candidates?.[0]?.content?.parts?.[0]?.text || ''
            },
            openai: {
                models: ['gpt-4o', 'gpt-4-turbo', 'gpt-3.5-turbo'],
                endpoint: () => `https://api.openai.com/v1/chat/completions`,
                getBody: (prompt, model) => ({ model: model, messages: [{ role: 'user', content: prompt }], max_tokens: 1500 }), // Adjust max_tokens as needed
                headers: (apiKey) => ({ 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }),
                getText: (data) => data?.choices?.[0]?.message?.content || ''
            },
            anthropic: {
                models: ['claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
                endpoint: () => `https://api.anthropic.com/v1/messages`,
                getBody: (prompt, model) => ({ model: model, messages: [{ role: 'user', content: prompt }], max_tokens: 1500 }), // Adjust max_tokens
                headers: (apiKey) => ({
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey, // Anthropic uses x-api-key header
                    'anthropic-version': '2023-06-01'
                 }),
                getText: (data) => data?.content?.[0]?.text || '',
                cors_warning: true // Flag potential CORS issues
            },
             deepseek: {
                models: ['deepseek-chat', 'deepseek-coder'],
                endpoint: () => `https://api.deepseek.com/v1/chat/completions`,
                getBody: (prompt, model) => ({ model: model, messages: [{ role: 'user', content: prompt }], max_tokens: 1500 }),
                headers: (apiKey) => ({ 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }),
                getText: (data) => data?.choices?.[0]?.message?.content || '',
                cors_warning: true // Flag potential CORS issues
            },
            xai: { // Grok - API details might differ, assuming OpenAI compatible for now
                models: ['grok-1'], // Check official XAI docs for endpoints/models
                endpoint: () => `https://api.xai.com/v1/chat/completions`, // Placeholder endpoint - VERIFY THIS
                getBody: (prompt, model) => ({ model: model, messages: [{ role: 'user', content: prompt }], max_tokens: 1500 }),
                headers: (apiKey) => ({ 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }),
                getText: (data) => data?.choices?.[0]?.message?.content || '',
                cors_warning: true, // Highly likely CORS issues / specific setup needed
                api_note: "XAI/Grok API details are less public; endpoint/body might differ. Verify official documentation."
            }
        };

        // --- DOM Elements ---
        const keywordInput = document.getElementById('keyword');
        const languageSelect = document.getElementById('language');
        const customLanguageInput = document.getElementById('custom_language');
        const toneSelect = document.getElementById('tone');
        const customToneInput = document.getElementById('custom_tone');
        const formatSelect = document.getElementById('format');
        const customSpecsInput = document.getElementById('custom_specs');
        const aiProviderSelect = document.getElementById('ai_provider');
        const aiModelSelect = document.getElementById('ai_model');
        const apiKeyInput = document.getElementById('api_key');

        const generateStructureBtn = document.getElementById('generateStructureBtn');
        const generateArticleBtn = document.getElementById('generateArticleBtn');
        const enableSpinningBtn = document.getElementById('enableSpinningBtn');
        const spinSelectedBtn = document.getElementById('spinSelectedBtn');
        const toggleStructureVisibilityBtn = document.getElementById('toggleStructureVisibility');
        const previewHtmlCheckbox = document.getElementById('preview_html_checkbox');

        const step1Section = document.getElementById('step1');
        const step2Section = document.getElementById('step2');
        const step3Section = document.getElementById('step3');
        const step4Section = document.getElementById('step4');

        const structureContainer = document.getElementById('structureContainer');
        const articleStructureTextarea = document.getElementById('article_structure');
        const generatedArticleTextarea = document.getElementById('generated_article');
        const articleOutputContainer = document.getElementById('article_output_container');
        const htmlPreviewDiv = document.getElementById('html_preview');
        const spinOutputContainer = document.getElementById('spin_output_container');
        const spunArticleDisplay = document.getElementById('spun_article_display');

        // Loading Indicators
        const structureLoadingIndicator = document.getElementById('structureLoadingIndicator');
        const articleLoadingIndicator = document.getElementById('articleLoadingIndicator');
        const spinLoadingIndicator = document.getElementById('spinLoadingIndicator'); // On enable spinning btn (less likely needed)
        const spinActionLoadingIndicator = document.getElementById('spinActionLoadingIndicator'); // On spin selected btn

        const consoleLog = document.getElementById('consoleLog');

        // --- Helper Functions ---
        function logToConsole(message, type = 'info') {
            console.log(`[${type.toUpperCase()}] ${message}`); // Log to browser console
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = documentcreateElement('div');
            logEntry.classList.add(`log-${type}`);
            logEntry.textContent = `[${timestamp}] ${message}`;
            consoleLog.prepend(logEntry); // Add new logs to the top

            // Keep log trimmed (optional)
            while (consoleLog.children.length > 50) {
                consoleLog.removeChild(consoleLog.lastChild);
            }
        }

        function showLoading(indicatorElement, show = true) {
            indicatorElement.classList.toggle('hidden', !show);
        }

        function disableButtons(disabled = true) {
            generateStructureBtn.disabled = disabled;
            generateArticleBtn.disabled = disabled;
            enableSpinningBtn.disabled = disabled;
            // spinSelectedBtn is handled separately
        }

        function getSelectedProviderKey() {
             return aiProviderSelect.value;
        }

        function getProviderConfig() {
            const providerKey = getSelectedProviderKey();
            return aiProviders[providerKey];
        }

        // --- Local Storage for API Keys ---
        function loadApiKey() {
            const providerKey = getSelectedProviderKey();
            const keys = JSON.parse(localStorage.getItem('aiApiKeys_v2') || '{}'); // Use new key to avoid conflicts
            apiKeyInput.value = keys[providerKey] || '';
            logToConsole(`Checked local storage for ${providerKey} API key.`);
        }

        function saveApiKey() {
            const providerKey = getSelectedProviderKey();
            const key = apiKeyInput.value.trim();
            const keys = JSON.parse(localStorage.getItem('aiApiKeys_v2') || '{}');
            if (key) {
                keys[providerKey] = key;
                localStorage.setItem('aiApiKeys_v2', JSON.stringify(keys));
                logToConsole(`Saved API key for ${providerKey} to local storage.`);
            } else {
                // Remove key if field is cleared and key exists
                if (keys[providerKey]) {
                    delete keys[providerKey];
                    localStorage.setItem('aiApiKeys_v2', JSON.stringify(keys));
                    logToConsole(`Removed API key for ${providerKey} from local storage.`);
                }
            }
        }

        // --- Dynamic Model Loading ---
        function populateModels() {
            const providerConfig = getProviderConfig();
            const models = providerConfig?.models || [];
            aiModelSelect.innerHTML = ''; // Clear existing options

            if (providerConfig?.api_note) {
                logToConsole(`Note for ${getSelectedProviderKey()}: ${providerConfig.api_note}`, 'warn');
            }
            if (providerConfig?.cors_warning) {
                 logToConsole(`Warning: Direct browser calls to ${getSelectedProviderKey()} might be blocked by CORS. A backend proxy might be needed.`, 'warn');
            }


            if (models.length === 0) {
                 const option = document.createElement('option');
                 option.value = '';
                 option.textContent = 'No models listed';
                 aiModelSelect.appendChild(option);
                 aiModelSelect.disabled = true;
            } else {
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    aiModelSelect.appendChild(option);
                });
                 aiModelSelect.disabled = false;
            }
            loadApiKey(); // Load key for the newly selected provider
        }

        // --- Unified AI Call Function ---
        async function callAI(prompt, loadingIndicator, buttonToDisable) {
            const providerKey = getSelectedProviderKey();
            const providerConfig = getProviderConfig();
            const model = aiModelSelect.value;
            const apiKey = apiKeyInput.value.trim();

            if (!providerConfig || !model || !apiKey) {
                logToConsole('Missing Provider Config, Model, or API Key.', 'error');
                alert('Please select a provider, model, and enter your API key.');
                return null;
            }

            const endpoint = typeof providerConfig.endpoint === 'function' ? providerConfig.endpoint(model, apiKey) : providerConfig.endpoint;
            const body = providerConfig.getBody(prompt, model);
            const headers = typeof providerConfig.headers === 'function' ? providerConfig.headers(apiKey) : providerConfig.headers;

            logToConsole(`Calling ${providerKey} (${model})...`, 'info');
            showLoading(loadingIndicator, true);
            if (buttonToDisable) buttonToDisable.disabled = true; else disableButtons(true);

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`API Error (${response.status}): ${response.statusText}. Body: ${errorBody}`);
                }

                const data = await response.json();
                const generatedText = providerConfig.getText(data);

                if (!generatedText) {
                     logToConsole(`No text found in API response: ${JSON.stringify(data)}`, 'warn');
                     throw new Error('AI returned an empty or unexpected response.');
                }

                logToConsole(`Successfully received response from ${providerKey}.`, 'success');
                return generatedText;

            } catch (error) {
                console.error("AI Call Failed:", error);
                logToConsole(`AI Call Error: ${error.message}`, 'error');
                // Check for common errors
                if (error.message.includes('CORS')) {
                     logToConsole('This might be a CORS issue. Direct browser calls to this API might be blocked. Consider using a backend proxy.', 'error');
                     alert(`API Call Failed: CORS policy might be blocking the request to ${providerKey}. Check the browser console (F12) for details. A backend proxy might be required for this provider.`);
                } else if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                     alert(`API Call Failed: Authentication error (401). Please check if your API key for ${providerKey} is correct and active.`);
                } else if (error.message.includes('400') || error.message.includes('Bad Request')) {
                     alert(`API Call Failed: Bad Request (400). The data sent to the API might be incorrect. Check the prompt or configuration. Details: ${error.message}`);
                }
                 else {
                     alert(`API Call Failed: ${error.message}. Check the console log for more details.`);
                }
                return null; // Indicate failure
            } finally {
                showLoading(loadingIndicator, false);
                 if (buttonToDisable) buttonToDisable.disabled = false; else disableButtons(false);
            }
        }


        // --- Spintax Highlighting ---
        function highlightSpintax(element) {
            // Avoid re-highlighting if already done (simple check)
            if (element.querySelector('.spintax-pipe')) return;

            let html = element.innerHTML;
             // Temporarily replace HTML tags to avoid messing them up
            const tagMap = {};
            let tagIndex = 0;
            html = html.replace(/<[^>]+>/g, (match) => {
                const placeholder = `__TAG${tagIndex}__`;
                tagMap[placeholder] = match;
                tagIndex++;
                return placeholder;
            });

            // Replace pipes first
            html = html.replace(/\|/g, '<span class="spintax-pipe">|</span>');

            let level = 0;
            let coloredHtml = '';
            for (let i = 0; i < html.length; i++) {
                if (html[i] === '{') {
                    level++;
                    const colorClass = `spintax-level-${level % 3 + 1}`;
                    coloredHtml += `<span class="${colorClass}">{</span>`;
                } else if (html[i] === '}') {
                     if (level > 0) {
                         const colorClass = `spintax-level-${level % 3 + 1}`;
                         coloredHtml += `<span class="${colorClass}">}</span>`;
                         level--;
                     } else {
                         coloredHtml += '}'; // Avoid closing unopened spans
                     }
                } else {
                    coloredHtml += html[i];
                }
            }

             // Restore HTML tags
            coloredHtml = coloredHtml.replace(/__TAG\d+__/g, (placeholder) => tagMap[placeholder] || placeholder);

            element.innerHTML = coloredHtml;
        }

        // --- Event Listeners ---

        // Custom input toggles
        languageSelect.addEventListener('change', () => {
            customLanguageInput.classList.toggle('hidden', languageSelect.value !== 'custom');
        });
        toneSelect.addEventListener('change', () => {
            customToneInput.classList.toggle('hidden', toneSelect.value !== 'custom');
        });

        // AI Provider/Model/Key Handling
        aiProviderSelect.addEventListener('change', populateModels);
        apiKeyInput.addEventListener('change', saveApiKey); // Save on change/blur instead of input

        // Step 1 -> Step 2: Generate Structure
        generateStructureBtn.addEventListener('click', async () => {
            const keyword = keywordInput.value.trim();
            if (!keyword) {
                alert('Please enter a keyword or product.');
                return;
            }

            const language = languageSelect.value === 'custom' ? customLanguageInput.value.trim() : languageSelect.value;
            const tone = toneSelect.value === 'custom' ? customToneInput.value.trim() : toneSelect.value;
            const customSpecs = customSpecsInput.value.trim();

            const prompt = `Generate a detailed article structure/outline for the keyword: "${keyword}".
            - Language: ${language}
            - Tone: ${tone}
            ${customSpecs ? `- Other Specifications: ${customSpecs}` : ''}
            - The structure should be logical and cover the topic comprehensively.
            - Output only the structure, using clear headings or bullet points (like Section 1: ..., - Point A, - Point B). No introductory or concluding remarks about the structure itself.`;

            logToConsole(`--- Generating Structure Prompt ---\n${prompt}\n---------------------------------`);
            const structure = await callAI(prompt, structureLoadingIndicator, generateStructureBtn);

            if (structure) {
                articleStructureTextarea.value = structure;
                step2Section.classList.remove('hidden');
                structureContainer.classList.remove('hidden');
                toggleStructureVisibilityBtn.textContent = 'Hide';
                step3Section.classList.add('hidden');
                step4Section.classList.add('hidden');
            }
        });

        // Step 2 -> Step 3: Generate Article
        generateArticleBtn.addEventListener('click', async () => {
            const structure = articleStructureTextarea.value.trim();
            if (!structure) {
                alert('Article structure is empty. Please generate or edit the structure.');
                return;
            }

            const keyword = keywordInput.value.trim();
            const language = languageSelect.value === 'custom' ? customLanguageInput.value.trim() : languageSelect.value;
            const tone = toneSelect.value === 'custom' ? customToneInput.value.trim() : toneSelect.value;
            const format = formatSelect.value;
            const customSpecs = customSpecsInput.value.trim();

            const prompt = `Generate a full article based on the following structure and specifications:
            - Keyword: "${keyword}"
            - Language: ${language}
            - Tone: ${tone}
            - Output Format: ${format}
            ${customSpecs ? `- Other Specifications: ${customSpecs}` : ''}

            Article Structure:
            ---
            ${structure}
            ---

            Instructions:
            - Write content for each section of the structure.
            - Ensure the article flows well and is coherent.
            - Adhere strictly to the requested output format (${format}).
            ${format === 'html' ? '- For HTML: Use only basic text formatting tags like <p>, <h1>-<h6>, <ul>, <ol>, <li>, <b>, <i>, <a>. Do NOT include <html>, <head>, <body>, or <div> tags.' : '- For Markdown: Use standard Markdown syntax.'}
            - Generate only the article content itself, without any introductory or concluding remarks about the generation process.`;

            logToConsole(`--- Generating Article Prompt ---\n${prompt}\n---------------------------------`);
            const article = await callAI(prompt, articleLoadingIndicator, generateArticleBtn);

            if (article) {
                generatedArticleTextarea.value = article;
                const isHtml = format === 'html';
                previewHtmlCheckbox.checked = false;
                previewHtmlCheckbox.disabled = !isHtml;
                previewHtmlCheckbox.parentElement.classList.toggle('hidden', !isHtml);
                generatedArticleTextarea.classList.remove('hidden');
                htmlPreviewDiv.classList.add('hidden');
                htmlPreviewDiv.innerHTML = '';

                step3Section.classList.remove('hidden');
                step4Section.classList.add('hidden');
            }
        });

        // Toggle Structure Visibility
        toggleStructureVisibilityBtn.addEventListener('click', () => {
            const isHidden = structureContainer.classList.toggle('hidden');
            toggleStructureVisibilityBtn.textContent = isHidden ? 'Show' : 'Hide';
        });

         // HTML Preview Toggle
        previewHtmlCheckbox.addEventListener('change', () => {
            const showPreview = previewHtmlCheckbox.checked;
            generatedArticleTextarea.classList.toggle('hidden', showPreview);
            htmlPreviewDiv.classList.toggle('hidden', !showPreview);
            if (showPreview) {
                // Basic sanitization attempt (remove script tags) - a proper library is better
                let unsafeHTML = generatedArticleTextarea.value;
                let sanitizedHTML = unsafeHTML.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                htmlPreviewDiv.innerHTML = sanitizedHTML;
                 logToConsole("Showing HTML preview. Basic script tag removal applied.", "warn");
            }
        });

        // Step 3 -> Step 4: Enable Spinning
        enableSpinningBtn.addEventListener('click', () => {
            // Use the *current* content of the textarea, which might have been edited
            spunArticleDisplay.innerHTML = generatedArticleTextarea.value;
            step4Section.classList.remove('hidden');
            // Clear previous highlighting before applying new one
            spunArticleDisplay.querySelectorAll('.spintax-level-1, .spintax-level-2, .spintax-level-3, .spintax-pipe').forEach(el => {
                 // Replace span with its content
                 el.outerHTML = el.innerHTML;
            });
            highlightSpintax(spunArticleDisplay); // Highlight existing spintax if any
            logToConsole("Spinning enabled. Select text in the 'Spinnable Article' area.", 'info');

            // Hide Step 3 editing area and preview controls
            generatedArticleTextarea.classList.add('hidden');
            htmlPreviewDiv.classList.add('hidden');
            previewHtmlCheckbox.parentElement.classList.add('hidden'); // Hide the checkbox label too
            previewHtmlCheckbox.checked = false;
        });


        // --- Text Selection and Spinning Logic ---
        let selectedTextInfo = null; // Store { text: '...', range: Range }

        spunArticleDisplay.addEventListener('mouseup', handleSelection);
        spunArticleDisplay.addEventListener('keyup', handleSelection); // Handle selection changes via keyboard
        spunArticleDisplay.addEventListener('focus', handleSelection); // Re-check on focus

        function handleSelection() {
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                // Ensure selection is within our editable div and not empty
                if (spunArticleDisplay.contains(range.commonAncestorContainer) && !range.collapsed) {
                    const text = selection.toString().trim();
                    if (text.length > 0) {
                        selectedTextInfo = { text: text, range: range.cloneRange() }; // Store range
                        spinSelectedBtn.disabled = false;
                        // logToConsole(`Selected: "${text}"`); // Reduce log clutter
                        return;
                    }
                }
            }
            // If no valid selection or selection outside the target or empty
            selectedTextInfo = null;
            spinSelectedBtn.disabled = true;
        }


        spinSelectedBtn.addEventListener('click', async () => {
            if (!selectedTextInfo || !selectedTextInfo.text) {
                 logToConsole("Spin button clicked but no valid text selected.", "warn");
                 return;
            }

            const textToSpin = selectedTextInfo.text; // Use stored text
            const language = languageSelect.value === 'custom' ? customLanguageInput.value.trim() : languageSelect.value;
            const tone = toneSelect.value === 'custom' ? customToneInput.value.trim() : toneSelect.value;

            const prompt = `Take the following text and generate 2-4 variations that mean the same thing, suitable for spintax.
            - Language: ${language}
            - Tone: ${tone} (Maintain this tone)
            - Output Format: Return ONLY the spintax string in the format {original|variation1|variation2|...}. Do not include the original text you were given unless it's one of the variations. Do not include any explanation or surrounding text.

            Text to Spin:
            ---
            ${textToSpin}
            ---`;

            logToConsole(`--- Spinning Text Prompt ---\n${prompt}\n---------------------------------`);
            const spintaxResult = await callAI(prompt, spinActionLoadingIndicator, spinSelectedBtn); // Pass button to disable

            if (spintaxResult) {
                // --- Replace Selection Logic using stored Range ---
                const selection = window.getSelection();
                if (selection && selectedTextInfo.range) {
                    try {
                         // Restore the selection using the stored range before inserting
                         selection.removeAllRanges();
                         selection.addRange(selectedTextInfo.range);

                         // Use insertHTML if available for better structure preservation, else fallback
                         if (document.queryCommandSupported('insertHTML')) {
                            document.execCommand('insertHTML', false, spintaxResult);
                         } else if (document.queryCommandSupported('insertText')) {
                             logToConsole("insertHTML not supported, using insertText (might lose formatting).", "warn");
                             document.execCommand('insertText', false, spintaxResult);
                         } else {
                             // Manual fallback (less reliable)
                             selectedTextInfo.range.deleteContents();
                             selectedTextInfo.range.insertNode(document.createTextNode(spintaxResult));
                         }

                        logToConsole(`Inserted spintax: ${spintaxResult}`, 'success');

                        // Re-highlight the entire content after modification
                         highlightSpintax(spunArticleDisplay);

                    } catch (e) {
                        logToConsole(`Error replacing selection with spintax: ${e}`, 'error');
                        alert("Error applying spintax. The content might not have updated correctly.");
                    } finally {
                         // Clear selection state after attempting replacement
                         selectedTextInfo = null;
                         spinSelectedBtn.disabled = true; // Disable button after use
                         selection.removeAllRanges(); // Deselect text
                    }
                } else {
                     logToConsole("Could not restore selection range to insert spintax.", 'error');
                     alert("Could not apply spintax. Please try selecting the text again.");
                     spinSelectedBtn.disabled = true;
                }
            } else {
                 // callAI already showed an error, just disable button
                 spinSelectedBtn.disabled = true;
            }
        });


        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            populateModels(); // Populate models for the default provider
            logToConsole("App initialized (v2). Ready for input.", 'info');
            logToConsole("Remember: API calls are made directly from your browser. Ensure you trust the source of this code and understand the security implications of handling API keys this way.", 'warn');
        });

    </script>

</body>
</html>
