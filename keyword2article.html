<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Article Generator ✍️</title>
    <style>
        /* Basic CSS Styling here */
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        h1 { color: #333; text-align: center; margin-bottom: 20px; }
        label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; font-size: 0.9em; } /* Reduced label font size */
        p { color: #777; margin-bottom: 8px; }
        input[type="text"], textarea { width: calc(100% - 18px); padding: 8px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; font-family: inherit; }
        textarea { height: 100px; resize: vertical; }
        input[type="text"] { height: 30px; } /* Adjusted text input height */
        button { padding: 8px 16px; cursor: pointer; border-radius: 5px; background-color: #f0f0f0; border: 1px solid #ccc; font-family: inherit; } /* Reduced button padding */
        button:hover { background-color: #e0e0e0; }
        #api-key-area, #keyword-area, #progress-area, #cards-container { margin-bottom: 20px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #api-key-area label, #keyword-area label, #progress-area label { margin-bottom: 10px; display: block; }
        #api-key { width: calc(100% - 18px); padding: 8px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; font-family: monospace; }
        #keywords { width: calc(100% - 18px); height: 150px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; padding: 8px; font-family: monospace; }
        #custom-instruction { width: calc(100% - 18px); padding: 8px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; font-family: inherit; }
        .keyword-input-row { display: flex; align-items: flex-start; gap: 15px; }
        .keyword-input-row > div { flex: 1; }
        #progress-bar-container { width: 100%; height: 20px; background-color: #eee; border-radius: 5px; overflow: hidden; margin-bottom: 10px; }
        #progress-bar { height: 100%; width: 0%; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s ease-in-out; }
        #progress-text { text-align: center; font-size: 0.9em; color: #555; }
        #cards-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
        .card { background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 5px; padding: 15px; }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .card-header h3 { margin: 0; font-size: 1.1em; color: #333; } /* Slightly smaller topic header */
        .regenerate-btn { background: none; border: none; font-size: 1em; cursor: pointer; margin-left: 5px; } /* Smaller regenerate button */
        .card textarea, .card input[type="text"] { width: calc(100% - 18px); margin-bottom: 5px; }
        .card textarea { height: 70px; } /* Reduced textarea height */
        .article-content-area { position: relative; }
        .article-content-area textarea { height: 120px; } /* Reduced article textarea height */
        .toggle-format-btn { position: absolute; top: 5px; right: 5px; padding: 5px 8px; font-size: 0.7em; } /* Smaller toggle button */
        .emoji-label { display: flex; align-items: center; gap: 5px; }
        .emoji { font-size: 1em; } /* Smaller emoji size */
        .hidden { display: none !important; }
        .status-area { margin-top: 10px; white-space: pre-wrap; height: 100px; overflow-y: scroll; border: 1px solid #ccc; padding: 8px; box-sizing: border-box; font-family: monospace; border-radius: 5px; background-color: #f9f9f9; font-size: 0.8em; }
        .input-row { display: flex; align-items: center; margin-bottom: 5px; }
        .input-row label { margin-right: 5px; margin-bottom: 0; }
        .input-row > div { flex: 1; display: flex; align-items: center; }
        .input-row > div input[type="text"], .input-row > div textarea { margin-bottom: 0; }
        .textarea-container { display: flex; align-items: center; }
    </style>
</head>
<body>
    <h1>AI Article Generator ✍️</h1>

    <div id="api-key-area">
        <label for="api-key" class="emoji-label"><span class="emoji">🔑</span> Gemini API Key:</label>
        <input type="text" id="api-key" placeholder="Enter your Gemini API key">
    </div>

    <div id="keyword-area">
        <div class="keyword-input-row">
            <div>
                <label for="keywords" class="emoji-label"><span class="emoji">📝</span> Keywords (one per line):</label>
                <textarea id="keywords" placeholder="Enter keywords here, one per line"></textarea>
            </div>
            <div>
                <label for="custom-instruction" class="emoji-label"><span class="emoji">⚙️</span> Custom Instructions (optional):</label>
                <textarea id="custom-instruction" placeholder="e.g., Write in a professional tone, target audience are beginners, etc."></textarea>
            </div>
        </div>
    </div>

    <div id="progress-area">
        <label class="emoji-label"><span class="emoji">📊</span> Generation Progress:</label>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <p id="progress-text">Waiting for keywords and API key...</p>
    </div>

    <div id="cards-container">
        <!-- Cards will be generated here -->
    </div>

    <div class="status-area" id="status-log" style="display: none;"></div>

    <script>
        const apiKeyInput = document.getElementById('api-key');
        const keywordsInput = document.getElementById('keywords');
        const customInstructionInput = document.getElementById('custom-instruction');
        const cardsContainer = document.getElementById('cards-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const statusLog = document.getElementById('status-log');

        let apiKey = localStorage.getItem('geminiApiKey') || '';
        apiKeyInput.value = apiKey;

        const models = {
            'Gemini 2.0 Flash-Lite Preview': { rpm: 30, tpm: 1000000, rpd: 1500, usageRPM: 0, usageTPM: 0, usageRPD: 0, lastReset: localStorage.getItem('usageResetDate_Gemini 2.0 Flash-Lite Preview') },
            'Gemini 2.0 Flash': { rpm: 15, tpm: 1000000, rpd: 1500, usageRPM: 0, usageTPM: 0, usageRPD: 0, lastReset: localStorage.getItem('usageResetDate_Gemini 2.0 Flash') },
            'Gemini 2.0 Flash Thinking Experimental 01-21': { rpm: 10, tpm: 4000000, rpd: 1500, usageRPM: 0, usageTPM: 0, usageRPD: 0, lastReset: localStorage.getItem('usageResetDate_Gemini 2.0 Flash Thinking Experimental 01-21') },
            'Gemini 2.0 Pro Experimental 02-05': { rpm: 2, tpm: 1000000, rpd: 50, usageRPM: 0, usageTPM: 0, usageRPD: 0, lastReset: localStorage.getItem('usageResetDate_Gemini 2.0 Pro Experimental 02-05') }
        };

        const modelNames = Object.keys(models);
        let currentModelName = 'Gemini 2.0 Flash-Lite Preview'; // Default model

        loadUsageData();
        resetDailyUsageIfNeeded();

        apiKeyInput.addEventListener('change', (e) => {
            apiKey = e.target.value;
            localStorage.setItem('geminiApiKey', apiKey);
            if (keywordsInput.value.trim() !== '') {
                processKeywords(); // Auto-start if keywords are already present
            }
        });

        keywordsInput.addEventListener('paste', handlePasteKeywords);
        keywordsInput.addEventListener('input', () => {
            if (apiKey && keywordsInput.value.trim() !== '') {
                processKeywords(); // Auto-start if API key is already present
            }
        });

        let pendingKeywords = null; // Store keywords if pasted before API key

        async function handlePasteKeywords(event) {
            event.preventDefault();
            const text = (event.clipboardData || window.clipboardData).getData('text');
            keywordsInput.value = text;
            if (apiKey) {
                processKeywords();
            } else {
                pendingKeywords = text; // Store keywords to process later
                alert("API Key needed. Please enter your Gemini API key to start generating.");
            }
        }

        async function processKeywords() {
            const keywords = keywordsInput.value.trim().split('\n').filter(keyword => keyword.trim() !== '');
            if (!keywords.length) {
                alert("Please enter keywords.");
                return;
            }
            if (!apiKey) {
                alert("Please enter your Gemini API Key.");
                return;
            }

            cardsContainer.innerHTML = '';
            progressText.textContent = `Generating...`;
            progressBar.style.width = '0%';
            let progress = { keywords: keywords.length, titles: 0, outlines: 0, articles: 0 };
            let startTime = Date.now();

            for (let i = 0; i < keywords.length; i++) {
                const keyword = keywords[i].trim();
                if (!keyword) continue;

                const card = createCard(keyword, i);
                cardsContainer.appendChild(card);

                const titleInput = card.querySelector('.article-title'); // Changed to input
                const outlineTextArea = card.querySelector('.article-outline');
                const articleTextArea = card.querySelector('.article-content');

                try {
                    const title = await generateContentWithRateLimit('Generate catchy article title about: ' + keyword, 'title');
                    titleInput.value = title;
                    progress.titles++;
                    updateProgress(progress, startTime);

                    const outline = await generateContentWithRateLimit('Generate detailed article outline for title: ' + title + ' about: ' + keyword, 'outline');
                    outlineTextArea.value = outline;
                    progress.outlines++;
                    updateProgress(progress, startTime);

                    const article = await generateContentWithRateLimit('Write a full article in HTML format based on title: ' + title + ', outline: ' + outline + ', topic: ' + keyword + '. ' + customInstructionInput.value, 'article');
                    articleTextArea.value = article;
                    articleTextArea.dataset.format = 'html'; // Store format
                    progress.articles++;
                    updateProgress(progress, startTime);

                } catch (error) {
                    console.error("Error generating content:", error);
                    logStatus(`Error for keyword "${keyword}": ${error.message}`);
                    titleInput.value = "Error generating title.";
                    outlineTextArea.value = "Error generating outline.";
                    articleTextArea.value = "Error generating article.";
                }
            }

            progressText.textContent = `Generation complete!`;
        }

        function updateProgress(progress, startTime) {
            const totalKeywords = progress.keywords;
            const generatedTitles = progress.titles;
            const generatedOutlines = progress.outlines;
            const generatedArticles = progress.articles;

            const percentTitles = (generatedTitles / totalKeywords) * 100;
            const percentOutlines = (generatedOutlines / totalKeywords) * 100;
            const percentArticles = (generatedArticles / totalKeywords) * 100;
            const overallPercent = ((percentTitles + percentOutlines + percentArticles) / 3);

            progressBar.style.width = `${overallPercent}%`;
            const elapsedTimeSeconds = (Date.now() - startTime) / 1000;
            const estimatedTotalTimeSeconds = (generatedArticles > 0) ? (elapsedTimeSeconds / (generatedArticles / totalKeywords)) : 'Estimating...';
            const estimatedRemainingTime = isNaN(estimatedTotalTimeSeconds) || estimatedTotalTimeSeconds === 'Estimating...' ? 'Estimating...' : formatTime(Math.max(0, estimatedTotalTimeSeconds - elapsedTimeSeconds));


            progressText.textContent = `${totalKeywords} keywords | ${generatedTitles} / ${totalKeywords} titles | ${generatedOutlines} / ${totalKeywords} outlines | ${generatedArticles} / ${totalKeywords} articles | Remaining time: ${estimatedRemainingTime}`;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}m ${remainingSeconds}s`;
        }


        function createCard(keyword, index) {
            const card = document.createElement('div');
            card.classList.add('card');
            card.dataset.keywordIndex = index;

            card.innerHTML = `
                <div class="card-header">
                    <h3><span class="emoji">📌</span> ${keyword}</h3>
                </div>
                <div class="input-row">
                    <div>
                        <label for="title-${index}" class="emoji-label"><span class="emoji">📰</span> Title:</label>
                        <div class="textarea-container">
                            <input type="text" class="article-title" id="title-${index}" placeholder="Article Title">
                            <button class="regenerate-btn" data-type="title" aria-label="Regenerate Title">🔄</button>
                        </div>
                    </div>
                </div>
                <div class="input-row">
                    <div>
                        <label for="outline-${index}" class="emoji-label"><span class="emoji">📝</span> Outline:</label>
                        <div class="textarea-container">
                            <textarea class="article-outline" id="outline-${index}" placeholder="Article Outline"></textarea>
                            <button class="regenerate-btn" data-type="outline" aria-label="Regenerate Outline">🔄</button>
                        </div>
                    </div>
                </div>
                <div class="input-row">
                    <div>
                        <label for="article-${index}" class="emoji-label"><span class="emoji">✍️</span> Content:</label>
                        <div class="article-content-area">
                            <textarea class="article-content" id="article-${index}" placeholder="Article Content"></textarea>
                            <button class="toggle-format-btn" data-target="article-${index}">HTML</button>
                        </div>
                    </div>
                </div>
            `;

            card.querySelectorAll('.regenerate-btn').forEach(button => {
                button.addEventListener('click', regenerateContent.bind(null, card, button.dataset.type));
            });

            const toggleButton = card.querySelector('.toggle-format-btn');
            toggleButton.addEventListener('click', toggleArticleFormat);

            return card;
        }

        async function regenerateContent(card, contentType) {
            const keyword = card.querySelector('.card-header h3').textContent.replace('📌 ', '');
            const titleInput = card.querySelector('.article-title'); // Changed to input
            const outlineTextArea = card.querySelector('.article-outline');
            const articleTextArea = card.querySelector('.article-content');
            const currentTitle = titleInput.value;
            const currentOutline = outlineTextArea.value;

            try {
                if (contentType === 'title') {
                    const newTitle = await generateContentWithRateLimit('Generate catchy article title about: ' + keyword, 'title');
                    titleInput.value = newTitle;
                    outlineTextArea.value = await generateContentWithRateLimit('Generate detailed article outline for title: ' + newTitle + ' about: ' + keyword, 'outline');
                } else if (contentType === 'outline') {
                    const newOutline = await generateContentWithRateLimit('Generate detailed article outline for title: ' + currentTitle + ' about: ' + keyword, 'outline');
                    outlineTextArea.value = newOutline;
                }
                if (contentType === 'title' || contentType === 'outline') { // Regenerate article if title or outline is regenerated
                    const newArticle = await generateContentWithRateLimit('Write a full article in HTML format based on title: ' + titleInput.value + ', outline: ' + outlineTextArea.value + ', topic: ' + keyword + '. ' + customInstructionInput.value, 'article');
                    articleTextArea.value = newArticle;
                    articleTextArea.dataset.format = 'html';
                    card.querySelector('.toggle-format-btn').textContent = 'HTML';
                }
            } catch (error) {
                console.error(`Error regenerating ${contentType}:`, error);
                logStatus(`Error regenerating ${contentType} for keyword "${keyword}": ${error.message}`);
                if (contentType === 'title') titleInput.value = "Error generating title.";
                if (contentType === 'outline') outlineTextArea.value = "Error generating outline.";
                if (contentType === 'article') articleTextArea.value = "Error generating article.";
            }
        }


        async function generateContentWithRateLimit(promptText, contentType) {
            let modelToUse = selectModel();
            if (!modelToUse) {
                logStatus("All models rate limited. Please wait.");
                throw new Error("Rate limit reached for all models."); // Stop processing if all models are limited
            }

            const modelDetails = models[modelToUse];
            const geminiAPIUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelToUse.toLowerCase().replace(/ /g, '-')}:generateContent?key=${apiKey}`;

            incrementUsage(modelToUse, 'rpm'); // Assume each call counts as 1 RPM and TPM for simplicity
            incrementUsage(modelToUse, 'tpm');

            logStatus(`[${modelToUse}] Generating ${contentType} with prompt: ${promptText.substring(0, 50)}...`);

            const requestBody = {
                contents: [{
                    parts: [{ text: promptText + ' ' + customInstructionInput.value }]
                }]
            };

            try {
                const response = await fetch(geminiAPIUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    if (response.status === 429) {
                        logStatus(`[${modelToUse}] Rate limit hit! Status: ${response.status} - ${response.statusText}`);
                        resetUsage(modelToUse, 'rpm'); // Reset RPM for immediate retry in simple implementation. For real app, implement proper retry/backoff.
                        // In a more robust app, you would implement a retry mechanism with backoff and potentially switch to another model here if available.
                        throw new Error(`[${modelToUse}] Rate limit error! Status: ${response.status}`);
                    } else {
                        const errorDetails = await response.json();
                        logStatus(`[${modelToUse}] API Error: ${response.status} - ${response.statusText} - ${JSON.stringify(errorDetails)}`);
                        throw new Error(`[${modelToUse}] HTTP error! status: ${response.status}, details: ${JSON.stringify(errorDetails)}`);
                    }
                }

                const data = await response.json();
                if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                    logStatus(`[${modelToUse}] Unexpected API response format: ${JSON.stringify(data)}`);
                    throw new Error(`[${modelToUse}] Unexpected API response format`);
                }

                const generatedText = data.candidates[0].content.parts[0].text.trim();
                logStatus(`[${modelToUse}] Generated ${contentType}: ${generatedText.substring(0, 100)}...`);
                return generatedText;

            } catch (error) {
                console.error("Error in generateContentWithRateLimit:", error);
                throw error; // Re-throw to be caught in processKeywords/regenerateContent
            }
        }


        function toggleArticleFormat(event) {
            const button = event.target;
            const targetTextAreaId = button.dataset.target;
            const textArea = document.getElementById(targetTextAreaId);
            let currentFormat = textArea.dataset.format || 'html';
            let newFormat = currentFormat === 'html' ? 'md' : 'html';
            textArea.dataset.format = newFormat;
            button.textContent = newFormat.toUpperCase();

            if (newFormat === 'md') {
                textArea.value = textArea.value.replace(/<p>/g, '\n').replace(/<\/p>/g, '').replace(/<[^>]*>/g, '');
            } else {
                textArea.value = textArea.value.replace(/\n/g, '<p>');
            }
        }

        function logStatus(message) {
            statusLog.style.display = 'block';
            statusLog.textContent += message + '\n';
            statusLog.scrollTop = statusLog.scrollHeight;
        }

        function selectModel() {
            // Simple model selection: prioritize 'Flash-Lite Preview', then 'Flash', then 'Thinking Experimental', then 'Pro Experimental'
            const priorityOrder = ['Gemini 2.0 Flash-Lite Preview', 'Gemini 2.0 Flash', 'Gemini 2.0 Flash Thinking Experimental 01-21', 'Gemini 2.0 Pro Experimental 02-05'];
            for (const modelName of priorityOrder) {
                if (models[modelName].usageRPM < models[modelName].rpm && models[modelName].usageRPD < models[modelName].rpd) {
                    return modelName;
                }
            }
            return null; // All models are rate limited
        }


        function incrementUsage(modelName, dimension) {
            if (dimension === 'rpm') models[modelName].usageRPM++;
            if (dimension === 'tpm') models[modelName].usageTPM++;
            if (dimension === 'rpd') models[modelName].usageRPD++;
            saveUsageData();
        }

        function resetUsage(modelName, dimension) {
            if (dimension === 'rpm') models[modelName].usageRPM = 0;
            if (dimension === 'tpm') models[modelName].usageTPM = 0;
            if (dimension === 'rpd') models[modelName].usageRPD = 0;
            saveUsageData();
        }

        function saveUsageData() {
            modelNames.forEach(modelName => {
                localStorage.setItem(`usageRPM_${modelName}`, models[modelName].usageRPM);
                localStorage.setItem(`usageTPM_${modelName}`, models[modelName].usageTPM);
                localStorage.setItem(`usageRPD_${modelName}`, models[modelName].usageRPD);
            });
        }

        function loadUsageData() {
            modelNames.forEach(modelName => {
                models[modelName].usageRPM = parseInt(localStorage.getItem(`usageRPM_${modelName}`) || '0');
                models[modelName].usageTPM = parseInt(localStorage.getItem(`usageTPM_${modelName}`) || '0');
                models[modelName].usageRPD = parseInt(localStorage.getItem(`usageRPD_${modelName}`) || '0');
            });
        }

        function resetDailyUsageIfNeeded() {
            const today = new Date().toDateString();
            modelNames.forEach(modelName => {
                const lastResetDate = models[modelName].lastReset;
                if (lastResetDate !== today) {
                    models[modelName].usageRPM = 0;
                    models[modelName].usageTPM = 0;
                    models[modelName].usageRPD = 0;
                    models[modelName].lastReset = today;
                    localStorage.setItem('usageResetDate_' + modelName, today);
                    localStorage.setItem(`usageRPM_${modelName}`, '0');
                    localStorage.setItem(`usageTPM_${modelName}`, '0');
                    localStorage.setItem(`usageRPD_${modelName}`, '0');
                    logStatus(`Daily usage reset for ${modelName}`);
                }
            });
        }


        if (pendingKeywords) { // Process stored keywords if API key is now available on load
            processKeywords();
            pendingKeywords = null;
        }


    </script>
</body>
</html>
