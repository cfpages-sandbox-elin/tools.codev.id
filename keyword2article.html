<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Article Generator ‚úçÔ∏è</title>
    <style>
        /* Basic CSS Styling here */
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        h1 { color: #333; text-align: center; margin-bottom: 20px; }
        label { font-weight: bold; display: block; margin-bottom: 5px; color: #555; font-size: 0.9em; }
        p { color: #777; margin-bottom: 8px; }
        input[type="text"], textarea, select { width: calc(100% - 18px); padding: 8px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; font-family: inherit; }
        textarea { height: 100px; resize: vertical; }
        input[type="text"] { height: 30px; }
        button { padding: 8px 16px; cursor: pointer; border-radius: 5px; background-color: #f0f0f0; border: 1px solid #ccc; font-family: inherit; }
        button:hover { background-color: #e0e0e0; }
        #api-provider-area, #api-key-area-container { margin-bottom: 20px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #api-provider-area label, #api-key-area-container label { margin-bottom: 10px; display: block; }
        .api-key-input-area { margin-bottom: 15px; }
        .api-key-input-area label { margin-bottom: 5px; }
        .api-key-input { width: calc(100% - 18px); padding: 8px; margin-bottom: 5px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; font-family: monospace; }
        .api-key-status { font-size: 0.8em; margin-top: 2px; margin-bottom: 10px; display: block; }
        .api-key-status.success { color: green; }
        .api-key-status.error { color: red; }
        #keyword-area, #progress-area, #cards-container { margin-bottom: 20px; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #keyword-area label, #progress-area label { margin-bottom: 10px; display: block; }
        #keywords { width: calc(100% - 18px); height: 150px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; padding: 8px; font-family: monospace; }
        #custom-instruction { width: calc(100% - 18px); padding: 8px; margin-bottom: 10px; box-sizing: border-box; border-radius: 5px; border: 1px solid #ccc; font-family: inherit; }
        .keyword-input-row { display: flex; align-items: flex-start; gap: 15px; }
        .keyword-input-row > div { flex: 1; }
        #progress-bar-container { width: 100%; height: 20px; background-color: #eee; border-radius: 5px; overflow: hidden; margin-bottom: 10px; }
        #progress-bar { height: 100%; width: 0%; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s ease-in-out; }
        #progress-text { text-align: center; font-size: 0.9em; color: #555; }
        #cards-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }
        .card { background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 5px; padding: 15px; }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .card-header h3 { margin: 0; font-size: 1.1em; color: #333; }
        .regenerate-btn { background: none; border: none; font-size: 1em; cursor: pointer; margin-left: 5px; position: absolute; top: 5px; right: 5px; opacity: 0.5; transition: opacity 0.3s; } /* Floating button, initially semi-transparent */
        .regenerate-btn:hover { opacity: 1; } /* Full opacity on hover */
        .card textarea, .card input[type="text"] { width: calc(100% - 18px); margin-bottom: 5px; }
        .card textarea { height: 70px; }
        .article-content-area { position: relative; }
        .article-content-area textarea { height: 120px; }
        .toggle-format-btn { position: absolute; top: 5px; right: 5px; padding: 5px 8px; font-size: 0.7em; }
        .emoji-label { display: flex; align-items: center; gap: 5px; }
        .emoji { font-size: 1em; }
        .hidden { display: none !important; }
        .status-area { margin-top: 10px; white-space: pre-wrap; height: 100px; overflow-y: scroll; border: 1px solid #ccc; padding: 8px; box-sizing: border-box; font-family: monospace; border-radius: 5px; background-color: #f9f9f9; font-size: 0.8em; }
        .input-row { display: flex; align-items: center; margin-bottom: 5px; position: relative; } /* Relative positioning for input rows */
        .input-row > div { flex: 1; display: flex; align-items: center; }
        .input-row > div input[type="text"], .input-row > div textarea { margin-bottom: 0; }
        .textarea-container { display: flex; align-items: center; }
        .checkbox-row { display: flex; align-items: center; margin-bottom: 5px; font-size: 0.9em; }
        .checkbox-row input[type="checkbox"] { width: auto; margin-right: 5px; }
    </style>
</head>
<body>
    <h1>‚úçÔ∏è AI Article Generator v2.0</h1>

    <div id="api-provider-area">
        <label for="api-provider-select" class="emoji-label"><span class="emoji">ü§ñ</span> Select AI Provider:</label>
        <select id="api-provider-select">
            <option value="gemini">Gemini</option>
            <option value="openai">OpenAI</option>
            <option value="grok">Grok</option>
            <option value="claude">Claude</option>
            <option value="deepseek">DeepSeek</option>
        </select>
    </div>

    <div id="api-key-area-container">
        <div id="gemini-api-key-area" class="api-key-input-area">
            <label for="gemini-api-key" class="emoji-label"><span class="emoji">üîë</span> Gemini API Key:</label>
            <input type="text" id="gemini-api-key" class="api-key-input" placeholder="Enter your Gemini API key">
            <span id="gemini-api-key-status" class="api-key-status"></span>
        </div>

        <div id="openai-api-key-area" class="api-key-input-area hidden">
            <label for="openai-api-key" class="emoji-label"><span class="emoji">üîë</span> OpenAI API Key:</label>
            <input type="text" id="openai-api-key" class="api-key-input" placeholder="Enter your OpenAI API key">
            <div class="checkbox-row">
                <input type="checkbox" id="openai-batch-api-enabled">
                <label for="openai-batch-api-enabled" class="emoji-label"><span class="emoji">üì¶</span> Batch API Enabled (OpenAI)</label>
            </div>
            <span id="openai-api-key-status" class="api-key-status"></span>
        </div>

        <div id="grok-api-key-area" class="api-key-input-area hidden">
            <label for="grok-api-key" class="emoji-label"><span class="emoji">üîë</span> Grok API Key:</label>
            <input type="text" id="grok-api-key" class="api-key-input" placeholder="Enter your Grok API key">
            <span id="grok-api-key-status" class="api-key-status"></span>
        </div>

        <div id="claude-api-key-area" class="api-key-input-area hidden">
            <label for="claude-api-key" class="emoji-label"><span class="emoji">üîë</span> Claude API Key:</label>
            <input type="text" id="claude-api-key" class="api-key-input" placeholder="Enter your Claude API key">
            <span id="claude-api-key-status" class="api-key-status"></span>
        </div>

        <div id="deepseek-api-key-area" class="api-key-input-area hidden">
            <label for="deepseek-api-key" class="emoji-label"><span class="emoji">üîë</span> DeepSeek API Key:</label>
            <input type="text" id="deepseek-api-key" class="api-key-input" placeholder="Enter your DeepSeek API key">
            <span id="deepseek-api-key-status" class="api-key-status"></span>
        </div>
    </div>

    <div id="keyword-area">
        <div class="keyword-input-row">
            <div>
                <label for="keywords" class="emoji-label"><span class="emoji">üìù</span> Keywords (one per line):</label>
                <textarea id="keywords" placeholder="Enter keywords here, one per line"></textarea>
            </div>
            <div>
                <label for="custom-instruction" class="emoji-label"><span class="emoji">‚öôÔ∏è</span> Custom Instructions (optional):</label>
                <textarea id="custom-instruction" placeholder="e.g., Write in a professional tone, target audience are beginners, etc."></textarea>
            </div>
        </div>
    </div>

    <div id="progress-area">
        <label class="emoji-label"><span class="emoji">üìä</span> Generation Progress:</label>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <p id="progress-text">Waiting for keywords and API key...</p>
    </div>

    <div id="cards-container">
        <!-- Cards will be generated here -->
    </div>

    <div class="status-area" id="status-log" style="display: none;"></div>

    <script src="https://cdn.jsdelivr.net/npm/@anthropic-ai/sdk@latest/browser.js"></script>
    <script src="https://cdn.openai.com/openai-js/4/openai-beta.mjs"></script>
    <script>
        const apiProviderSelect = document.getElementById('api-provider-select');
        const apiKeyInputAreas = {
            gemini: document.getElementById('gemini-api-key-area'),
            openai: document.getElementById('openai-api-key-area'),
            grok: document.getElementById('grok-api-key-area'),
            claude: document.getElementById('claude-api-key-area'),
            deepseek: document.getElementById('deepseek-api-key-area')
        };
        const apiKeyInputs = {
            gemini: document.getElementById('gemini-api-key'),
            openai: document.getElementById('openai-api-key'),
            grok: document.getElementById('grok-api-key'),
            claude: document.getElementById('claude-api-key'),
            deepseek: document.getElementById('deepseek-api-key')
        };
        const apiKeyStatuses = {
            gemini: document.getElementById('gemini-api-key-status'),
            openai: document.getElementById('openai-api-key-status'),
            grok: document.getElementById('grok-api-key-status'),
            claude: document.getElementById('claude-api-key-status'),
            deepseek: document.getElementById('deepseek-api-key-status')
        };
        const openaiBatchApiEnabledCheckbox = document.getElementById('openai-batch-api-enabled');

        const keywordsInput = document.getElementById('keywords');
        const customInstructionInput = document.getElementById('custom-instruction');
        const cardsContainer = document.getElementById('cards-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const statusLog = document.getElementById('status-log');

        let currentProvider = localStorage.getItem('currentProvider') || 'gemini';
        apiProviderSelect.value = currentProvider;
        showApiKeyInputArea(currentProvider);

        let apiKeys = {
            gemini: localStorage.getItem('geminiApiKey') || '',
            openai: localStorage.getItem('openaiApiKey') || '',
            grok: localStorage.getItem('grokApiKey') || '',
            claude: localStorage.getItem('claudeApiKey') || '',
            deepseek: localStorage.getItem('deepseekApiKey') || ''
        };

        apiKeyInputs.gemini.value = apiKeys.gemini;
        apiKeyInputs.openai.value = apiKeys.openai;
        apiKeyInputs.grok.value = apiKeys.grok;
        apiKeyInputs.claude.value = apiKeys.claude;
        apiKeyInputs.deepseek.value = apiKeys.deepseek;

        const models = {
            gemini: {
                'gemini-2.0-flash-lite-preview-02-05': { displayName: 'Flash-Lite Preview', maxRpm: 30, maxTpm: 1000000, rpd: 1500, modelId: 'gemini-2.0-flash-lite-preview-02-05', priority: 1 },
                'gemini-2.0-flash': { displayName: 'Flash', maxRpm: 15, maxTpm: 1000000, rpd: 1500, modelId: 'gemini-2.0-flash', priority: 2 }
            },
            openai: {
                'gpt-4o-mini': { displayName: 'GPT-4o Mini', maxRpm: 500, maxTpm: 30000, modelId: 'gpt-4o-mini', priority: 1 }
            },
            grok: {
                'grok-2-latest': { displayName: 'Grok-2', maxRpm: 100, modelId: 'grok-2-latest', priority: 1 }
            },
            claude: {
                'claude-3-5-sonnet-20241022': { displayName: 'Claude 3.5 Sonnet', maxRpm: 100, modelId: 'claude-3-5-sonnet-20241022', priority: 1 }
            },
            deepseek: {
                'deepseek-chat': { displayName: 'DeepSeek Chat', maxRpm: 999999, modelId: 'deepseek-chat', priority: 1 }
            }
        };

        let processQueue = [];
        let isProcessing = false;
        let retryCounts = {};
        let batchJobId = null;

        apiProviderSelect.addEventListener('change', function() {
            currentProvider = this.value;
            localStorage.setItem('currentProvider', currentProvider);
            showApiKeyInputArea(currentProvider);
        });

        function showApiKeyInputArea(provider) {
            Object.keys(apiKeyInputAreas).forEach(key => {
                apiKeyInputAreas[key].classList.add('hidden');
            });
            apiKeyInputAreas[provider].classList.remove('hidden');
            testApiKey(provider);
        }

        Object.keys(apiKeyInputs).forEach(provider => {
            apiKeyInputs[provider].addEventListener('change', (e) => {
                apiKeys[provider] = e.target.value;
                localStorage.setItem(`${provider}ApiKey`, apiKeys[provider]);
                testApiKey(provider);
                if (keywordsInput.value.trim() !== '') {
                    processKeywords();
                }
            });
        });

        async function testApiKey(provider) {
            const apiKey = apiKeys[provider];
            const statusElement = apiKeyStatuses[provider];
            if (!apiKey) {
                statusElement.textContent = 'API key not entered.';
                statusElement.className = 'api-key-status error';
                return;
            }

            statusElement.textContent = 'Testing API key...';
            statusElement.className = 'api-key-status';

            let testResult = false;
            let errorMessage = 'Error testing API key.';

            try {
                let response;
                if (provider === 'gemini') {
                    response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: "Are you ready? answer promptly" }] }] }) });
                } else if (provider === 'openai') {
                    const openai = new OpenAI({ apiKey: apiKey, dangerouslyAllowBrowser: true }); //`dangerouslyAllowBrowser: true` is needed for browser environment
                    const completion = await openai.chat.completions.create({ model: "gpt-4o-mini", messages: [{ role: "user", content: "Are you ready? answer promptly" }], max_tokens: 5 });
                    if (completion.choices && completion.choices.length > 0) testResult = true;
                } else if (provider === 'grok') {
                    response = await fetch('https://api.x.ai/v1/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ messages: [{ role: "user", content: "Are you ready? answer promptly" }], model: "grok-2-latest", stream: false, temperature: 0 }) });
                } else if (provider === 'claude') {
                    const anthropic = new Anthropic({ apiKey: apiKey, dangerouslyAllowBrowser: true }); //`dangerouslyAllowBrowser: true` is needed for browser environment
                    const msg = await anthropic.messages.create({ model: "claude-3-5-sonnet-20241022", max_tokens: 5, messages: [{ role: "user", content: "Are you ready? answer promptly" }] });
                    if (msg.content && msg.content.length > 0) testResult = true;
                } else if (provider === 'deepseek') {
                    response = await fetch('https://api.deepseek.com/chat/completions', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: "deepseek-chat", messages: [{ role: "user", content: "Are you ready? answer promptly" }], stream: false }) });
                }

                if (response && response.ok) {
                    testResult = true;
                } else if (response) {
                    const errorData = await response.json();
                    errorMessage = `${provider.charAt(0).toUpperCase() + provider.slice(1)} API test failed: ${response.status} ${response.statusText} - ${errorData.error?.message || JSON.stringify(errorData)}`;
                }

            } catch (error) { errorMessage = `${provider.charAt(0).toUpperCase() + provider.slice(1)} API test error: ${error.message || error.toString()}`; }


            if (testResult) {
                statusElement.textContent = 'API key is valid. ‚úÖ';
                statusElement.className = 'api-key-status success';
            } else {
                statusElement.textContent = errorMessage;
                statusElement.className = 'api-key-status error';
            }
        }


        async function processKeywords() {
            const keywords = keywordsInput.value.trim().split('\n').filter(keyword => keyword.trim() !== '');
            if (!keywords.length) {
                alert("Please enter keywords.");
                return;
            }
            if (!apiKeys[currentProvider]) {
                alert(`Please enter your ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} API Key.`);
                return;
            }

            cardsContainer.innerHTML = '';
            progressText.textContent = `Queuing keywords for generation...`;
            progressBar.style.width = '0%';
            let progress = { keywords: keywords.length, titles: 0, outlines: 0, articles: 0 };
            let startTime = Date.now();
            processQueue = [];
            retryCounts = {};
            batchJobId = null;

            if (currentProvider === 'openai' && openaiBatchApiEnabledCheckbox.checked) {
                await processKeywordsBatchOpenAI(keywords, progress, startTime);
            } else {
                keywords.forEach((keyword, index) => {
                    if (keyword.trim()) {
                        const card = createCard(keyword.trim(), index);
                        cardsContainer.appendChild(card);
                        processQueue.push({ keyword: keyword.trim(), card, progressIndex: index });
                        retryCounts[keyword.trim()] = { title: 0, outline: 0, article: 0 };
                    }
                });

                if (!isProcessing) {
                    processNextInQueue(progress, startTime);
                }
            }
        }

        async function processKeywordsBatchOpenAI(keywords, progress, startTime) {
            logStatus("Preparing OpenAI Batch API request...");
            progressText.textContent = `Preparing OpenAI Batch API request...`;
            const batchRequests = keywords.map((keyword, index) => ({
                custom_id: `request-${index + 1}`,
                method: "POST",
                url: "/v1/chat/completions",
                body: {
                    model: models.openai['gpt-4o-mini'].modelId, // Use gpt-4o-mini for batch API
                    messages: [
                        { role: "user", content: `Generate article title, outline, and article for keyword: ${keyword}. Custom instructions: ${customInstructionInput.value}` }
                    ],
                    max_tokens: 1500 // Adjust max_tokens as needed
                }
            }));

            const jsonlData = batchRequests.map(request => JSON.stringify(request)).join('\n');
            const blob = new Blob([jsonlData], { type: 'application/jsonl' });
            const file = new File([blob], "batch_input.jsonl");

            try {
                logStatus("Uploading batch input file to OpenAI...");
                progressText.textContent = `Uploading batch input file to OpenAI...`;
                const openai = new OpenAI({ apiKey: apiKeys.openai, dangerouslyAllowBrowser: true });
                const fileResponse = await openai.files.create({ file: file, purpose: "batch" });
                const fileId = fileResponse.id;

                logStatus(`File uploaded successfully, file ID: ${fileId}. Creating batch...`);
                progressText.textContent = `Creating batch job...`;
                const batchResponse = await openai.batches.create({
                    input_file_id: fileId,
                    endpoint: "/v1/chat/completions",
                    completion_window: "24h"
                });
                batchJobId = batchResponse.id;
                localStorage.setItem('openaiBatchJobId', batchJobId);
                logStatus(`Batch job created successfully, Batch ID: ${batchJobId}. OpenAI is processing in the background. You can close this app and check back later using the Batch ID.`);
                progressText.textContent = `OpenAI Batch Job ID: ${batchJobId}. Processing in background.`;
                alert(`OpenAI Batch Job started with ID: ${batchJobId}. Results will be available later. You can close this app.`);

            } catch (error) {
                console.error("Error processing OpenAI Batch API:", error);
                logStatus(`Error processing OpenAI Batch API: ${error.message}`);
                progressText.textContent = `Error creating OpenAI Batch Job. See status log.`;
                alert(`Error creating OpenAI Batch Job. See status log for details.`);
            } finally {
                isProcessing = false;
            }
        }


        async function processNextInQueue(progress, startTime) {
            if (processQueue.length === 0) {
                isProcessing = false;
                progressText.textContent = `Generation complete!`;
                return;
            }
            isProcessing = true;
            const task = processQueue.shift();
            const { keyword, card, progressIndex } = task;

            const titleInput = card.querySelector('.article-title');
            const outlineTextArea = card.querySelector('.article-outline');
            const articleTextArea = card.querySelector('.article-content');

            try {
                const title = await generateContentWithRateLimit(keyword, 'title', retryCounts[keyword].title);
                titleInput.value = title;
                progress.titles++;
                updateProgress(progress, startTime);
                await delay(calculateDelay());

                const outline = await generateContentWithRateLimit(keyword, 'outline', retryCounts[keyword].outline, title);
                outlineTextArea.value = outline;
                progress.outlines++;
                updateProgress(progress, startTime);
                await delay(calculateDelay());

                const article = await generateContentWithRateLimit(keyword, 'article', retryCounts[keyword].article, title, outlineTextArea.value);
                articleTextArea.value = article;
                articleTextArea.dataset.format = 'html';
                progress.articles++;
                updateProgress(progress, startTime);
                await delay(calculateDelay());


            } catch (error) {
                console.error("Error generating content:", error);
                logStatus(`Error for keyword "${keyword}": ${error.message}`);
                titleInput.value = "Error generating title.";
                outlineTextArea.value = "Error generating outline.";
                articleTextArea.value = "Error generating article.";
            } finally {
                processNextInQueue(progress, startTime);
            }
        }

        function calculateDelay() {
            const currentModel = models[currentProvider]?.[Object.keys(models[currentProvider])[0]];
            const rpm = currentModel?.maxRpm || 30;
            const minDelay = (60000 / rpm) * 1.1;
            return minDelay;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }


        function updateProgress(progress, startTime) {
            const totalKeywords = progress.keywords;
            const generatedTitles = progress.titles;
            const generatedOutlines = progress.outlines;
            const generatedArticles = progress.articles;

            const percentTitles = (generatedTitles / totalKeywords) * 100;
            const percentOutlines = (generatedOutlines / totalKeywords) * 100;
            const percentArticles = (generatedArticles / totalKeywords) * 100;
            const overallPercent = ((percentTitles + percentOutlines + percentArticles) / 3);

            progressBar.style.width = `${overallPercent}%`;
            const elapsedTimeSeconds = (Date.now() - startTime) / 1000;
            const estimatedTotalTimeSeconds = (generatedArticles > 0) ? (elapsedTimeSeconds / (generatedArticles / totalKeywords)) * totalKeywords : 'Estimating...';
            const estimatedRemainingTime = isNaN(estimatedTotalTimeSeconds) || estimatedTotalTimeSeconds === 'Estimating...' ? 'Estimating...' : formatTime(Math.max(0, estimatedTotalTimeSeconds - elapsedTimeSeconds));


            progressText.textContent = `${totalKeywords} keywords | ${generatedTitles} / ${totalKeywords} titles | ${generatedOutlines} / ${totalKeywords} outlines | ${generatedArticles} / ${totalKeywords} articles | Remaining time: ${estimatedRemainingTime}`;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}m ${remainingSeconds}s`;
        }


        function createCard(keyword, index) {
            const card = document.createElement('div');
            card.classList.add('card');
            card.dataset.keywordIndex = index;

            card.innerHTML = `
                <div class="card-header">
                    <h3><span class="emoji">üìå</span> ${keyword}</h3>
                </div>
                <div class="input-row" title="Article Title">
                    <div>
                        <span class="emoji" title="Article Title">üì∞</span>
                        <input type="text" class="article-title" id="title-${index}" placeholder="Article Title">
                        <button class="regenerate-btn" data-type="title" aria-label="Regenerate Title">üîÑ</button>
                    </div>
                </div>
                <div class="input-row" title="Article Outline">
                    <div>
                        <span class="emoji" title="Article Outline">üìù</span>
                        <textarea class="article-outline" id="outline-${index}" placeholder="Article Outline"></textarea>
                        <button class="regenerate-btn" data-type="outline" aria-label="Regenerate Outline">üîÑ</button>
                    </div>
                </div>
                <div class="input-row" title="Article Content">
                    <div>
                        <span class="emoji" title="Article Content">‚úçÔ∏è</span>
                        <div class="article-content-area">
                            <textarea class="article-content" id="article-${index}" placeholder="Article Content"></textarea>
                            <button class="toggle-format-btn" data-target="article-${index}">HTML</button>
                        </div>
                    </div>
                </div>
            `;

            card.querySelectorAll('.regenerate-btn').forEach(button => {
                button.addEventListener('click', regenerateContent.bind(null, card, button.dataset.type));
            });

            const toggleButton = card.querySelector('.toggle-format-btn');
            toggleButton.addEventListener('click', toggleArticleFormat);

            return card;
        }

        async function regenerateContent(card, contentType) {
            const keyword = card.querySelector('.card-header h3').textContent.replace('üìå ', '');
            const titleInput = card.querySelector('.article-title');
            const outlineTextArea = card.querySelector('.article-outline');
            const articleTextArea = card.querySelector('.article-content');
            const currentTitle = titleInput.value;
            const currentOutline = outlineTextArea.value;

            try {
                if (contentType === 'title') {
                    const newTitle = await generateContentWithRateLimit(keyword, 'title', retryCounts[keyword].title);
                    titleInput.value = newTitle;
                    outlineTextArea.value = await generateContentWithRateLimit(keyword, 'outline', retryCounts[keyword].outline, newTitle);
                } else if (contentType === 'outline') {
                    const newOutline = await generateContentWithRateLimit(keyword, 'outline', retryCounts[keyword].outline, currentTitle);
                    outlineTextArea.value = newOutline;
                }
                if (contentType === 'title' || contentType === 'outline') {
                    const newArticle = await generateContentWithRateLimit(keyword, 'article', retryCounts[keyword].article, titleInput.value, outlineTextArea.value);
                    articleTextArea.value = newArticle;
                    articleTextArea.dataset.format = 'html';
                    card.querySelector('.toggle-format-btn').textContent = 'HTML';
                }
            } catch (error) {
                console.error(`Error regenerating ${contentType}:`, error);
                logStatus(`Error regenerating ${contentType} for keyword "${keyword}": ${error.message}`);
                if (contentType === 'title') titleInput.value = "Error generating title.";
                if (contentType === 'outline') outlineTextArea.value = "Error generating outline.";
                if (contentType === 'article') articleTextArea.value = "Error generating article.";
            }
        }


        async function generateContentWithRateLimit(keyword, contentType, retryAttempt, currentTitle = '', currentOutline = '') {
            const provider = currentProvider;
            const apiKey = apiKeys[provider];
            const modelConfig = selectModelForProvider(provider);
            if (!modelConfig) {
                logStatus(`No model available for provider: ${provider}`);
                throw new Error(`No model available for provider: ${provider}`);
            }
            const modelId = modelConfig.modelId;

            let geminiAPIUrl, openaiAPIUrl, grokAPIUrl, claudeAPIUrl, deepseekAPIUrl, requestBody, promptText = '';

            if (contentType === 'title') promptText = 'Generate catchy article title about: ' + keyword;
            else if (contentType === 'outline') promptText = 'Generate detailed article outline for title: ' + currentTitle + ' about: ' + keyword;
            else if (contentType === 'article') promptText = 'Write a full article in HTML format based on title: ' + currentTitle + ', outline: ' + currentOutline + ', topic: ' + keyword + '. ' + customInstructionInput.value;


            incrementUsage(provider, modelId, 'rpm');

            logStatus(`[${provider.toUpperCase()}-${modelConfig.displayName}] Generating ${contentType} for "${keyword}" (Attempt ${retryAttempt + 1}) with prompt: ${promptText.substring(0, 50)}...`);

            try {
                let response;
                if (provider === 'gemini') {
                    geminiAPIUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`;
                    requestBody = { contents: [{ parts: [{ text: promptText + ' ' + customInstructionInput.value }] }] };
                    response = await fetch(geminiAPIUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });

                } else if (provider === 'openai') {
                    openaiAPIUrl = `https://api.openai.com/v1/chat/completions`;
                    const openai = new OpenAI({ apiKey: apiKey, dangerouslyAllowBrowser: true });
                    const completion = await openai.chat.completions.create({ model: modelId, messages: [{ role: "user", content: promptText + ' ' + customInstructionInput.value }], max_tokens: 1000 });
                    incrementUsage(provider, modelId, 'tpm', completion.usage.total_tokens);
                    return completion.choices[0].message.content.trim();


                } else if (provider === 'grok') {
                    grokAPIUrl = `https://api.x.ai/v1/chat/completions`;
                    requestBody = { messages: [{ role: "user", content: promptText + ' ' + customInstructionInput.value }], model: modelId, stream: false, temperature: 0 };
                    response = await fetch(grokAPIUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify(requestBody) });

                } else if (provider === 'claude') {
                    claudeAPIUrl = `https://api.anthropic.com/v1/messages`;
                    const anthropic = new Anthropic({ apiKey: apiKey, dangerouslyAllowBrowser: true });
                    const msg = await anthropic.messages.create({ model: modelId, max_tokens: 8192, messages: [{ role: "user", content: promptText + ' ' + customInstructionInput.value }] });
                    incrementUsage(provider, modelId, 'tpm');
                    return msg.content[0].text.trim();


                } else if (provider === 'deepseek') {
                    deepseekAPIUrl = `https://api.deepseek.com/chat/completions`;
                    requestBody = { model: modelId, messages: [{ role: "user", content: promptText + ' ' + customInstructionInput.value }], stream: false };
                    response = await fetch(deepseekAPIUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify(requestBody) });
                }


                if (response && response.ok) {
                    if (provider !== 'openai' && provider !== 'claude') {
                        const data = await response.json();
                        let generatedText = '';
                        if (provider === 'gemini') generatedText = data.candidates[0].content.parts[0].text.trim();
                        else if (provider === 'grok') generatedText = data.choices[0].message.content.trim();
                        else if (provider === 'deepseek') generatedText = data.choices[0].message.content.trim();

                        logStatus(`[${provider.toUpperCase()}-${modelConfig.displayName}] Generated ${contentType} for "${keyword}": ${generatedText.substring(0, 100)}...`);
                        return generatedText;
                    }

                } else if (response) {
                    incrementUsage(provider, modelId, 'rpm', 1, true);
                    if (response.status === 429) {
                        logStatus(`[${provider.toUpperCase()}-${modelConfig.displayName}] Rate limit hit for "${keyword}" - ${contentType}! Status: ${response.status} - ${response.statusText}`);
                        const nextModelConfig = selectNextModel(modelId, provider);
                        if (nextModelConfig) {
                            logStatus(`Switching model to ${nextModelConfig.displayName}`);
                            return await generateContentWithRateLimit(keyword, contentType, retryAttempt + 1, currentTitle, currentOutline);
                        } else {
                            logStatus(`No more models available for provider ${provider} or all are rate limited.`);
                            throw new Error(`Rate limit reached for all models for provider ${provider}.`);
                        }

                    } else {
                        const errorDetails = await response.json();
                        logStatus(`[${provider.toUpperCase()}-${modelConfig.displayName}] API Error for "${keyword}" - ${contentType}: ${response.status} - ${response.statusText} - ${JSON.stringify(errorDetails)}`);
                        throw new Error(`HTTP error! status: ${response.status}, details: ${JSON.stringify(errorDetails)}`);
                    }
                }


            } catch (error) {
                console.error("Error in generateContentWithRateLimit:", error);
                throw error;
            }
        }


        function toggleArticleFormat(event) {
            const button = event.target;
            const targetTextAreaId = button.dataset.target;
            const textArea = document.getElementById(targetTextAreaId);
            let currentFormat = textArea.dataset.format || 'html';
            let newFormat = currentFormat === 'html' ? 'md' : 'html';
            textArea.dataset.format = newFormat;
            button.textContent = newFormat.toUpperCase();

            if (newFormat === 'md') {
                textArea.value = textArea.value.replace(/<p>/g, '\n').replace(/<\/p>/g, '').replace(/<[^>]*>/g, '');
            } else {
                textArea.value = textArea.value.replace(/\n/g, '<p>');
            }
        }

        function logStatus(message) {
            statusLog.style.display = 'block';
            statusLog.textContent += message + '\n';
            statusLog.scrollTop = statusLog.scrollHeight;
        }


        function selectModelForProvider(provider) {
            const providerModels = models[provider];
            if (!providerModels) return null;

            const modelKeys = Object.keys(providerModels);
            if (modelKeys.length === 0) return null;

            let bestModel = null;
            let bestPriority = Infinity;

            for (const modelName of modelKeys) {
                const model = providerModels[modelName];
                if (model.usageRPM < model.maxRpm && model.priority < bestPriority) {
                    bestModel = model;
                    bestPriority = model.priority;
                }
            }
            return bestModel;
        }


        function selectNextModel(currentModelId, provider) {
            const providerModels = models[provider];
            if (!providerModels) return null;

            const modelKeys = Object.keys(providerModels);
            const currentModelPriority = providerModels[currentModelId]?.priority;
            if (currentModelPriority === undefined) return null;

            let nextBestModel = null;
            let nextBestPriority = Infinity;

            for (const modelName of modelKeys) {
                const model = providerModels[modelName];
                if (model.priority > currentModelPriority && model.priority < nextBestPriority && model.usageRPM < model.maxRpm) {
                    nextBestModel = model;
                    nextBestPriority = model.priority;
                }
            }
            return nextBestModel;
        }


        function incrementUsage(provider, modelName, dimension, value = 1, isFailure = false) {
            if (!models[provider] || !models[provider][modelName]) return;

            if (dimension === 'rpm') models[provider][modelName].usageRPM += value;
            if (dimension === 'tpm') models[provider][modelName].usageTPM += value;
            if (dimension === 'rpd') models[provider][modelName].usageRPD += value;
        }

        function resetUsage(modelName, dimension) {
            // (No implementation yet)
        }
        function saveUsageData() {
            // (No implementation yet)
        }
        function loadUsageData() {
            // (No implementation yet)
        }
        function resetDailyUsageIfNeeded() {
            // (No implementation yet)
        }


        resetDailyUsageIfNeeded();
    </script>

</body>
</html>