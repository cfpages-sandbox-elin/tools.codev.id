<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML to PPT Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pptxgenjs/3.12.0/pptxgen.bundle.js" integrity="sha512-TCP3qvyzR4NFe3BIhQDT0bFMRYOdLMXB485uAPbxG+5W+nM8QeFjF4Cb0spg0Y+7SdZz/YKjMRgXKj7qjLTLcA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        body {
            font-family: sans-serif;
            background-color: var(--wp--preset--color--theme-palette-8, #F7FAFC);
            color: var(--wp--preset--color--theme-palette-3, #000027);
            padding: 2rem;
            line-height: 1.6;
            --wp--preset--color--theme-palette-1: #FC5E1F; /* Example color */
            --wp--preset--color--theme-palette-3: #000027; /* Example color */
            --wp--preset--color--theme-palette-8: #F7FAFC; /* Example color */
            --wp--preset--color--theme-palette-9: #ffffff; /* Example color */
        }

        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: var(--wp--preset--color--theme-palette-9, #ffffff);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }

        h1 {
            color: var(--wp--preset--color--theme-palette-1, #FC5E1F);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        input[type="url"], input[type="text"] {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding in width */
        }

        button {
            display: inline-block;
            background-color: var(--wp--preset--color--theme-palette-1, #FC5E1F);
            color: var(--wp--preset--color--theme-palette-9, #ffffff);
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #statusMessage {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            display: none; /* Initially hidden */
        }
        .status-info {
            background-color: #e0f7fa;
            color: #00796b;
            border: 1px solid #b2ebf2;
        }
        .status-success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        .status-error {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        #contentContainer {
             /* Hidden container to render fetched content for screenshotting */
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1280px; /* Define a width for rendering */
            opacity: 0;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>HTML Page to PPT Slides</h1>
        <p>Enter the URL of a web page. The tool will attempt to detect repeating sections (divs with the same classes under the same parent), screenshot each section, and generate a PowerPoint file with each screenshot as a slide.</p>
        <p><small>Note: This may not work for all websites due to CORS restrictions or complex HTML structures.</small></p>

        <div>
            <label for="urlInput">Website URL:</label>
            <input type="url" id="urlInput" placeholder="https://example.com" required>
        </div>
        <div>
            <label for="selectorInput">Optional: CSS Selector for repeating elements (e.g., .product-item):</label>
            <input type="text" id="selectorInput" placeholder="Leave empty for auto-detection">
        </div>
        <button id="convertButton">Convert to PPT</button>

        <div id="statusMessage"></div>
    </div>

    <div id="contentContainer"></div>

    <script>
        const urlInput = document.getElementById('urlInput');
        const selectorInput = document.getElementById('selectorInput');
        const convertButton = document.getElementById('convertButton');
        const statusMessage = document.getElementById('statusMessage');
        const contentContainer = document.getElementById('contentContainer');

        convertButton.addEventListener('click', handleConversion);

        function setStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `status-${type}`; // Apply status styling
            statusMessage.style.display = 'block';
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function disableForm(disabled) {
            convertButton.disabled = disabled;
            urlInput.disabled = disabled;
            selectorInput.disabled = disabled;
             convertButton.textContent = disabled ? 'Processing...' : 'Convert to PPT';
        }

        // Auto-detection heuristic: Find sibling divs with identical class lists
        function findRepeatingSiblingDivs(container) {
            const candidates = [];
            const parentNodes = container.querySelectorAll('div'); // Check divs at various levels

            parentNodes.forEach(parent => {
                const childDivs = Array.from(parent.children).filter(el => el.tagName === 'DIV' && el.className.trim() !== '');
                if (childDivs.length < 2) return; // Need at least 2 siblings

                const classMap = {};
                childDivs.forEach(div => {
                    const classKey = Array.from(div.classList).sort().join(' '); // Normalize class order
                    if (!classMap[classKey]) {
                        classMap[classKey] = [];
                    }
                    classMap[classKey].push(div);
                });

                for (const key in classMap) {
                    if (classMap[key].length > 1) { // Found multiple siblings with same classes
                        const group = classMap[key];
                        let isSequential = true;
                        for(let i = 0; i < group.length - 1; i++) {
                            // Check if the next element in the group is indeed the next sibling or after skipping non-divs
                            let current = group[i];
                            let nextExpected = group[i+1];
                            let nextSibling = current.nextElementSibling;
                            while(nextSibling && nextSibling !== nextExpected && nextSibling.tagName !== 'DIV'){
                                // Skip non-div elements
                                nextSibling = nextSibling.nextElementSibling;
                            }
                            if (nextSibling !== nextExpected) {
                                isSequential = false;
                                break;
                            }
                        }
                        if(isSequential) {
                            candidates.push(...group);
                        }
                    }
                }
            });

            const uniqueCandidates = [...new Set(candidates)];
            console.log(`Auto-detected ${uniqueCandidates.length} potential repeating divs.`);
            return uniqueCandidates;
        }

        async function handleConversion() {
            const url = urlInput.value.trim();
            const customSelector = selectorInput.value.trim();

            if (!url) {
                setStatus('Please enter a valid URL.', 'error');
                return;
            }

            disableForm(true);
            setStatus('Fetching page content...');
            contentContainer.innerHTML = ''; // Clear previous content

            const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} - Failed to fetch from proxy.`);
                }
                const html = await response.text();

                setStatus('Parsing HTML and preparing content for rendering...');
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                const base = doc.createElement('base');
                base.href = url;
                doc.head.prepend(base);

                // Render content in the hidden container
                contentContainer.innerHTML = ''; // Clear first
                // Append styles from head
                doc.querySelectorAll('link[rel="stylesheet"], style').forEach(styleEl => {
                    contentContainer.appendChild(styleEl.cloneNode(true));
                });
                // Append body content
                if (doc.body) {
                    Array.from(doc.body.childNodes).forEach(node => {
                        contentContainer.appendChild(node.cloneNode(true));
                    });
                } else {
                    throw new Error('Could not find body element in the fetched HTML.');
                }

                // Wait a bit for potential layout and rendering updates
                await new Promise(resolve => setTimeout(resolve, 200));

                let elementsToCapture;
                if (customSelector) {
                    console.log(`Using custom selector: ${customSelector}`)
                    elementsToCapture = Array.from(contentContainer.querySelectorAll(customSelector));
                    if (elementsToCapture.length === 0) {
                        throw new Error(`No elements found matching selector: ${customSelector}`);
                    }
                } else {
                    console.log("Attempting auto-detection of repeating sibling divs...");
                    elementsToCapture = findRepeatingSiblingDivs(contentContainer);
                    if (elementsToCapture.length === 0) {
                        throw new Error('Could not auto-detect suitable repeating elements. Try using a specific CSS selector.');
                    }
                }

                setStatus(`Found ${elementsToCapture.length} elements. Generating screenshots...`);

                const imagePromises = elementsToCapture.map((element, index) => {
                    console.log(`Preparing to capture element ${index + 1}`, element);
                    if (!element || element.offsetWidth === 0 || element.offsetHeight === 0) {
                         console.warn(`Skipping element ${index + 1} as it is not visible or has zero dimensions.`);
                         return Promise.resolve(null);
                    }
                    return html2canvas(element, {
                        useCORS: true,
                        allowTaint: true,
                        logging: false, // Reduce console noise, enable for deep debug
                        scale: window.devicePixelRatio || 1
                    }).then(canvas => {
                        console.log(`Successfully captured element ${index + 1}`);
                        return canvas.toDataURL('image/png');
                    }).catch(err => {
                        console.error(`html2canvas error for element ${index+1}:`, err);
                        setStatus(`Error capturing element ${index + 1}. Skipping.`, 'error');
                        return null; // Return null on error
                    });
                });

                const images = (await Promise.all(imagePromises)).filter(img => img !== null);

                if (images.length === 0) {
                    throw new Error('No elements could be successfully screenshotted.');
                }

                setStatus(`Generated ${images.length} screenshots. Preparing slides...`);

                const pptx = new PptxGenJS();
                pptx.layout = 'LAYOUT_WIDE';

                // Create promises to get image dimensions
                const dimensionPromises = images.map((imageDataUrl, index) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = function() {
                            resolve({ // Resolve with data needed for the slide
                                imageDataUrl: imageDataUrl,
                                width: img.width,
                                height: img.height,
                                index: index // Keep original index for logging
                            });
                        };
                        img.onerror = function() {
                            console.error(`Failed to load image data for screenshot ${index + 1} to get dimensions.`);
                            resolve(null); // Indicate failure for this image
                        };
                        img.src = imageDataUrl;
                    });
                });

                // Wait for all dimension calculations
                const imageInfos = await Promise.all(dimensionPromises);

                setStatus(`Image dimensions processed. Adding ${imageInfos.filter(info => info).length} slides to PPTX...`);

                let addedSlideCount = 0;
                imageInfos.forEach(info => {
                    if (!info) { // Skip if dimension calculation failed
                        console.warn(`Skipping slide for image index ${info ? info.index + 1 : 'unknown'} due to load error.`);
                        return;
                    }

                    const { imageDataUrl, width: imgWidth, height: imgHeight, index } = info;
                    if (imgWidth === 0 || imgHeight === 0) {
                        console.warn(`Skipping slide for image index ${index + 1} due to zero dimensions after load.`);
                        return;
                    }
                    const aspectRatio = imgWidth / imgHeight;
                    const slideWidthInches = 13.33; // Widescreen layout width
                    const slideHeightInches = 7.5;   // Widescreen layout height

                    let w = slideWidthInches;
                    let h = w / aspectRatio;

                    if (h > slideHeightInches) {
                        h = slideHeightInches;
                        w = h * aspectRatio;
                    }

                    const x = (slideWidthInches - w) / 2;
                    const y = (slideHeightInches - h) / 2;

                    try {
                        const slide = pptx.addSlide();
                        slide.addImage({
                            data: imageDataUrl,
                            x: x, y: y, w: w, h: h,
                        });
                        addedSlideCount++;
                        console.log(`Added image ${index + 1} to slide.`);
                    } catch(slideErr) {
                        console.error(`Error adding image ${index + 1} to slide:`, slideErr);
                        setStatus(`Error adding image ${index + 1} to slide. Skipping.`, 'error');
                    }
                });

                // Call writeFile once after the loop
                if (addedSlideCount > 0) {
                    const filename = `website_slides_${new Date().toISOString().slice(0,10)}.pptx`;
                    setStatus(`Added ${addedSlideCount} slides. Saving PPTX file: ${filename}`);
                    await pptx.writeFile({ fileName: filename });
                    setStatus(`Success! ${addedSlideCount} slides generated in ${filename}`, 'success');
                } else {
                    throw new Error('No slides could be successfully added to the PPTX file.');
                }

            } catch (error) {
                console.error('Conversion failed:', error);
                setStatus(`Error: ${error.message}`, 'error');
            } finally {
                disableForm(false);
                contentContainer.innerHTML = ''; // Clean up hidden container
            }
        }

    </script>
</body>
</html>