<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML to PPT Converter</title>
    <!-- Use local scripts -->
    <script src="assets/js/html2canvas.min.js"></script>
    <script src="assets/js/pptxgen.bundle.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background-color: var(--wp--preset--color--theme-palette-8, #F7FAFC);
            color: var(--wp--preset--color--theme-palette-3, #000027);
            padding: 2rem;
            line-height: 1.6;
            --wp--preset--color--theme-palette-1: #FC5E1F; /* Example color */
            --wp--preset--color--theme-palette-3: #000027; /* Example color */
            --wp--preset--color--theme-palette-8: #F7FAFC; /* Example color */
            --wp--preset--color--theme-palette-9: #ffffff; /* Example color */
        }

        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: var(--wp--preset--color--theme-palette-9, #ffffff);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }

        h1 {
            color: var(--wp--preset--color--theme-palette-1, #FC5E1F);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        input[type="url"], input[type="text"] {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding in width */
        }

        button {
            display: inline-block;
            background-color: var(--wp--preset--color--theme-palette-1, #FC5E1F);
            color: var(--wp--preset--color--theme-palette-9, #ffffff);
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #statusMessage {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            display: none; /* Initially hidden */
        }
        .status-info {
            background-color: #e0f7fa;
            color: #00796b;
            border: 1px solid #b2ebf2;
        }
        .status-success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        .status-error {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        #contentContainer {
             /* Hidden container to render fetched content for screenshotting */
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1280px; /* Define a width for rendering */
            opacity: 0;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>HTML Page to PPT Slides v.0.0.3</h1>
        <p>Enter the URL of a web page or a local path relative to the project root (e.g., /folder/file.html). The tool will attempt to detect repeating sections, screenshot each section, and generate a PowerPoint file.</p>
        <p><small>Note: Cross-origin requests (to different domains) require a CORS proxy and may not always succeed.</small></p>

        <div>
            <label for="urlInput">URL or Local Path:</label>
            <input type="url" id="urlInput" placeholder="https://example.com or /local/path.html" required>
        </div>
        <div>
            <label for="selectorInput">Optional: CSS Selector for repeating elements (e.g., .product-item):</label>
            <input type="text" id="selectorInput" placeholder="Leave empty for auto-detection">
        </div>
        <button id="convertButton">Convert to PPT</button>

        <div id="statusMessage"></div>
    </div>

    <div id="contentContainer"></div>

    <script>
        const urlInput = document.getElementById('urlInput');
        const selectorInput = document.getElementById('selectorInput');
        const convertButton = document.getElementById('convertButton');
        const statusMessage = document.getElementById('statusMessage');
        const contentContainer = document.getElementById('contentContainer');

        convertButton.addEventListener('click', handleConversion);

        function setStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `status-${type}`;
            statusMessage.style.display = 'block';
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function disableForm(disabled) {
            convertButton.disabled = disabled;
            urlInput.disabled = disabled;
            selectorInput.disabled = disabled;
            convertButton.textContent = disabled ? 'Processing...' : 'Convert to PPT';
        }

        function findRepeatingSiblingDivs(container) {
            const candidates = [];
            const parentNodes = container.querySelectorAll('div');

            parentNodes.forEach(parent => {
                const childDivs = Array.from(parent.children).filter(el => el.tagName === 'DIV' && el.className.trim() !== '');
                if (childDivs.length < 2) return;

                const classMap = {};
                childDivs.forEach(div => {
                    const classKey = Array.from(div.classList).sort().join(' ');
                    if (!classMap[classKey]) classMap[classKey] = [];
                    classMap[classKey].push(div);
                });

                for (const key in classMap) {
                    if (classMap[key].length > 1) {
                        const group = classMap[key];
                        let isSequential = true;
                        for(let i = 0; i < group.length - 1; i++) {
                            let current = group[i], nextExpected = group[i+1];
                            let nextSibling = current.nextElementSibling;
                            while(nextSibling && nextSibling !== nextExpected && nextSibling.tagName !== 'DIV'){
                                nextSibling = nextSibling.nextElementSibling;
                            }
                            if (nextSibling !== nextExpected) {
                                isSequential = false; break;
                            }
                        }
                        if(isSequential) candidates.push(...group);
                    }
                }
            });

            const uniqueCandidates = [...new Set(candidates)];
            console.log(`Auto-detected ${uniqueCandidates.length} potential repeating divs.`);
            return uniqueCandidates;
        }

        // Function to check if a URL is cross-origin
        function isCrossOrigin(url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                return false; // Local paths are not cross-origin
            }
            try {
                const targetOrigin = new URL(url).origin;
                return targetOrigin !== window.location.origin;
            } catch (e) {
                console.error("Error parsing URL origin:", e);
                return true; // Assume cross-origin if URL parsing fails
            }
        }

        // Function to fetch HTML content
        async function fetchHtmlContent(url, requiresCors) {
            if (requiresCors) {
                console.log(`Fetching cross-origin resource via proxy: ${url}`);
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                try {
                    const response = await fetch(proxyUrl);
                    if (!response.ok) {
                         throw new Error(`Proxy fetch failed! Status: ${response.status}`);
                    }
                     return await response.text();
                 } catch (proxyError) {
                    console.warn(`Proxy fetch failed: ${proxyError.message}. Attempting direct fetch (might fail due to CORS)...`);
                    // Fallback attempt: direct fetch (will likely fail for cross-origin, but worth a try)
                    try {
                         const directResponse = await fetch(url);
                          if (!directResponse.ok) {
                             throw new Error(`Direct fetch also failed! Status: ${directResponse.status}`);
                         }
                         console.log("Direct fetch successful after proxy failure (unexpected!).");
                         return await directResponse.text();
                     } catch (directError) {
                        console.error("Direct fetch attempt error:", directError);
                         throw new Error(`Proxy fetch failed and direct fetch failed: ${proxyError.message}`);
                     }
                 }
            } else {
                // Fetching local path or same-origin URL
                let fetchUrl = url;
                 if (!url.startsWith('http://') && !url.startsWith('https://')) {
                     // Ensure local paths are relative to the root or handled correctly
                     fetchUrl = url.startsWith('/') ? url : `/${url}`;
                    console.log(`Fetching local resource: ${fetchUrl}`);
                 } else {
                    console.log(`Fetching same-origin resource: ${url}`);
                 }
                 const response = await fetch(fetchUrl);
                 if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} - Failed to fetch resource.`);
                }
                 return await response.text();
            }
        }


        async function handleConversion() {
            let originalUrl = urlInput.value.trim(); // Keep original URL for base href etc.
            let fetchPath = originalUrl;
            const customSelector = selectorInput.value.trim();

            if (!originalUrl) {
                setStatus('Please enter a valid URL or local path.', 'error');
                return;
            }

            const needsCors = isCrossOrigin(originalUrl);
            const isLocal = !originalUrl.startsWith('http://') && !originalUrl.startsWith('https://');

            // Adjust local path if needed (remove leading slash for fetch relative to root)
            if (isLocal && fetchPath.startsWith('/')) {
                fetchPath = fetchPath.substring(1);
            }

            disableForm(true);
            setStatus('Fetching page content...');
            contentContainer.innerHTML = '';

            try {
                // Use fetchPath for fetching, but originalUrl for base href if needed
                const html = await fetchHtmlContent(fetchPath, needsCors);

                setStatus('Parsing HTML and preparing content for rendering...');
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Set base URL only for non-local URLs to resolve relative resources within them
                if (!isLocal && originalUrl.startsWith('http')) {
                    const base = doc.createElement('base');
                    base.href = originalUrl;
                    doc.head.prepend(base);
                }

                contentContainer.innerHTML = '';
                doc.querySelectorAll('link[rel="stylesheet"], style').forEach(styleEl => {
                     // Adjust relative stylesheet paths if the source was local
                     if (isLocal && styleEl.tagName === 'LINK' && styleEl.hasAttribute('href')) {
                        let href = styleEl.getAttribute('href');
                        if (!href.startsWith('http') && !href.startsWith('/') && !href.startsWith('data:')) {
                             const pageDir = fetchPath.includes('/') ? fetchPath.substring(0, fetchPath.lastIndexOf('/')) : '.';
                             styleEl.setAttribute('href', `${pageDir}/${href}`);
                             console.log(`Adjusted local stylesheet path: ${styleEl.getAttribute('href')}`);
                         }
                     }
                    contentContainer.appendChild(styleEl.cloneNode(true));
                });
                if (doc.body) {
                    Array.from(doc.body.childNodes).forEach(node => {
                        contentContainer.appendChild(node.cloneNode(true));
                    });
                } else {
                    throw new Error('Could not find body element in the fetched HTML.');
                }

                await new Promise(resolve => setTimeout(resolve, 200));

                let elementsToCapture;
                if (customSelector) {
                    console.log(`Using custom selector: ${customSelector}`)
                    elementsToCapture = Array.from(contentContainer.querySelectorAll(customSelector));
                    if (elementsToCapture.length === 0) {
                        throw new Error(`No elements found matching selector: ${customSelector}`);
                    }
                } else {
                    console.log("Attempting auto-detection of repeating sibling divs...");
                    elementsToCapture = findRepeatingSiblingDivs(contentContainer);
                    if (elementsToCapture.length === 0) {
                         console.log("Auto-detection failed, attempting to capture direct body children divs...");
                         elementsToCapture = Array.from(contentContainer.children).filter(el => el.tagName === 'DIV');
                         if (elementsToCapture.length === 0) {
                             console.log("Capturing direct body children failed, attempting to capture body itself...");
                            const bodyElement = contentContainer.querySelector('body') || contentContainer;
                            elementsToCapture = [bodyElement];
                             if (!bodyElement || bodyElement.innerHTML.trim() === '') {
                                 throw new Error('Could not auto-detect/fallback to capture elements.');
                            }
                         } else {
                             console.log(`Found ${elementsToCapture.length} direct children divs to capture.`);
                         }
                     }
                }

                setStatus(`Found ${elementsToCapture.length} element(s) to capture. Generating screenshots...`);

                const imagePromises = elementsToCapture.map((element, index) => {
                    console.log(`Preparing to capture element ${index + 1}`, element);
                    if (!element || typeof element.getBoundingClientRect !== 'function') {
                         console.warn(`Skipping element ${index + 1} as it's not a valid element.`);
                         return Promise.resolve(null);
                    }
                     const rect = element.getBoundingClientRect();
                     if (rect.width === 0 || rect.height === 0 || getComputedStyle(element).visibility === 'hidden' || getComputedStyle(element).display === 'none') {
                         console.warn(`Skipping element ${index + 1} as it is not visible or has zero dimensions.`);
                         return Promise.resolve(null);
                     }

                    return html2canvas(element, {
                        useCORS: needsCors, // Use CORS only if determined necessary
                        allowTaint: needsCors,
                        logging: false,
                        scale: window.devicePixelRatio || 1,
                         backgroundColor: '#ffffff',
                         scrollX: 0,
                         scrollY: -window.scrollY,
                         // Adjust window dimensions based on whether it's cross-origin or not
                         windowWidth: needsCors ? document.documentElement.scrollWidth : null,
                         windowHeight: needsCors ? document.documentElement.scrollHeight : null
                    }).then(canvas => {
                        console.log(`Successfully captured element ${index + 1}`);
                        return canvas.toDataURL('image/png');
                    }).catch(err => {
                        console.error(`html2canvas error for element ${index+1}:`, err);
                        setStatus(`Error capturing element ${index + 1}. Skipping.`, 'error');
                        return null;
                    });
                });

                const images = (await Promise.all(imagePromises)).filter(img => img !== null);

                if (images.length === 0) {
                    throw new Error('No elements could be successfully screenshotted.');
                }

                setStatus(`Generated ${images.length} screenshots. Preparing slides...`);

                const pptx = new PptxGenJS();
                pptx.layout = 'LAYOUT_WIDE';

                const dimensionPromises = images.map((imageDataUrl, index) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve({ imageDataUrl, width: img.width, height: img.height, index });
                        img.onerror = () => { console.error(`Failed to load image ${index + 1} data`); resolve(null); };
                        img.src = imageDataUrl;
                    });
                });

                const imageInfos = await Promise.all(dimensionPromises);
                setStatus(`Image dimensions processed. Adding ${imageInfos.filter(info => info).length} slides to PPTX...`);

                let addedSlideCount = 0;
                imageInfos.forEach(info => {
                    if (!info || info.width === 0 || info.height === 0) return;
                    const { imageDataUrl, width: imgWidth, height: imgHeight, index } = info;
                    const aspectRatio = imgWidth / imgHeight;
                    const slideWidthInches = 13.33, slideHeightInches = 7.5;
                    let w = slideWidthInches, h = w / aspectRatio;
                    if (h > slideHeightInches) { h = slideHeightInches; w = h * aspectRatio; }
                    const x = (slideWidthInches - w) / 2, y = (slideHeightInches - h) / 2;
                    try {
                        const slide = pptx.addSlide();
                        slide.addImage({ data: imageDataUrl, x, y, w, h });
                        addedSlideCount++;
                        console.log(`Added image ${index + 1} to slide.`);
                    } catch(slideErr) {
                        console.error(`Error adding image ${index + 1} to slide:`, slideErr);
                        setStatus(`Error adding image ${index + 1} to slide. Skipping.`, 'error');
                    }
                });

                if (addedSlideCount > 0) {
                    const filename = `slides_${originalUrl.replace(/[^a-zA-Z0-9]/g, '_')}.pptx`;
                    setStatus(`Added ${addedSlideCount} slides. Saving PPTX file: ${filename}`);
                    await pptx.writeFile({ fileName: filename });
                    setStatus(`Success! ${addedSlideCount} slides generated in ${filename}`, 'success');
                } else {
                    throw new Error('No slides could be successfully added.');
                }

            } catch (error) {
                console.error('Conversion failed:', error);
                setStatus(`Error: ${error.message}`, 'error');
            } finally {
                disableForm(false);
                contentContainer.innerHTML = '';
            }
        }

    </script>
</body>
</html>