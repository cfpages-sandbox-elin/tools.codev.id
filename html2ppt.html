<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML to PPT Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pptxgenjs/3.12.0/pptxgen.bundle.js" integrity="sha512-TCP3qvyzR4NFe3BIhQDT0bFMRYOdLMXB485uAPbxG+5W+nM8QeFjF4Cb0spg0Y+7SdZz/YKjMRgXKj7qjLTLcA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        body {
            font-family: sans-serif;
            background-color: var(--wp--preset--color--theme-palette-8, #F7FAFC);
            color: var(--wp--preset--color--theme-palette-3, #000027);
            padding: 2rem;
            line-height: 1.6;
            --wp--preset--color--theme-palette-1: #FC5E1F; /* Example color */
            --wp--preset--color--theme-palette-3: #000027; /* Example color */
            --wp--preset--color--theme-palette-8: #F7FAFC; /* Example color */
            --wp--preset--color--theme-palette-9: #ffffff; /* Example color */
        }

        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: var(--wp--preset--color--theme-palette-9, #ffffff);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }

        h1 {
            color: var(--wp--preset--color--theme-palette-1, #FC5E1F);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        input[type="url"], input[type="text"] {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding in width */
        }

        button {
            display: inline-block;
            background-color: var(--wp--preset--color--theme-palette-1, #FC5E1F);
            color: var(--wp--preset--color--theme-palette-9, #ffffff);
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #statusMessage {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }
        .status-info {
            background-color: #e0f7fa;
            color: #00796b;
            border: 1px solid #b2ebf2;
        }
        .status-success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        .status-error {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        #contentContainer {
             /* Hidden container to render fetched content for screenshotting */
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1280px; /* Define a width for rendering */
            opacity: 0;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>HTML Page to PPT Slides</h1>
        <p>Enter the URL of a web page. The tool will attempt to detect repeating sections (divs with the same classes under the same parent), screenshot each section, and generate a PowerPoint file with each screenshot as a slide.</p>
        <p><small>Note: This may not work for all websites due to CORS restrictions or complex HTML structures.</small></p>

        <div>
            <label for="urlInput">Website URL:</label>
            <input type="url" id="urlInput" placeholder="https://example.com" required>
        </div>
        <div>
            <label for="selectorInput">Optional: CSS Selector for repeating elements (e.g., .product-item):</label>
            <input type="text" id="selectorInput" placeholder="Leave empty for auto-detection">
        </div>
        <button id="convertButton">Convert to PPT</button>

        <div id="statusMessage"></div>
    </div>

    <div id="contentContainer"></div>

    <script>
        const urlInput = document.getElementById('urlInput');
        const selectorInput = document.getElementById('selectorInput');
        const convertButton = document.getElementById('convertButton');
        const statusMessage = document.getElementById('statusMessage');
        const contentContainer = document.getElementById('contentContainer');

        convertButton.addEventListener('click', handleConversion);

        function setStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = \`status-\${type}\`; // Apply status styling
            statusMessage.style.display = 'block';
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function disableForm(disabled) {
            convertButton.disabled = disabled;
            urlInput.disabled = disabled;
            selectorInput.disabled = disabled;
             convertButton.textContent = disabled ? 'Processing...' : 'Convert to PPT';
        }

        async function handleConversion() {
            const url = urlInput.value.trim();
            const customSelector = selectorInput.value.trim();

            if (!url) {
                setStatus('Please enter a valid URL.', 'error');
                return;
            }

            disableForm(true);
            setStatus('Fetching page content...');
            contentContainer.innerHTML = ''; // Clear previous content

            // Use a CORS proxy to fetch content
            const proxyUrl = \`https://api.allorigins.win/raw?url=\${encodeURIComponent(url)}\`;

            try {
                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    throw new Error(\`HTTP error! Status: \${response.status} - Failed to fetch from proxy.\`);
                }
                const html = await response.text();

                setStatus('Parsing HTML and identifying elements...');

                // Parse the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Inject base URL to resolve relative paths (like images)
                const base = doc.createElement('base');
                base.href = url;
                doc.head.prepend(base);

                // Append styles from the original page head to the container's document fragment
                // This helps html2canvas render styles correctly. This is imperfect.
                const tempFragment = document.createDocumentFragment();
                doc.querySelectorAll('link[rel="stylesheet"], style').forEach(styleEl => {
                    tempFragment.appendChild(styleEl.cloneNode(true));
                 });
                 // Render the fetched body content into the hidden container
                contentContainer.innerHTML = ''; // Clear again just in case
                contentContainer.appendChild(tempFragment); // Add styles first
                // Append the body directly for rendering - may cause issues if body tag itself has critical styles/scripts
                 // A safer approach might be to create a div and copy children, but let's try this first.
                 if(doc.body) {
                     // Clone nodes to avoid modifying the parsed doc directly if needed elsewhere
                     Array.from(doc.body.childNodes).forEach(node => {
                         contentContainer.appendChild(node.cloneNode(true));
                     });
                 } else {
                     throw new Error('Could not find body element in the fetched HTML.');
                 }


                await new Promise(resolve => setTimeout(resolve, 100)); // Short delay for rendering

                let elementsToCapture;

                if (customSelector) {
                     console.log(\`Using custom selector: \${customSelector}\`)
                     elementsToCapture = Array.from(contentContainer.querySelectorAll(customSelector));
                     if (elementsToCapture.length === 0) {
                         setStatus(\`No elements found matching selector: \${customSelector}\`, 'error');
                         disableForm(false);
                         return;
                     }
                } else {
                     console.log("Attempting auto-detection of repeating sibling divs...");
                     elementsToCapture = findRepeatingSiblingDivs(contentContainer);
                      if (elementsToCapture.length === 0) {
                         setStatus('Could not auto-detect suitable repeating elements. Try using a specific CSS selector.', 'error');
                         disableForm(false);
                         return;
                     }
                }


                setStatus(\`Found \${elementsToCapture.length} elements. Generating screenshots...\`);

                const imagePromises = elementsToCapture.map((element, index) => {
                    console.log(\`Capturing element \${index + 1}\`, element);
                     // Skip elements that might be hidden or have no dimensions
                    if (element.offsetWidth === 0 || element.offsetHeight === 0) {
                         console.warn(\`Skipping element \${index + 1} as it has zero dimensions.\`);
                         return Promise.resolve(null); // Resolve with null if skipped
                     }
                    return html2canvas(element, {
                            useCORS: true, // Attempt to capture cross-origin images
                            allowTaint: true, // Allow tainting canvas for cross-origin images (may prevent toDataURL)
                            logging: true, // Enable html2canvas logging for debugging
                           scale: window.devicePixelRatio || 1 // Use device pixel ratio for better quality
                     }).then(canvas => canvas.toDataURL('image/png'))
                       .catch(err => {
                           console.error(\`html2canvas error for element \${index+1}:\`, err);
                           setStatus(\`Error capturing element \${index + 1}. Skipping.\`, 'error');
                           return null; // Return null on error
                       });
                });

                const images = (await Promise.all(imagePromises)).filter(img => img !== null); // Filter out nulls (skipped/errors)

                if (images.length === 0) {
                    setStatus('No elements could be successfully screenshotted.', 'error');
                    disableForm(false);
                    return;
                }

                setStatus(\`Generated \${images.length} screenshots. Creating PPTX file...\`);

                const pptx = new PptxGenJS();
                pptx.layout = 'LAYOUT_WIDE'; // Use a standard widescreen layout

                images.forEach((imageDataUrl, index) => {
                    const slide = pptx.addSlide();
                     // Add image, scaling it to fit the slide width while maintaining aspect ratio
                     // PptxGenJS uses inches for x, y, w, h. Assuming a standard 16:9 slide (10x5.625 inches or 13.33x7.5 inches for Widescreen)
                     // We get image dimensions to calculate aspect ratio.
                     const img = new Image();
                     img.onload = function() {
                         const imgWidth = img.width;
                         const imgHeight = img.height;
                         const aspectRatio = imgWidth / imgHeight;
                         const slideWidthInches = 13.33; // Widescreen layout width
                         const slideHeightInches = 7.5;   // Widescreen layout height

                         let w = slideWidthInches;
                         let h = w / aspectRatio;

                         // If calculated height exceeds slide height, scale by height instead
                         if (h > slideHeightInches) {
                             h = slideHeightInches;
                             w = h * aspectRatio;
                         }

                         // Center the image on the slide
                         const x = (slideWidthInches - w) / 2;
                         const y = (slideHeightInches - h) / 2;

                         slide.addImage({
                             data: imageDataUrl,
                             x: x, // Position (inches)
                             y: y, // Position (inches)
                             w: w, // Width (inches)
                             h: h, // Height (inches)
                         });
                         console.log(\`Added image \${index + 1} to slide.\`);

                          // Check if this is the last image to trigger download
                         if (index === images.length - 1) {
                            const filename = \`website_slides_\${new Date().toISOString().slice(0,10)}.pptx\`;
                            pptx.writeFile({ fileName: filename }).then(() => {
                                setStatus(\`Success! \${images.length} slides generated in \${filename}\`, 'success');
                            }).catch(err => {
                                console.error("PptxGenJS error:", err);
                                setStatus('Error generating PPTX file.', 'error');
                            }).finally(() => {
                                disableForm(false);
                                contentContainer.innerHTML = ''; // Clean up hidden container
                            });
                         }
                     };
                     img.onerror = function() {
                         console.error(\`Failed to load image data for slide \${index + 1} to get dimensions.\`);
                          // Add a placeholder or skip if image loading fails for dimension calculation
                          // For simplicity, maybe add with default size or skip slide
                         if (index === images.length - 1) { // Still need to potentially trigger download if last item
                            const filename = \`website_slides_\${new Date().toISOString().slice(0,10)}.pptx\`;
                             pptx.writeFile({ fileName: filename }).then(() => {
                                setStatus(\`Success (with potential image load errors)! \${images.length} slides generated in \${filename}\`, 'success');
                             }).catch(err => {
                                 console.error("PptxGenJS error:", err);
                                 setStatus('Error generating PPTX file.', 'error');
                             }).finally(() => {
                                 disableForm(false);
                                 contentContainer.innerHTML = '';
                             });
                         }
                     }
                     img.src = imageDataUrl; // Set src to trigger onload/onerror

                });


            } catch (error) {
                console.error('Conversion failed:', error);
                setStatus(\`Error: \${error.message}\`, 'error');
                disableForm(false);
                contentContainer.innerHTML = ''; // Clean up
            }
        }

        // Auto-detection heuristic: Find sibling divs with identical class lists
        function findRepeatingSiblingDivs(container) {
            const candidates = [];
            const parentNodes = container.querySelectorAll('div'); // Check divs at various levels

            parentNodes.forEach(parent => {
                const childDivs = Array.from(parent.children).filter(el => el.tagName === 'DIV' && el.className.trim() !== '');
                if (childDivs.length < 2) return; // Need at least 2 siblings

                const classMap = {};
                childDivs.forEach(div => {
                    const classKey = Array.from(div.classList).sort().join(' '); // Normalize class order
                    if (!classMap[classKey]) {
                        classMap[classKey] = [];
                    }
                    classMap[classKey].push(div);
                });

                for (const key in classMap) {
                    if (classMap[key].length > 1) { // Found multiple siblings with same classes
                        // Check if these elements are roughly sequential siblings
                        const group = classMap[key];
                        let isSequential = true;
                        for(let i = 0; i < group.length - 1; i++) {
                            if (group[i].nextElementSibling !== group[i+1]) {
                                // Allow for non-div elements in between (like <hr> or <script>)
                                let nextSibling = group[i].nextElementSibling;
                                let found = false;
                                while(nextSibling && nextSibling !== group[i+1]) {
                                    nextSibling = nextSibling.nextElementSibling;
                                }
                                if(nextSibling !== group[i+1]){
                                    isSequential = false;
                                    break;
                                }
                            }
                        }
                        // Basic sequential check passed, add them
                        if(isSequential) {
                            candidates.push(...group);
                        }

                    }
                }
            });

             // Return unique elements only, preferring deeper, more specific groups
             // Simple approach: just return unique elements found. More complex logic could prioritize.
            const uniqueCandidates = [...new Set(candidates)];
            console.log(`Auto-detected ${uniqueCandidates.length} potential repeating divs.`);
             return uniqueCandidates;
         }

    </script>
</body>
</html>