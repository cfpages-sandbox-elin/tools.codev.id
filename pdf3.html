<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Splitter</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js from Mozilla -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- pdf-lib -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
        .spinner { border: 4px solid rgba(0,0,0,.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #09f; animation: spin 1s ease infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .cut-line { position: absolute; left: 0; right: 0; height: 5px; background-color: rgba(239, 68, 68, 0.7); cursor: ns-resize; border-top: 1px dashed white; border-bottom: 1px dashed white; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .cut-line:hover { background-color: rgba(220, 38, 38, 1); }
        .cut-line .handle { width: 60px; height: 20px; background-color: rgb(239, 68, 68); border-radius: 10px; color: white; font-size: 10px; text-align: center; line-height: 20px; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body class="bg-slate-100 font-sans">
    <div class="w-full max-w-5xl mx-auto p-4 sm:p-8 my-10 bg-white rounded-xl shadow-lg">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-slate-800">Advanced PDF Splitter v3.1</h1>
            <p class="text-slate-500 mt-2">Upload, preview, and adjust split lines before creating your multi-page PDF.</p>
        </div>

        <div id="settings-section" class="grid grid-cols-1 md:grid-cols-3 gap-6 border-b pb-6 mb-6 items-start">
            <div>
                <label class="block text-sm font-medium text-slate-700 mb-2">1. Upload PDF</label>
                <input id="file-upload" type="file" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100" accept=".pdf">
                <p id="file-name" class="text-xs text-slate-500 mt-2 truncate"></p>
            </div>
            <div>
                <label for="paper-size" class="block text-sm font-medium text-slate-700 mb-2">2. Target Paper Size</label>
                <select id="paper-size" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option value="A4">A4 (210 x 297 mm)</option>
                    <option value="A5">A5 (148 x 210 mm)</option>
                    <option value="Letter">Letter (8.5 x 11 in)</option>
                    <option value="Legal">Legal (8.5 x 14 in)</option>
                    <option value="F4">F4 (210 x 330 mm)</option>
                </select>
            </div>
            <div>
                <label for="padding-select" class="block text-sm font-medium text-slate-700 mb-2">3. Top/Bottom Padding</label>
                <select id="padding-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option value="18">Narrow (18 pts / 0.25")</option>
                    <option value="36" selected>Normal (36 pts / 0.5")</option>
                    <option value="72">Wide (72 pts / 1.0")</option>
                    <option value="custom">Custom</option>
                </select>
                <input type="number" id="custom-padding-input" value="36" class="hidden mt-2 w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
            </div>
        </div>

        <div id="action-bar" class="flex items-center justify-center space-x-4 mb-6">
             <button id="preview-button" type="button" disabled class="px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-slate-400 disabled:cursor-not-allowed">Generate Preview</button>
             <button id="generate-button" type="button" class="hidden px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Create Final PDF</button>
             <!-- UI FIX: Download link is now here -->
             <a id="download-link" class="hidden px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700">Download Split PDF</a>
        </div>
        <div id="status" class="text-center mb-4 min-h-[2rem]"></div>

        <div id="preview-section" class="hidden">
            <h3 class="text-lg font-semibold text-slate-700 mb-2 text-center">4. Adjust Split Lines</h3>
            <p class="text-sm text-slate-500 text-center mb-4">Click and drag a red line. The line will snap to a pixel grid.</p>
            <div id="preview-container" class="relative w-full max-h-[80vh] overflow-y-auto border-2 border-slate-300 bg-slate-200">
                <canvas id="pdf-canvas" class="w-full h-auto"></canvas>
                <div id="cut-lines-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
            </div>
        </div>
    </div>

<script>
    const { PDFDocument, rgb } = PDFLib; // Ensure rgb is imported
    let uploadedFile = null;
    let originalPdfArrayBuffer = null;
    let originalPageSize = { width: 0, height: 0, scale: 1 };
    let cutPositions = [];
    let maxSliceHeightPixels = 0;
    let activeDrag = { lineIndex: -1, startY: 0, originalCutPositions: [] };
    
    const fileInput = document.getElementById('file-upload');
    const fileNameDisplay = document.getElementById('file-name');
    const paperSizeSelect = document.getElementById('paper-size');
    const paddingSelect = document.getElementById('padding-select');
    const customPaddingInput = document.getElementById('custom-padding-input');
    const previewButton = document.getElementById('preview-button');
    const generateButton = document.getElementById('generate-button');
    const statusDiv = document.getElementById('status');
    const previewSection = document.getElementById('preview-section');
    const canvas = document.getElementById('pdf-canvas');
    const cutLinesContainer = document.getElementById('cut-lines-container');
    const downloadLink = document.getElementById('download-link');

    const paperDimensions = { A4: { width: 595.28, height: 841.89 }, A5: { width: 419.53, height: 595.28 }, Letter: { width: 612, height: 792 }, Legal: { width: 612, height: 1008 }, F4: { width: 595.28, height: 935.43 } };

    fileInput.addEventListener('change', handleFileSelect);
    previewButton.addEventListener('click', renderPreview);
    generateButton.addEventListener('click', createFinalPdf);
    paddingSelect.addEventListener('change', () => {
        customPaddingInput.classList.toggle('hidden', paddingSelect.value !== 'custom');
    });

    function getPaddingValue() {
        return paddingSelect.value === 'custom' ? (parseFloat(customPaddingInput.value) || 0) : parseFloat(paddingSelect.value);
    }

    function handleFileSelect(e) {
        uploadedFile = e.target.files[0];
        if (uploadedFile) {
            fileNameDisplay.textContent = uploadedFile.name;
            previewButton.disabled = false;
            previewSection.classList.add('hidden');
            generateButton.classList.add('hidden');
            downloadLink.classList.add('hidden');
            statusDiv.innerHTML = '';
        }
    }

    async function renderPreview() {
        if (!uploadedFile) return;
        showStatus('loading', 'Loading and rendering PDF preview...');
        previewButton.disabled = true;
        
        try {
            originalPdfArrayBuffer = await uploadedFile.arrayBuffer();
            const pdfjsDoc = await pdfjsLib.getDocument({ data: originalPdfArrayBuffer.slice(0) }).promise;
            
            if (pdfjsDoc.numPages !== 1) {
                showStatus('error', 'Error: This tool only supports single-page PDFs.'); return;
            }

            const page = await pdfjsDoc.getPage(1);
            const desiredWidth = 1000;
            const viewport = page.getViewport({ scale: 1 });
            const scale = desiredWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });

            originalPageSize = { width: viewport.width, height: viewport.height, scale: scale };
            canvas.height = scaledViewport.height;
            canvas.width = scaledViewport.width;

            const renderContext = { canvasContext: canvas.getContext('2d', { willReadFrequently: true }), viewport: scaledViewport };
            await page.render(renderContext).promise;

            calculateInitialCutLines();
            drawCutLines();
            
            previewSection.classList.remove('hidden');
            generateButton.classList.remove('hidden');
            downloadLink.classList.add('hidden');
            showStatus('success', `Preview generated. Found ${cutPositions.length + 1} potential pages.`);
        } catch (err) {
            showStatus('error', `Error rendering preview: ${err.message}`);
        } finally {
            previewButton.disabled = false;
        }
    }

    function calculateInitialCutLines() {
        const selectedPaper = paperSizeSelect.value;
        const targetDims = paperDimensions[selectedPaper];
        const targetRatio = targetDims.height / targetDims.width;
        
        const paddingPoints = getPaddingValue();
        const targetContentHeightPoints = (originalPageSize.width * targetRatio) - (2 * paddingPoints);

        if (targetContentHeightPoints <= 0) {
            showStatus('error', 'Padding is too large for the selected paper size.');
            cutPositions = []; maxSliceHeightPixels = 0; return;
        }

        maxSliceHeightPixels = targetContentHeightPoints * originalPageSize.scale;
        cutPositions = [];
        let currentY = 0;
        while (currentY < canvas.height) {
            currentY += maxSliceHeightPixels;
            if (currentY < canvas.height) cutPositions.push(Math.round(currentY));
        }
    }

    function drawCutLines() {
        cutLinesContainer.innerHTML = '';
        cutPositions.forEach((yPos, index) => {
            const line = document.createElement('div');
            line.className = 'cut-line';
            line.style.top = `${yPos}px`;
            line.dataset.index = index;
            line.style.pointerEvents = 'auto';
            const handle = document.createElement('div');
            handle.className = 'handle';
            handle.textContent = `Page ${index + 2}`;
            line.appendChild(handle);
            line.addEventListener('mousedown', startDrag);
            cutLinesContainer.appendChild(line);
        });
    }

    function startDrag(e) {
        e.preventDefault();
        const lineIndex = parseInt(e.target.dataset.index, 10);
        activeDrag = { lineIndex, startY: e.clientY, originalCutPositions: [...cutPositions] };
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
    }

    // GRID LOCK FIX: The drag function now aggressively snaps to whole pixels.
    function drag(e) {
        if (activeDrag.lineIndex === -1) return;
        const deltaY = e.clientY - activeDrag.startY;
        const index = activeDrag.lineIndex;
        const originalY = activeDrag.originalCutPositions[index];
        let newY = originalY + deltaY;
        
        const prevLineY = index > 0 ? cutPositions[index - 1] : 0;
        const minAllowedY = prevLineY + 20;
        const maxAllowedY = prevLineY + maxSliceHeightPixels;

        newY = Math.max(minAllowedY, newY);
        newY = Math.min(maxAllowedY, newY);
        
        const snappedY = Math.round(newY);
        if (cutPositions[index] === snappedY) return; // Prevent redraw if position hasn't changed
        cutPositions[index] = snappedY;
        
        const sliceHeight = snappedY - prevLineY;
        for (let i = index + 1; i < cutPositions.length; i++) {
            cutPositions[i] = Math.round(cutPositions[i - 1] + sliceHeight);
        }
        
        rebalanceCutLines();
        drawCutLines();
    }

    function endDrag() {
        activeDrag.lineIndex = -1;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', endDrag);
    }

    function rebalanceCutLines() {
        let lastY = cutPositions.length > 0 ? cutPositions[cutPositions.length - 1] : 0;
        while (canvas.height - lastY > maxSliceHeightPixels + 10) {
            const newCutY = lastY + maxSliceHeightPixels;
            if (newCutY < canvas.height) {
                cutPositions.push(Math.round(newCutY));
                lastY = newCutY;
            } else { break; }
        }
        while (cutPositions.length > 0 && cutPositions[cutPositions.length - 1] >= canvas.height) {
            cutPositions.pop();
        }
    }
    
    // --- Final PDF Generation (REPLACE THIS ENTIRE FUNCTION) ---

    async function createFinalPdf() {
        if (!originalPdfArrayBuffer) return;
        showStatus('loading', 'Generating final PDF...');
        generateButton.disabled = true;

        try {
            const outputPdfDoc = await PDFDocument.create();
            const [embeddedPage] = await outputPdfDoc.embedPdf(originalPdfArrayBuffer.slice(0));
            
            const selectedPaper = paperSizeSelect.value;
            const targetSize = paperDimensions[selectedPaper];
            const paddingPoints = getPaddingValue();
            
            const cutPointsY = [0, ...cutPositions.map(p => p / originalPageSize.scale), originalPageSize.height];

            for (let i = 0; i < cutPointsY.length - 1; i++) {
                const startY_pdf = cutPointsY[i];

                const finalPage = outputPdfDoc.addPage([targetSize.width, targetSize.height]);
                const { width: finalWidth, height: finalHeight } = finalPage.getSize();
                
                const scaleFactor = finalWidth / embeddedPage.width;
                const scaledPageHeight = embeddedPage.height * scaleFactor;

                // --- THE DEFINITIVE AND CORRECT POSITIONING MATH ---
                // We want to align the top of our slice with the top of the content area.
                // The `drawPage` y-coordinate refers to the BOTTOM of the embedded page.
                
                // 1. Determine the Y-coordinate for the top of the content on the new page.
                const contentTopOnNewPage = (i === 0) ? finalHeight : (finalHeight - paddingPoints);
                
                // 2. Calculate the position of the top of the slice in the scaled-up coordinate system.
                const scaledSliceTopY = startY_pdf * scaleFactor;
                
                // 3. Calculate the final offset for the bottom of the embedded page.
                const y_offset = contentTopOnNewPage - scaledSliceTopY;
                
                // 1. Draw the positioned content.
                finalPage.drawPage(embeddedPage, {
                    x: 0,
                    y: y_offset - scaledPageHeight, // Correctly positions from the bottom
                    width: finalWidth,
                    height: scaledPageHeight,
                });

                // 2. Draw white boxes ON TOP to create clean margins and a "hard cut".
                const white = rgb(1, 1, 1);

                // Always create a clean bottom margin.
                finalPage.drawRectangle({
                    x: 0, y: 0,
                    width: finalWidth, height: paddingPoints,
                    color: white,
                });

                // For all pages AFTER the first, create a clean top margin.
                if (i !== 0) {
                    finalPage.drawRectangle({
                        x: 0, y: finalHeight - paddingPoints,
                        width: finalWidth, height: paddingPoints,
                        color: white,
                    });
                }
            }

            const pdfBytes = await outputPdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            
            const originalFileName = uploadedFile.name.replace(/\.pdf$/i, '');
            downloadLink.href = url;
            downloadLink.download = `${originalFileName}-split-final.pdf`;
            downloadLink.classList.remove('hidden');
            
            showStatus('success', 'PDF successfully created!');

        } catch (err) {
            showStatus('error', `Failed to create PDF: ${err.message}`);
            console.error(err);
        } finally {
            generateButton.disabled = false;
        }
    }
        if (!originalPdfArrayBuffer) return;
        showStatus('loading', 'Generating final PDF...');
        generateButton.disabled = true;

        try {
            const outputPdfDoc = await PDFDocument.create();
            const [embeddedPage] = await outputPdfDoc.embedPdf(originalPdfArrayBuffer.slice(0));
            
            const selectedPaper = paperSizeSelect.value;
            const targetSize = paperDimensions[selectedPaper];
            const paddingPoints = getPaddingValue();
            
            const cutPointsY = [0, ...cutPositions.map(p => p / originalPageSize.scale), originalPageSize.height];

            for (let i = 0; i < cutPointsY.length - 1; i++) {
                const startY_pdf = cutPointsY[i];

                const finalPage = outputPdfDoc.addPage([targetSize.width, targetSize.height]);
                const { width: finalWidth, height: finalHeight } = finalPage.getSize();
                
                const scaleFactor = finalWidth / embeddedPage.width;
                const scaledPageHeight = embeddedPage.height * scaleFactor;

                // --- THE DEFINITIVE MATH FIX for positioning ---
                let contentTopOnNewPage = (i === 0) ? finalHeight : (finalHeight - paddingPoints);
                let y_offset = contentTopOnNewPage - (startY_pdf * scaleFactor);

                // 1. Draw the positioned content.
                finalPage.drawPage(embeddedPage, {
                    x: 0,
                    y: y_offset - scaledPageHeight, // Adjust to position from the top
                    width: finalWidth,
                    height: scaledPageHeight,
                });

                // 2. Draw white boxes ON TOP to create clean margins and a "hard cut".
                const white = rgb(1, 1, 1);

                // Always create a clean bottom margin.
                finalPage.drawRectangle({
                    x: 0, y: 0,
                    width: finalWidth, height: paddingPoints,
                    color: white,
                });

                // For all pages AFTER the first, create a clean top margin.
                if (i !== 0) {
                    finalPage.drawRectangle({
                        x: 0, y: finalHeight - paddingPoints,
                        width: finalWidth, height: paddingPoints,
                        color: white,
                    });
                }
            }

            const pdfBytes = await outputPdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            
            const originalFileName = uploadedFile.name.replace(/\.pdf$/i, '');
            downloadLink.href = url;
            downloadLink.download = `${originalFileName}-split-final.pdf`;
            downloadLink.classList.remove('hidden'); // Show the download button
            
            showStatus('success', 'PDF successfully created!');

        } catch (err) {
            showStatus('error', `Failed to create PDF: ${err.message}`);
            console.error(err);
        } finally {
            generateButton.disabled = false;
        }
    }

    function showStatus(type, message) {
        let color = type === 'error' ? 'text-red-600' : (type === 'success' ? 'text-green-600' : 'text-slate-600');
        const icon = type === 'loading' ? '<div class="spinner mx-auto"></div>' : '';
        statusDiv.innerHTML = `<div class="flex items-center justify-center space-x-2 ${color}">${icon}<p>${message}</p></div>`;
    }
</script>
</body>
</html>