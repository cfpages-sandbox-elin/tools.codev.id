<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PDF Splitter</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js from Mozilla -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- pdf-lib -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        /* Make sure the worker is loaded from the CDN */
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Styles for the draggable cut lines */
        .cut-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 5px;
            background-color: rgba(239, 68, 68, 0.7); /* Red-500 with transparency */
            cursor: ns-resize;
            border-top: 1px dashed white;
            border-bottom: 1px dashed white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .cut-line:hover {
            background-color: rgba(220, 38, 38, 1); /* Red-600 */
        }
        .cut-line .handle {
            width: 60px;
            height: 20px;
            background-color: rgb(239, 68, 68);
            border-radius: 10px;
            color: white;
            font-size: 10px;
            text-align: center;
            line-height: 20px;
            font-family: sans-serif;
            pointer-events: none; /* Let the parent handle drag events */
        }
    </style>
</head>
<body class="bg-slate-100 font-sans">
    <div class="w-full max-w-5xl mx-auto p-4 sm:p-8 my-10 bg-white rounded-xl shadow-lg">

        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-slate-800">Advanced PDF Splitter v1.4</h1>
            <p class="text-slate-500 mt-2">Upload, preview, and adjust split lines before creating your multi-page PDF.</p>
        </div>

        <!-- Settings Section -->
        <div id="settings-section" class="grid grid-cols-1 md:grid-cols-3 gap-6 border-b pb-6 mb-6">
            <!-- File Upload -->
            <div>
                <label class="block text-sm font-medium text-slate-700 mb-2">1. Upload PDF</label>
                <input id="file-upload" type="file" class="block w-full text-sm text-slate-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-indigo-50 file:text-indigo-700
                    hover:file:bg-indigo-100" accept=".pdf">
                <p id="file-name" class="text-xs text-slate-500 mt-2truncate"></p>
            </div>
            <!-- Paper Size -->
            <div>
                <label for="paper-size" class="block text-sm font-medium text-slate-700 mb-2">2. Target Paper Size</label>
                <select id="paper-size" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                    <option value="A4">A4 (210 x 297 mm)</option>
                    <option value="A5">A5 (148 x 210 mm)</option>
                    <option value="Letter">Letter (8.5 x 11 in)</option>
                    <option value="Legal">Legal (8.5 x 14 in)</option>
                    <option value="F4">F4 (210 x 330 mm)</option>
                </select>
            </div>
             <!-- Padding -->
            <div>
                <label for="padding" class="block text-sm font-medium text-slate-700 mb-2">3. Top/Bottom Padding (pts)</label>
                <input type="number" id="padding" value="36" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md" min="0" step="1">
                <p class="text-xs text-slate-500 mt-2">72 pts = 1 inch</p>
            </div>
        </div>

        <!-- Action / Status Bar -->
        <div id="action-bar" class="flex items-center justify-center space-x-4 mb-6">
             <button id="preview-button" type="button" disabled class="px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-slate-400 disabled:cursor-not-allowed">
                Generate Preview
            </button>
             <button id="generate-button" type="button" class="hidden px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                Create Final PDF
            </button>
        </div>
        <div id="status" class="text-center mb-4 min-h-[2rem]"></div>


        <!-- Preview Section -->
        <div id="preview-section" class="hidden">
            <h3 class="text-lg font-semibold text-slate-700 mb-2 text-center">4. Adjust Split Lines</h3>
            <!-- UI text improvement -->
            <p class="text-sm text-slate-500 text-center mb-4">Click and drag a red line to change its page break. Changes will cascade downwards.</p>
            <div id="preview-container" class="relative w-full max-h-[80vh] overflow-y-auto border-2 border-slate-300 bg-slate-200">
                <canvas id="pdf-canvas" class="w-full h-auto"></canvas>
                <div id="cut-lines-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
            </div>
        </div>
        
        <!-- Result Section -->
        <div id="result-section" class="text-center mt-6 hidden">
             <a id="download-link" class="inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-emerald-600 hover:bg-emerald-700">
                Download Split PDF
             </a>
        </div>
    </div>

<script>
    // --- Global State ---
    const { PDFDocument } = PDFLib;
    let uploadedFile = null;
    let originalPdfArrayBuffer = null;
    let originalPageSize = { width: 0, height: 0, scale: 1 };
    let cutPositions = []; // Store the Y-coordinate of each cut line in pixels
    let maxSliceHeightPixels = 0; // The max height of a slice in pixels
    let activeDrag = { lineIndex: -1, startY: 0, originalCutPositions: [] };
    
    // --- UI Elements ---
    const fileInput = document.getElementById('file-upload');
    const fileNameDisplay = document.getElementById('file-name');
    const paperSizeSelect = document.getElementById('paper-size');
    const paddingInput = document.getElementById('padding');
    const previewButton = document.getElementById('preview-button');
    const generateButton = document.getElementById('generate-button');
    const statusDiv = document.getElementById('status');
    const previewSection = document.getElementById('preview-section');
    const canvas = document.getElementById('pdf-canvas');
    const cutLinesContainer = document.getElementById('cut-lines-container');
    const resultSection = document.getElementById('result-section');
    const downloadLink = document.getElementById('download-link');

    // --- Paper Size Ratios (in PDF points) ---
    const paperDimensions = {
        A4: { width: 595.28, height: 841.89 },
        A5: { width: 419.53, height: 595.28 },
        Letter: { width: 612, height: 792 },
        Legal: { width: 612, height: 1008 },
        F4: { width: 595.28, height: 935.43 }
    };

    // --- Event Listeners ---
    fileInput.addEventListener('change', handleFileSelect);
    previewButton.addEventListener('click', renderPreview);
    generateButton.addEventListener('click', createFinalPdf);


    // --- Core Functions ---

    function handleFileSelect(e) {
        uploadedFile = e.target.files[0];
        if (uploadedFile) {
            fileNameDisplay.textContent = uploadedFile.name;
            previewButton.disabled = false;
            previewSection.classList.add('hidden');
            generateButton.classList.add('hidden');
            resultSection.classList.add('hidden');
            statusDiv.innerHTML = '';
        }
    }

    async function renderPreview() {
        if (!uploadedFile) return;
        showStatus('loading', 'Loading and rendering PDF preview...');
        previewButton.disabled = true;
        
        try {
            originalPdfArrayBuffer = await uploadedFile.arrayBuffer();
            const pdfjsDoc = await pdfjsLib.getDocument({ data: originalPdfArrayBuffer.slice(0) }).promise;
            
            if (pdfjsDoc.numPages !== 1) {
                showStatus('error', 'Error: This tool only supports single-page PDFs.');
                return;
            }

            const page = await pdfjsDoc.getPage(1);
            const desiredWidth = 1000;
            const viewport = page.getViewport({ scale: 1 });
            const scale = desiredWidth / viewport.width;
            const scaledViewport = page.getViewport({ scale });

            originalPageSize = {
                width: viewport.width,
                height: viewport.height,
                scale: scale
            };
            
            canvas.height = scaledViewport.height;
            canvas.width = scaledViewport.width;

            // FIX 2: Add willReadFrequently attribute for performance
            const renderContext = {
                canvasContext: canvas.getContext('2d', { willReadFrequently: true }),
                viewport: scaledViewport,
            };
            await page.render(renderContext).promise;

            calculateInitialCutLines();
            drawCutLines();
            
            previewSection.classList.remove('hidden');
            generateButton.classList.remove('hidden');
            showStatus('success', `Preview generated. Found ${cutPositions.length + 1} potential pages.`);
        } catch (err) {
            showStatus('error', `Error rendering preview: ${err.message}`);
        } finally {
            previewButton.disabled = false;
        }
    }

    function calculateInitialCutLines() {
        const selectedPaper = paperSizeSelect.value;
        const targetDims = paperDimensions[selectedPaper];
        const targetRatio = targetDims.height / targetDims.width;
        
        const paddingPoints = parseFloat(paddingInput.value) || 0;
        const targetContentHeightPoints = (originalPageSize.width * targetRatio) - (2 * paddingPoints);

        if (targetContentHeightPoints <= 0) {
            showStatus('error', 'Padding is too large for the selected paper size.');
            cutPositions = [];
            maxSliceHeightPixels = 0;
            return;
        }

        maxSliceHeightPixels = targetContentHeightPoints * originalPageSize.scale;
        
        cutPositions = [];
        let currentY = 0;
        while (currentY < canvas.height) {
            currentY += maxSliceHeightPixels;
            if (currentY < canvas.height) {
                cutPositions.push(Math.round(currentY));
            }
        }
    }

    function drawCutLines() {
        cutLinesContainer.innerHTML = '';
        cutPositions.forEach((yPos, index) => {
            const line = document.createElement('div');
            line.className = 'cut-line';
            line.style.top = `${yPos}px`;
            line.dataset.index = index;
            line.style.pointerEvents = 'auto';

            const handle = document.createElement('div');
            handle.className = 'handle';
            handle.textContent = `Page ${index + 2}`;
            line.appendChild(handle);
            
            line.addEventListener('mousedown', startDrag);
            cutLinesContainer.appendChild(line);
        });
    }

    // --- Drag and Drop Logic ---

    function startDrag(e) {
        e.preventDefault();
        const lineIndex = parseInt(e.target.dataset.index, 10);
        activeDrag = {
            lineIndex,
            startY: e.clientY,
            originalCutPositions: [...cutPositions]
        };
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', endDrag);
    }

    function drag(e) {
        if (activeDrag.lineIndex === -1) return;

        const deltaY = e.clientY - activeDrag.startY;
        const index = activeDrag.lineIndex;
        const originalY = activeDrag.originalCutPositions[index];
        let newY = originalY + deltaY;
        
        const prevLineY = index > 0 ? cutPositions[index - 1] : 0;

        const minAllowedY = prevLineY + 20;
        const maxAllowedY = prevLineY + maxSliceHeightPixels;

        newY = Math.max(minAllowedY, newY);
        newY = Math.min(maxAllowedY, newY);
        
        cutPositions[index] = newY;
        
        const sliceHeight = newY - prevLineY;
        for (let i = index + 1; i < cutPositions.length; i++) {
            cutPositions[i] = cutPositions[i - 1] + sliceHeight;
        }
        
        drawCutLines();
    }

    function endDrag() {
        activeDrag.lineIndex = -1;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', endDrag);
    }
    
    // --- Final PDF Generation ---

    async function createFinalPdf() {
        if (!originalPdfArrayBuffer) return;
        showStatus('loading', 'Generating final PDF...');
        generateButton.disabled = true;

        try {
            const outputPdfDoc = await PDFDocument.create();
            
            // Correctly embed the single page from the original PDF's raw data.
            // This is the most robust way to handle it.
            const [embeddedPage] = await outputPdfDoc.embedPdf(originalPdfArrayBuffer.slice(0));
            
            const selectedPaper = paperSizeSelect.value;
            const targetSize = paperDimensions[selectedPaper];
            const paddingPoints = parseFloat(paddingInput.value) || 0;
            
            // Get the Y-coordinates for slicing, converting from canvas pixels back to PDF points
            const cutPointsY = [0, ...cutPositions.map(p => p / originalPageSize.scale), originalPageSize.height];

            for (let i = 0; i < cutPointsY.length - 1; i++) {
                const startY_pdf = cutPointsY[i]; // Y from top of original
                const endY_pdf = cutPointsY[i + 1]; // Y from top of original
                const sliceHeight_pdf = endY_pdf - startY_pdf;

                // Create a new blank page with the target dimensions
                const newPage = outputPdfDoc.addPage([targetSize.width, targetSize.height]);

                // Calculate where to position the embedded page so the correct slice appears
                // in our clipped view.
                const sourcePage_bottomOfSlice_Y = originalPageSize.height - endY_pdf;
                const y_offset = paddingPoints - sourcePage_bottomOfSlice_Y;

                // --- CORRECTED CLIPPING LOGIC ---
                // Save the page's current state
                newPage.pushGraphicsState();

                // Define a rectangular clipping path. Nothing will be drawn outside this path.
                newPage.drawRectangle({
                    x: 0,
                    y: paddingPoints, // Start clipping at the bottom padding
                    width: newPage.getWidth(),
                    height: sliceHeight_pdf,
                });
                newPage.clip();
                
                // Now, draw the entire embedded page. Because of the clipping path,
                // only the desired slice will actually be visible.
                newPage.drawPage(embeddedPage, {
                    x: 0,
                    y: y_offset,
                    width: originalPageSize.width,
                    height: originalPageSize.height,
                });
                
                // Restore the page's state to remove the clipping path
                newPage.popGraphicsState();
            }

            const pdfBytes = await outputPdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            
            const originalFileName = uploadedFile.name.replace(/\.pdf$/i, '');
            downloadLink.href = url;
            downloadLink.download = `${originalFileName}-split-final.pdf`;
            resultSection.classList.remove('hidden');
            showStatus('success', 'PDF successfully created!');

        } catch (err) {
            showStatus('error', `Failed to create PDF: ${err.message}`);
            console.error(err);
        } finally {
            generateButton.disabled = false;
        }
    }

    function showStatus(type, message) {
        let color = 'text-slate-600';
        if (type === 'error') color = 'text-red-600';
        if (type === 'success') color = 'text-green-600';
        
        const icon = type === 'loading' ? '<div class="spinner mx-auto"></div>' : '';
        
        statusDiv.innerHTML = `
            <div class="flex items-center justify-center space-x-2 ${color}">
                ${icon}
                <p>${message}</p>
            </div>
        `;
    }

</script>
</body>
</html>